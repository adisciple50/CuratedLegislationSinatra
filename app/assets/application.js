(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (global_object.console == null) {
    global_object.console = {};
  }

  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  function $uid() {
    unique_id += 2;
    return unique_id;
  };
  Opal.uid = $uid;

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id == null) {
      $prop(obj, '$$id', $uid());
    }
    return obj.$$id;
  };

  // Globals table
  var $gvars = Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if ($gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    var exception = Opal.exceptions.pop();
    if (exception) {
      $gvars["!"] = exception;
      $gvars["@"] = exception.$backtrace();
    }
    else {
      $gvars["!"] = $gvars["@"] = nil;
    }
  };

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;


  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    var body;

    if (method === 'to_int' && type === Opal.Integer && object.$$is_number)
      return object < 0 ? Math.ceil(object) : Math.floor(object);

    if (method === 'to_str' && type === Opal.String && object.$$is_string)
      return object;

    if (Opal.is_a(object, type)) return object;

    // Fast path for the most common situation
    if (object['$respond_to?'].$$pristine && object.$method_missing.$$pristine) {
      body = object['$' + method];
      if (body == null || body.$$stub) throw Opal.type_error(object, type);
      return body.apply(object, args);
    }

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = $ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name) {
    return (cref || _Object).$const_missing(name);
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);
    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat($ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat($ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  function $allocate_class(name, superclass, singleton) {
    var klass;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      klass = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      klass = function(){};
    }

    if (name && name !== nil) {
      $prop(klass, 'displayName', '::'+name);
    }

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', klass);
    $prop(klass, '$$prototype', klass.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };
  Opal.allocate_class = $allocate_class;


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass != null) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
    }
    else {
      // Class doesn't exist, create a new one with given superclass...

      // Not specifying a superclass means we can assume it to be Object
      if (superclass == null) {
        superclass = _Object;
      }

      // Create the class object (instance of Class)
      klass = $allocate_class(name, superclass);
      $const_set(scope, name, klass);

      // Call .inherited() hook with new class on the superclass
      if (superclass.$inherited) {
        superclass.$inherited(klass);
      }

      if (bridged) {
        Opal.bridge(bridged, klass);
      }
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  function $allocate_module(name) {
    var constructor = function(){};
    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };
  Opal.allocate_module = $allocate_module;

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module == null) {
      // Module doesnt exist, create a new one...
      module = $allocate_module(name);
      $const_set(scope, name, module);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // helper to set $$meta on klass, module or instance
  function set_meta(obj, meta) {
    if (obj.hasOwnProperty('$$meta')) {
      obj.$$meta = meta;
    } else {
      $prop(obj, '$$meta', meta);
    }
    if (obj.$$frozen) {
      // If a object is frozen (sealed), freeze $$meta too.
      // No need to inject $$meta.$$prototype in the prototype chain,
      // as $$meta cannot be modified anyway.
      obj.$$meta.$freeze();
    } else {
      $set_proto(obj, meta.$$prototype);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    var superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    var meta = $allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    set_meta(klass, meta);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = $allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    set_meta(mod, meta);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = $allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    set_meta(object, klass);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = $ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    return obj.$$meta ? Opal.own_instance_methods(obj.$$meta) : [];
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = $ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = $ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = $ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  function $ancestors(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = $ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };
  Opal.ancestors = $ancestors;

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = '$'+stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  function get_ancestors(obj) {
    if (obj.hasOwnProperty('$$meta') && obj.$$meta !== null) {
      return $ancestors(obj.$$meta);
    } else {
      return $ancestors(obj.$$class);
    }
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    ancestors = get_ancestors(obj);

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new(
        "implicit argument passing of super from method defined by define_method() is not supported. " +
        "Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error || candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var ancestors = $ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    return ancestors.indexOf(klass) !== -1;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1);
      return kwargs;
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block, blockopts);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    ancestors = get_ancestors(recv);

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);

      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];

        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;

          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;

          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] === 'undefined') continue;
          refine_module = refine_modules[ancestor];

          // Does this module define a method we want to call?
          if (typeof refine_module.$$prototype['$'+method] !== 'undefined') {
            body = refine_module.$$prototype['$'+method];
            return Opal.send2(recv, body, method, args, block, blockopts);
          }
        }
      }
    }

    return Opal.send(recv, method, args, block, blockopts);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    $deny_frozen_access(module);

    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype['$' + old];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      alias.$$p = null;

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty($gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return $gvars[old_name];
      },
      set: function(new_value) {
        $gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value, key_tmp;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        key_tmp = keys[i];

        if (key_tmp.$$is_string && typeof key_tmp !== "string") {
          key_tmp = key_tmp.valueOf();
        }

        if (key_tmp === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1) {
      args = arguments[0];

      if (arguments[0].$$is_array) {
        length = args.length;

        for (i = 0; i < length; i++) {
          if (args[i].length !== 2) {
            throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
          }

          key = args[i][0];
          value = args[i][1];

          Opal.hash_put(hash, key, value);
        }

        return hash;
      }
      else {
        args = arguments[0];
        for (key in args) {
          if ($has_own.call(args, key)) {
            value = args[key];

            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  var reserved_ivar_names = [
    // properties
    "constructor", "displayName", "__count__", "__noSuchMethod__",
    "__parent__", "__proto__",
    // methods
    "hasOwnProperty", "valueOf"
  ];

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (reserved_ivar_names.indexOf(name) !== -1) {
      name += "$";
    }

    return name;
  };

  // Support for #freeze
  // -------------------

  // helper that can be used from methods
  function $deny_frozen_access(obj) {
    if (obj.$$frozen) {
      throw Opal.FrozenError.$new("can't modify frozen " + (obj.$class()) + ": " + (obj), Opal.hash2(["receiver"], {"receiver": obj}));
    }
  };
  Opal.deny_frozen_access = $deny_frozen_access;

  // common #freeze runtime support
  Opal.freeze = function(obj) {
    $prop(obj, "$$frozen", true);

    // set $$id
    if (!obj.hasOwnProperty('$$id')) { $prop(obj, '$$id', $uid()); }

    if (obj.hasOwnProperty('$$meta')) {
      // freeze $$meta if it has already been set
      obj.$$meta.$freeze();
    } else {
      // ensure $$meta can be set lazily, $$meta is frozen when set in runtime.js
      $prop(obj, '$$meta', null);
    }

    // $$comparable is used internally and set multiple times
    // defining it before sealing ensures it can be modified later on
    if (!obj.hasOwnProperty('$$comparable')) { $prop(obj, '$$comparable', null); }

    // seal the Object
    Object.seal(obj);

    return obj;
  };

  // freze props, make setters of instance variables throw FrozenError
  Opal.freeze_props = function(obj) {
    var prop, prop_type, desc;

    for(prop in obj) {
      prop_type = typeof(prop);

      // prop_type "object" here is a String(), skip $ props
      if ((prop_type === "string" || prop_type === "object") && prop[0] === '$') {
        continue;
      }

      desc = Object.getOwnPropertyDescriptor(obj, prop);
      if (desc && desc.enumerable && desc.writable) {
        // create closure to retain current value as cv
        // for Opal 2.0 let for cv should do the trick, instead of a function
        (function() {
          // set v to undefined, as if the property is not set
          var cv = obj[prop];
          Object.defineProperty(obj, prop, {
            get: function() { return cv; },
            set: function(_val) { $deny_frozen_access(obj); },
            enumerable: true
          });
        })();
      }
    }
  };

  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result, flags;

    // RegExp already has the global and multiline flag
    if (pattern.global && pattern.multiline) return pattern;

    flags = 'gm' + (pattern.ignoreCase ? 'i' : '');
    if (pattern.multiline) {
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g == null) {
        pattern.$$g = new RegExp(pattern.source, flags);
      }
      result = pattern.$$g;
    } else {
      if (pattern.$$gm == null) {
        pattern.$$gm = new RegExp(pattern.source, flags);
      }
      result = pattern.$$gm;
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load_normalized = function(path) {
    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then($return_val(true));
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    return Opal.load_normalized(path);
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load_normalized(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------

  function are_both_numbers(l,r) { return typeof(l) === 'number' && typeof(r) === 'number' }

  Opal.rb_plus   = function(l,r) { return are_both_numbers(l,r) ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return are_both_numbers(l,r) ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return are_both_numbers(l,r) ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return are_both_numbers(l,r) ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return are_both_numbers(l,r) ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return are_both_numbers(l,r) ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return are_both_numbers(l,r) ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return are_both_numbers(l,r) ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  function are_both_numbers_or_strings(lhs, rhs) {
    return (typeof lhs === 'number' && typeof rhs === 'number') ||
           (typeof lhs === 'string' && typeof rhs === 'string');
  }

  function $eqeq(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeq = $eqeq;
  Opal.eqeqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs !== rhs : $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    if (true === arg || arg['$!'].$$pristine) return false;
    return $truthy(arg['$!']());
  }

  // Shortcuts - optimized function generators for simple kinds of functions
  function $return_val(arg) {
    return function() {
      return arg;
    }
  }
  Opal.return_val = $return_val;

  Opal.return_self = function() {
    return this;
  }
  Opal.return_ivar = function(ivar) {
    return function() {
      if (this[ivar] == null) { return nil; }
      return this[ivar];
    }
  }
  Opal.assign_ivar = function(ivar) {
    return function(val) {
      $deny_frozen_access(this);
      return this[ivar] = val;
    }
  }
  Opal.assign_ivar_val = function(ivar, static_val) {
    return function() {
      $deny_frozen_access(this);
      return this[ivar] = static_val;
    }
  }

  // Primitives for handling parameters
  Opal.ensure_kwargs = function(kwargs) {
    if (kwargs == null) {
      return Opal.hash2([], {});
    } else if (kwargs.$$is_hash) {
      return kwargs;
    } else {
      throw Opal.ArgumentError.$new('expected kwargs');
    }
  }

  Opal.get_kwarg = function(kwargs, key) {
    if (!$has_own.call(kwargs.$$smap, key)) {
      throw Opal.ArgumentError.$new('missing keyword: '+key);
    }
    return kwargs.$$smap[key];
  }

  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = $allocate_class('BasicObject', null);
  Opal.Object      = _Object     = $allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = $allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = $allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = $allocate_module('Opal');
  Opal.Kernel      = Kernel      = $allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const.BasicObject = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = $return_val('main');
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };

  // Nil
  Opal.NilClass = $allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };
  nil.$$frozen = true;
  nil.$$comparable = false;
  Object.seal(nil);

  Opal.thrower = function(type) {
    var thrower = new Error('unexpected '+type);
    thrower.$thrower_type = type;
    thrower.$throw = function(value) {
      if (value == null) value = nil;
      thrower.$v = value;
      throw thrower;
    };
    return thrower;
  };

  Opal.t_eval_return = Opal.thrower("return");

  TypeError.$$super = Error;

  // If enable-file-source-embed compiler option is enabled, each module loaded will add its
  // sources to this object
  Opal.file_sources = {};
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/irb"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $module = Opal.module, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $hash = Opal.hash, $gvars = Opal.gvars, $lambda = Opal.lambda, $send = Opal.send, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $range = Opal.range, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include?,raise,attr_accessor,singleton_class,output=,browser?,each,dup,write_proc=,proc,+,output,join,last,split,end_with?,call,write_proc,tty=,read_proc,read_proc=,freeze,new,string,ensure_loaded,prepare_console,loop,print,gets,puts,start_with?,[],==,silence,message,empty?,warnings,warn,full_message,eval_and_print,irb');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'IRB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$ensure_loaded', function $$ensure_loaded(library) {
        var version = nil, url = nil;

        
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        };
        version = ($truthy($$('RUBY_ENGINE_VERSION')['$include?']("dev")) ? ("master") : ($$('RUBY_ENGINE_VERSION')));
        url = "https://cdn.opalrb.com/opal/" + (version) + "/" + (library) + ".js";
        
        var libcode;

        if (typeof XMLHttpRequest !== 'undefined') { // Browser
          var r = new XMLHttpRequest();
          r.open("GET", url, false);
          r.send('');
          libcode = r.responseText;
        }
        else {
          $Kernel.$raise("You need to provision " + (library) + " yourself in this environment")
        }

        (new Function('Opal', libcode))(Opal);

        Opal.require(library);
      ;
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        } else {
          return $Kernel.$raise("Could not load " + (library) + " for some reason")
        };
      }, 1);
      self.$singleton_class().$attr_accessor("output");
      $defs(self, '$prepare_console', function $$prepare_console() {
        var block = $$prepare_console.$$p || nil, $a, self = this, original = nil, original_read_proc = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $$prepare_console.$$p = null;
        
        ;
        return (function() { try {
        
        self['$output=']("");
        original = $hash($gvars.stdout, $lambda(function $$1(i){
          
          if (i == null) i = nil;
          return ($gvars.stdout = i);}, 1), $gvars.stderr, $lambda(function $$2(i){
          
          if (i == null) i = nil;
          return ($gvars.stderr = i);}, 1));
        if ($truthy(self['$browser?']())) {
          
          $send(original, 'each', [], function $$3(pipe, pipe_setter){var self = $$3.$$s == null ? this : $$3.$$s, new_pipe = nil;

            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            new_pipe = pipe.$dup();
            new_pipe['$write_proc=']($send(self, 'proc', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (str == null) str = nil;
              self['$output=']($rb_plus(self.$output(), str));
              self['$output='](self.$output().$split("\n").$last(30).$join("\n"));
              if ($truthy(str['$end_with?']("\n"))) {
                self['$output=']($rb_plus(self.$output(), "\n"))
              };
              return pipe.$write_proc().$call(str);}, {$$arity: 1, $$s: self}));
            new_pipe['$tty='](false);
            return pipe_setter.$call(new_pipe);}, {$$arity: 2, $$s: self});
          original_read_proc = $gvars.stdin.$read_proc();
          $gvars.stdin['$read_proc='](function(s) { var p = prompt(self.$output()); if (p !== null) return p + "\n"; return nil; });
        };
        return Opal.yieldX(block, []);;
        } finally {
          ($send(original, 'each', [], function $$5(pipe, pipe_setter){
            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            return pipe_setter.$call(pipe);}, 2), ($a = [original_read_proc], $send($gvars.stdin, 'read_proc=', $a), $a[$a.length - 1]), ($a = [""], $send(self, 'output=', $a), $a[$a.length - 1]))
        }; })();
      }, 0);
      $defs(self, '$browser?', function $IRB_browser$ques$6() {
        
        return typeof(document) !== 'undefined' && typeof(prompt) !== 'undefined';
      }, 0);
      $const_set($nesting[0], 'LINEBREAKS', ["unexpected token $end", "unterminated string meets end of file"].$freeze());
      return (function($base, $super) {
        var self = $klass($base, $super, 'Silencer');

        var $proto = self.$$prototype;

        $proto.collector = $proto.stderr = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.stderr = $gvars.stderr)
        }, 0);
        
        $def(self, '$silence', function $$silence() {
          var $yield = $$silence.$$p || nil, self = this;

          $$silence.$$p = null;
          return (function() { try {
          
          self.collector = $$$('StringIO').$new();
          $gvars.stderr = self.collector;
          return Opal.yieldX($yield, []);;
          } finally {
            ($gvars.stderr = self.stderr)
          }; })()
        }, 0);
        return $def(self, '$warnings', function $$warnings() {
          var self = this;

          return self.collector.$string()
        }, 0);
      })($nesting[0], null);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Binding');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$irb', function $$irb() {try { var $t_return = $thrower('return'); 
      var self = this, silencer = nil;

      
      $$$($Opal, 'IRB').$ensure_loaded("opal-replutils");
      silencer = $$$($$$($Opal, 'IRB'), 'Silencer').$new();
      return $send($$$($Opal, 'IRB'), 'prepare_console', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        return (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s, line = nil, code = nil, mode = nil, js_code = nil, e = nil;

          
          self.$print(">> ");
          line = self.$gets();
          if (!$truthy(line)) {
            $t_break.$throw()
          };
          code = "";
          if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
            self.$puts(line)
          };
          if ($truthy(line['$start_with?']("ls "))) {
            
            code = line['$[]']($range(3, -1, false));
            mode = "ls";
          } else if ($eqeq(line, "ls\n")) {
            
            code = "self";
            mode = "ls";
          } else if ($truthy(line['$start_with?']("show "))) {
            
            code = line['$[]']($range(5, -1, false));
            mode = "show";
          } else {
            
            code = line;
            mode = "inspect";
          };
          js_code = nil;
          
          do { try {
            $send(silencer, 'silence', [], function $$9(){
              return (js_code = Opal.compile(code, {irb: true}))}, 0)
          } catch ($err) {
            if (Opal.rescue($err, [$$('SyntaxError')])) {(e = $err)
              try {
                if ($truthy($$$($$$($Opal, 'IRB'), 'LINEBREAKS')['$include?'](e.$message()))) {
                  
                  self.$print(".. ");
                  line = self.$gets();
                  if (!$truthy(line)) {
                    $t_return.$throw()
                  };
                  if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
                    self.$puts(line)
                  };
                  code = $rb_plus(code, line);
                  continue;
                } else if ($truthy(silencer.$warnings()['$empty?']())) {
                  self.$warn(e.$full_message())
                } else {
                  self.$warn(silencer.$warnings())
                }
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          } break; } while(1);;
          if ($eqeq(mode, "show")) {
            
            self.$puts(js_code);
            $t_return.$throw();
          };
          return self.$puts($$$('REPLUtils').$eval_and_print(js_code, mode, false, self));}, {$$arity: 0, $$s: self, $$ret: $t_return})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})()}, {$$arity: 0, $$s: self});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, 0)
  })('::', null, $nesting);
  
  // Run in WebTools console with: Opal.irb(c => eval(c))
  Opal.irb = function(fun) {
    $$$('Binding').$new(fun).$irb()
  }

  Opal.load_parser = function() {
    Opal.Opal.IRB.$ensure_loaded('opal-parser');
  }

  if (typeof Opal.eval === 'undefined') {
    Opal.eval = function(str) {
      Opal.load_parser();
      return Opal.eval(str);
    }
  }

  if (typeof Opal.compile === 'undefined') {
    Opal.compile = function(str, options) {
      Opal.load_parser();
      return Opal.compile(str, options);
    }
  }
;
};

Opal.modules["corelib/binding"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $Kernel = Opal.Kernel, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $module = Opal.module, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('js_eval,call,raise,inspect,include?,==,receiver,eval,attr_reader,new');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Binding');

    var $proto = self.$$prototype;

    $proto.jseval = $proto.scope_variables = nil;
    
    
    $def(self, '$initialize', function $$initialize(jseval, scope_variables, receiver, source_location) {
      var $a, self = this;

      
      if (scope_variables == null) scope_variables = [];
      ;
      if (source_location == null) source_location = nil;
      $a = [jseval, scope_variables, receiver, source_location], (self.jseval = $a[0]), (self.scope_variables = $a[1]), (self.receiver = $a[2]), (self.source_location = $a[3]), $a;
      if ($truthy(typeof receiver !== undefined)) {
        return nil
      } else {
        return (receiver = self.$js_eval("self"))
      };
    }, -2);
    
    $def(self, '$js_eval', function $$js_eval($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(self.jseval)) {
        return $send(self.jseval, 'call', $to_a(args))
      } else {
        return $Kernel.$raise("Evaluation on a Proc#binding is not supported")
      };
    }, -1);
    
    $def(self, '$local_variable_get', function $$local_variable_get(symbol) {
      var self = this;

      try {
        return self.$js_eval(symbol)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {
          try {
            return $Kernel.$raise($$$('NameError'), "local variable `" + (symbol) + "' is not defined for " + (self.$inspect()))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$local_variable_set', function $$local_variable_set(symbol, value) {
      var self = this;

      
      Opal.Binding.tmp_value = value;
      self.$js_eval("" + (symbol) + " = Opal.Binding.tmp_value");
      delete Opal.Binding.tmp_value;
      return value;
    }, 2);
    
    $def(self, '$local_variables', $return_ivar("scope_variables"), 0);
    
    $def(self, '$local_variable_defined?', function $Binding_local_variable_defined$ques$1(value) {
      var self = this;

      return self.scope_variables['$include?'](value)
    }, 1);
    
    $def(self, '$eval', function $Binding_eval$2(str, file, line) {try { var $t_eval_return = $thrower('eval_return'); 
      var self = this;

      
      if (file == null) file = nil;
      if (line == null) line = nil;
      if ($eqeq(str, "self")) {
        return self.$receiver()
      };
      return $Kernel.$eval(str, self, file, line);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    }, -2);
    return self.$attr_reader("receiver", "source_location");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$binding', function $$binding() {
      
      return $Kernel.$raise("Opal doesn't support dynamic calls to binding")
    }, 0)
  })('::');
  return $const_set($nesting[0], 'TOPLEVEL_BINDING', $$$('Binding').$new(
    function(js) {
      return (new Function("self", "return " + js))(self);
    }
  , [], self, ["<main>", 0]));
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $module = Opal.module, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (method_name == null) method_name = nil;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $rest_arg;

        
        $post_args = $slice.call(arguments);
        $rest_arg = $post_args;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$arity: 1, $$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    return $def(self, '$tainted?', function $Kernel_tainted$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    }, 0);
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$4($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false), 0);
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      return [];
    }, -1);
    $alias(self, "protected_methods", "private_methods");
    $alias(self, "private_instance_methods", "private_methods");
    return $alias(self, "protected_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$5($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$6($a) {
    var $post_args, methods;

    
    $post_args = $slice.call(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$7($a) {
    var $post_args, methods;

    
    $post_args = $slice.call(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, 1);
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      if (seed == null) seed = $$$('Random').$new_seed();
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, 1);
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    }, 0);
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      if (n == null) n = $$$('Random').$new_seed();
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    }, 1);
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$arity: 0, $$s: self}).$join().$encode("ASCII-8BIT");
    }, 1);
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    }, 1);
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, 0);
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    }, 0);
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, 1);
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $return_val = Opal.return_val, $Kernel = Opal.Kernel, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', $return_val(0), 0);
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, 0);
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      if (unit == null) unit = "float_second";
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + (unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $return_val = Opal.return_val, nil = Opal.nil;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', $return_val(nil), 0)
  })('::', null);
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $slice = Opal.slice, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        if (level == null) level = 1;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        if (suffix == null) suffix = nil;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, 1);
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      }, 1);
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], function $$3(f){
          
          if (f == null) f = nil;
          return f['$=~']($regexp(["^", path]));}, 1);
        return file;
      }, 1);
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        $post_args = $slice.call(arguments);
        paths = $post_args;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          if (item == null) item = nil;
          if (index == null) index = nil;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };}, 2);
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          if (item == null) item = nil;
          if (index == null) index = nil;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };}, 2);
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      }, 1);
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[],pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        $$chdir.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, 1);
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      }, 0);
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, 0);
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $hash2 = Opal.hash2, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,args,each_with_object,flatten,to_a,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      $Struct_new$1.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      args = $post_args;
      
      keyword_init = $kwargs.$$smap["keyword_init"];if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        if (arg == null) arg = nil;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");}, 1);
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          if (arg == null) arg = nil;
          return self.$define_struct_attribute(arg);}, {$$arity: 1, $$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$arity: 0, $$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$arity: 0, $$s: self});
      return $send(self, 'define_method', ["" + (name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        if (value == null) value = nil;
        return self.$$data[name] = value;;}, {$$arity: 1, $$s: self});
    }, 1);
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    }, 0);
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$arity: 0, $$s: self});
    }, 1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ($hash2([], {})));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + (extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var $b, self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return ($b = [name, kwargs['$[]'](name)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 1, $$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var $b, self = $$10.$$s == null ? this : $$10.$$s;

          
          if (name == null) name = nil;
          if (index == null) index = nil;
          return ($b = [name, args['$[]'](index)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 2, $$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, 1);
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    }, 0);
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return $$('Hash').$new(self.$$data).$hash()
    }, 0);
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    }, 1);
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    }, 2);
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (name == null) name = nil;
        return self['$[]'](name);}, {$$arity: 1, $$s: self})
    }, 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, "" + (self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          return "" + (name) + "=" + ($$('Opal').$inspect(value));}, 2).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(self.$args()))
      };
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], function $$22(name, h){var $a, self = $$22.$$s == null ? this : $$22.$$s;

        
        if (name == null) name = nil;
        if (h == null) h = nil;
        return ($a = [name, self['$[]'](name)], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      args = $send(args, 'map', [], function $$23(arg){
        
        if (arg == null) arg = nil;
        return arg.$$is_range ? arg.$to_a() : arg;}, 1).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice.call(arguments, 1);
      keys = $post_args;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $slice = Opal.slice, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.timezone = seconds.timezone;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (utc_offset == null) utc_offset = nil;
      
      var args, result, timezone, utc_date;

      if (year === undefined) {
        return new Date();
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      if (utc_offset === nil) {
        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }

      timezone = self.$_parse_offset(utc_offset);
      utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        utc_date.setUTCFullYear(year);
      }

      result = new Date(utc_date.getTime() - timezone * 3600000);
      result.timezone = timezone;

      return result;
    ;
    }, -1);
    $defs(self, '$_parse_offset', function $$_parse_offset(utc_offset) {
      
      
      var timezone;
      if (utc_offset.$$is_string) {
        if (utc_offset == 'UTC') {
          timezone = 0;
        }
        else if(/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
          var sign, hours, minutes;
          sign = utc_offset[0];
          hours = +(utc_offset[1] + utc_offset[2]);
          minutes = +(utc_offset[4] + utc_offset[5]);

          timezone = (sign == '-' ? -1 : 1) * (hours + minutes / 60);
        }
        else {
          // Unsupported: "A".."I","K".."Z"
          $Kernel.$raise($$$('ArgumentError'), "\"+HH:MM\", \"-HH:MM\", \"UTC\" expected for utc_offset: " + (utc_offset))
        }
      }
      else if (utc_offset.$$is_number) {
        timezone = utc_offset / 3600;
      }
      else {
        $Kernel.$raise($$$('ArgumentError'), "Opal doesn't support other types for a timezone argument than Integer and String")
      }
      return timezone;
    
    }, 1);
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.timezone = 0;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    }, 0);
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    }, 1);
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    }, 1);
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, 1);
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, 0);
    $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], 'each', [], function $Time$6(method, getter, utcgetter, difference){var self = $Time$6.$$s == null ? this : $Time$6.$$s;

      
      if (method == null) method = nil;
      if (getter == null) getter = nil;
      if (utcgetter == null) utcgetter = nil;
      if (difference == null) difference = 0;
      return $send(self, 'define_method', [method], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        return difference + ((self.timezone != null) ?
          (new Date(self.getTime() + self.timezone * 3600000))[utcgetter]() :
          self[getter]())
      }, {$$arity: 0, $$s: self});}, {$$arity: -4, $$s: self});
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, 0);
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$eql?', function $Time_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    }, 1);
    $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], 'each', [], function $Time$9(method, weekday){var self = $Time$9.$$s == null ? this : $Time$9.$$s;

      
      if (method == null) method = nil;
      if (weekday == null) weekday = nil;
      return $send(self, 'define_method', [method], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$wday() === weekday}, {$$arity: 0, $$s: self});}, {$$arity: 2, $$s: self});
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, 0);
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.timezone = self.timezone;
      return result;
    
    }, 0);
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, 0);
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      if (self.timezone === 0) return "UTC";
      else if (self.timezone != null) return nil;

      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.timezone = 0;
      return result;
    
    }, 0);
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      if (self.timezone !== 0) {
        $deny_frozen_access(self);
        self.timezone = 0;
      }
      return self;
    
    }, 0);
    
    $def(self, '$gmt?', function $Time_gmt$ques$11() {
      var self = this;

      return self.timezone === 0;
    }, 0);
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return (self.timezone != null) ? self.timezone * 60 : -self.getTimezoneOffset() * 60;
    }, 0);
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "", jd, c, s,
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = (self.timezone == null) ? self.getTimezoneOffset() : (-self.timezone * 60),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          // Non-standard: JIS X 0301 date format
          case 'J':
            jd = self.$to_date().$jd();
            if (jd < 2405160) {
              result += self.$strftime("%Y-%m-%d");
              break;
            }
            else if (jd < 2419614)
              c = 'M', s = 1867;
            else if (jd < 2424875)
              c = 'T', s = 1911;
            else if (jd < 2447535)
              c = 'S', s = 1925;
            else if (jd < 2458605)
              c = 'H', s = 1988;
            else
              c = 'R', s = 2018;

            result += self.$format("%c%02d", c, $rb_minus(self.$year(), s));
            result += self.$strftime("-%m-%d");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, 1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, 0);
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    }, 0);
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        self.$$comparable = false;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      if (max == null) max = nil;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,freeze,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, 2);
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, 2);
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      self.den = den;
      return self.$freeze();
    }, 2);
    
    $def(self, '$numerator', $return_ivar("num"), 0);
    
    $def(self, '$denominator', $return_ivar("den"), 0);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    }, 1);
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    }, 0);
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Rational:" + (self.num) + ":" + (self.den)
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      if (precision == null) precision = 0;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    }, 0);
    
    $def(self, '$to_r', $return_self, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, 0);
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    }, 2);
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    }, 1);
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $module = Opal.module, $def = Opal.def, $klass = Opal.klass, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      if (denominator == null) denominator = 1;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    }, 0)
  })('::', null);
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $return_self = Opal.return_self, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $return_val = Opal.return_val, $Opal = Opal.Opal, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    }, 1);
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else 
      switch (method) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "&":
        case "|":
        case "^":
        case "**":
          return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")
        case ">":
        case ">=":
        case "<":
        case "<=":
        case "<=>":
          return $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
        default:
          return nil
      }
    }, 2);
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    }, 1);
    
    $def(self, '$+@', $return_self, 0);
    
    $def(self, '$-@', function $Numeric_$minus$$2() {
      var self = this;

      return $rb_minus(0, self)
    }, 0);
    
    $def(self, '$%', function $Numeric_$percent$3(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', $return_self, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, 0);
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    }, 1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, 1);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    }, 0);
    
    $def(self, '$imag', $return_val(0), 0);
    
    $def(self, '$integer?', $return_val(false), 0);
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$4() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    }, 1);
    
    $def(self, '$real', $return_self, 0);
    
    $def(self, '$real?', $return_val(true), 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    }, 0);
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, self = this, counter = nil;

      $$step.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
      
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    }, 0);
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    }, 0);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$5() {
      var self = this;

      return self['$=='](0)
    }, 0);
    
    $def(self, '$positive?', function $Numeric_positive$ques$6() {
      var self = this;

      return $rb_gt(self, 0)
    }, 0);
    
    $def(self, '$negative?', function $Numeric_negative$ques$7() {
      var self = this;

      return $rb_lt(self, 0)
    }, 0);
    
    $def(self, '$dup', $return_self, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', $return_val(true), 0);
    
    $def(self, '$infinite?', $return_val(nil), 0);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $return_val = Opal.return_val, $const_set = Opal.const_set, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,freeze,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      if (theta == null) theta = 0;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      self.real = real;
      self.imag = imag;
      return self.$freeze();
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, 1);
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, 0);
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
          
            $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            while ($eqeq(mod, 0)) {
            
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    }, 0);
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    }, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, 0);
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, 1);
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Complex:" + (self.real) + ":" + (self.imag)
    }, 0);
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', $return_val(false), 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    }, 0);
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    }, 1);
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      if (imag == null) imag = nil;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    }, 0)
  })('::', null, $nesting);
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $slice = Opal.slice, $Kernel = Opal.Kernel, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    self.$module_function();
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], 'each', [], function $Math$3(method){var self = $Math$3.$$s == null ? this : $Math$3.$$s;

      
      if (method == null) method = nil;
      return $send(self, 'define_method', [method], function $$4(x){
        
        if (x == null) x = nil;
        return $$$('Math').$checked(method, $$$('Math')['$float!'](x));}, 1);}, {$$arity: 1, $$s: self});
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    }, 2);
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    }, 2);
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, 1);
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, 1);
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, 2);
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, 1);
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    }, 1);
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    }, 1);
    return $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    }, 1);
  })('::', $nesting)
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $a, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=');
  
  self.$require("corelib/string");
  (function($base, $super) {
    var self = $klass($base, $super, 'Encoding');

    var $proto = self.$$prototype;

    $proto.name = $proto.dummy = nil;
    
    $defs(self, '$register', function $$register(name, options) {
      var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

      $$register.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
      ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
      dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())
      };
      register = Opal.encodings;
      return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

        
        if (encoding_name == null) encoding_name = nil;
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, {$$arity: 1, $$s: self});
    }, -2);
    $defs(self, '$find', function $$find(name) {
      var self = this;

      
      if ($eqeq(name, "default_external")) {
        return self.$default_external()
      };
      return Opal.find_encoding(name);;
    }, 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, 4);
    
    $def(self, '$ascii_compatible?', $return_ivar("ascii"), 0);
    
    $def(self, '$dummy?', $return_ivar("dummy"), 0);
    
    $def(self, '$binary?', $return_val(false), 0);
    
    $def(self, '$to_s', $return_ivar("name"), 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + (self.name) + (($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    }, 0);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, 1);
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    
    $def(self, '$bytesize', function $$bytesize($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    $klass('::', $$$('StandardError'), 'EncodingError');
    return ($klass('::', $$$('EncodingError'), 'CompatibilityError'), nil);
  })('::', null);
  $send($$$('Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.$bytes().$length()
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 2;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_16LE')})], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 4;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_32LE')})], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      return string.length;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1);
    
    $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length;
    }, 1);
    return $def(self, '$binary?', $return_val(true), 0);}, {$$arity: 0, $$s: self});
  $$$('Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  $$$('Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    var $proto = self.$$prototype;

    $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.prop(String.prototype, 'bytes', nil);
    Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
    Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
    
    $def(self, '$b', function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, 0);
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, 0);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

          return self.$bytesize()}, {$$arity: 0, $$s: self})
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$bytes', function $$bytes() {
      var self = this, $ret_or_1 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = ($truthy(($ret_or_1 = self.bytes)) ? ($ret_or_1) : (self.$each_byte().$to_a()));
      return self.bytes.$dup();
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$length()}, {$$arity: 0, $$s: self})
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      $$chars.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, 0);
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      $$each_codepoint.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      $$codepoints.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    }, 0);
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, 1);
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_s");
      encoding = $$$('Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, 1);
    
    $def(self, '$getbyte', function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil
      };
      return string_bytes['$[]'](idx);
    }, 1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, 1);
    return $def(self, '$valid_encoding?', $return_val(true), 0);
  })('::', null);
  return ($a = [$$$($$('Encoding'), 'UTF_8')], $send($$$('Encoding'), 'default_external=', $a), $a[$a.length - 1]);
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $coerce_to = Opal.coerce_to, $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/string");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/io");
  return $Object.$require("opal/regexp_anchors");
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, $hash2 = Opal.hash2, nil = Opal.nil;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, nil = Opal.nil, $$$ = Opal.$$$, mersenne_twister = nil;

  Opal.add_stubs('generator=');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $a;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    return ($a = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')], $send(self, 'generator=', $a), $a[$a.length - 1]);
  })('::', null);
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $range = Opal.range, $send = Opal.send, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        if (count == null) count = nil;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        if (count == null) count = nil;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        if (count == null) count = nil;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        if (count == null) count = nil;
        if (padding == null) padding = false;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil;

        
        str = self.$hex(16).$split("");
        str['$[]='](12, "4");
        str['$[]='](16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16));
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, 0);
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          if (i == null) i = nil;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, 1);
        return $rb_divide(num.$abs(), 2147483647);
      }, 0);
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        if (count == null) count = nil;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (i == null) i = nil;
          return map['$[]'](self.$random_number(map.$length()));}, {$$arity: 1, $$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $return_self = Opal.return_self, $Opal = Opal.Opal, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!,dup');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      $Proc_new$1.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk, $ret = self.$$ret;

      if ($brk || ($ret && self.$$is_lambda)) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return err.$v;
          }
          else if (self.$$is_lambda && err === $ret) {
            return err.$v;
          }
          else {
            throw err;
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      $Proc_$gt$gt$2.$$p = null;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        $$3.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      $Proc_$lt$lt$4.$$p = null;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        $$5.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$to_proc', $return_self, 0);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    }, 0);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      
      if (self.$$is_curried) { return nil; };
      if ($truthy(($ret_or_1 = self.$$source_location))) {
        return $ret_or_1
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, 0);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, 0);
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $coerce_to = Opal.coerce_to, $prop = Opal.prop, $freeze = Opal.freeze, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $alias = Opal.alias, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $ensure_kwargs = Opal.ensure_kwargs, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,frozen?,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        $$allocate.$$p = null;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      }, 0);
      
      $def(self, '$escape', function $$escape(string) {
        
        return Opal.escape_regexp(string);
      }, 1);
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (n == null) n = nil;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        $post_args = $slice.call(arguments);
        parts = $post_args;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + (regexp) + "/")
        }

        regexp = regexp.replace('\\A', '^').replace('\\z', '$')

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, 1);
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    }, 1);
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$g')) { $prop(self, '$$g', null); }
      if (!self.hasOwnProperty('$$gm')) { $prop(self, '$$gm', null); }

      return $freeze(self);
    ;
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, 0);
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      $$match.$$p = null;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$uniq()
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        if (i == null) i = nil;
        return $send(i, 'map', [], function $$7(j){
          
          if (j == null) j = nil;
          return $rb_plus(j.$last(), 1);}, 1);}, 1)
    }, 0);
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, 0);
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.source;
    }, 0);
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      return result;
    
    }, 0);
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    }, 0);
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + (idx) + " out of matches")
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : $a.$length())
    }, 1);
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, 1);
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, 1);
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, 1);
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        if (i == null) i = nil;
        return matches['$[]']($rb_minus(i.$last(), 1));}, 1);
    }, 0);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        if (k == null) k = nil;
        if (v == null) v = nil;
        return                str += " " + k + ":" + v.$inspect();}, 2)
      }

      return str + ">";
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    }, 0);
    
    $def(self, '$to_a', $return_ivar("matches"), 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $module = Opal.module, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $Opal = Opal.Opal, $thrower = Opal.thrower, $def = Opal.def, $Kernel = Opal.Kernel, $return_val = Opal.return_val, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $hash2 = Opal.hash2, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,to_proc,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries');
  return (function($base) {
    var self = $module($base, 'Enumerable');

    
    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      $Enumerable_all$ques$1.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      $Enumerable_any$ques$5.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      $$chunk.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        if (yielder == null) yielder = nil;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      $$chunk_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        if (before == null) before = nil;
        if (after == null) after = nil;
        return Opal.yieldX(block, [before, after])['$!']();}, 2);
    }, 0);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      $$collect_concat.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send(self, 'map', [], block.$to_proc()).$flatten(1);
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      $$count.$$p = null;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$14($a){var $post_args, args;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], $return_val(true), 0)
      };
      $send(self, 'each', [], function $$15($a){var $post_args, args;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try { var $t_return = $thrower('return'); 
      var block = $$detect.$$p || nil, self = this;

      $$detect.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$17($a){var $post_args, args, value = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          $t_return.$throw(value)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, 1);
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      $$drop_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      $$each_cons.$$p = null;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    }, 1);
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      $$each_entry.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      data = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      $$each_slice.$$p = null;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      $$each_with_index.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      $$each_with_object.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, 1);
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      $$filter_map.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, 0);
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      $$find_all.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$find_index', function $$find_index(object) {try { var $t_return = $thrower('return'); 
      var block = $$find_index.$$p || nil, self = this, index = nil;

      $$find_index.$$p = null;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$25($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($eqeq($Opal.$destructure(value), object)) {
            $t_return.$throw(index)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$26($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(index)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      };
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$first', function $$first(number) {try { var $t_return = $thrower('return'); 
      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$27(value){
          
          if (value == null) value = nil;
          $t_return.$throw(value);}, {$$arity: 1, $$ret: $t_return})
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$28($a){var $post_args, args;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            $t_return.$throw(result)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return});
        return result;
      };} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      $$grep.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$29($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice.call(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      $$grep_v.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$30($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice.call(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, $a, self = this, hash = nil, $ret_or_1 = nil;

      $$group_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : (($a = [value, []], $send(hash, '[]=', $a), $a[$a.length - 1])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, 0);
    
    $def(self, '$include?', function $Enumerable_include$ques$32(obj) {try { var $t_return = $thrower('return'); 
      var self = this;

      
      $send(self, 'each', [], function $$33($a){var $post_args, args;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        if ($eqeq($Opal.$destructure(args), obj)) {
          $t_return.$throw(true)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, 1);
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      $$inject.$$p = null;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$34(enum$, $a){var $post_args, args;

        
        if (enum$ == null) enum$ = nil;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    }, 0);
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      $$max_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$36(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            return Opal.yieldX(block, [a, b]);;}, 2).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      $$min_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      $$minmax.$$p = null;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$38(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$<=>'](b);}, 2)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, 0);
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      $$minmax_by.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, 0);
    
    $def(self, '$none?', function $Enumerable_none$ques$40(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_none$ques$40.$$p || nil, self = this;

      $Enumerable_none$ques$40.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$41($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$42($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$43($a){var $post_args, value, item = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$44(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_one$ques$44.$$p || nil, self = this, count = nil;

      $Enumerable_one$ques$44.$$p = null;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$45($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              $t_return.$throw(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$46($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$47($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if (!$truthy($Opal.$destructure(value))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return count['$=='](1);} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      $$partition.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      $$slice_before.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$51(e){var self = $$51.$$s == null ? this : $$51.$$s;

        
        if (e == null) e = nil;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      $$slice_after.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$52(e){
          
          if (e == null) e = nil;
          return pattern['$==='](e);}, 1)
      };
      return $send($$$('Enumerator'), 'new', [], function $$53(yielder){var self = $$53.$$s == null ? this : $$53.$$s;

        
        if (yielder == null) yielder = nil;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      $$slice_when.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$54(yielder){var self = $$54.$$s == null ? this : $$54.$$s;

        
        if (yielder == null) yielder = nil;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      $$sort.$$p = null;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$55(a, b){
          
          if (a == null) a = nil;
          if (b == null) b = nil;
          return a['$<=>'](b);}, 2)
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, 0);
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      $$sort_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$56(){var self = $$56.$$s == null ? this : $$56.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      dup = $send(self, 'map', [], function $$57(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, 0);
      $send(dup, 'sort!', [], function $$58(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return (a[0])['$<=>'](b[0]);}, 2);
      return $send(dup, 'map!', [], function $$59(i){
        
        if (i == null) i = nil;
        return i[1];;}, 1);
    }, 0);
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      $$sum.$$p = null;
      
      if (initial == null) initial = 0;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$60($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {try { var $t_return = $thrower('return'); 
      var block = $$take_while.$$p || nil, self = this, result = nil;

      $$take_while.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$61($a){var $post_args, args, value = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          $t_return.$throw(result)
        };
        return result.push(value);;}, {$$arity: -1, $$ret: $t_return});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, 0);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      $$uniq.$$p = null;
      
      ;
      hash = $hash2([], {});
      $send(self, 'each', [], function $$62($a){var $post_args, args, $b, value = nil, produced = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          return ($b = [produced, value], $send(hash, '[]=', $b), $b[$b.length - 1])
        };}, -1);
      return hash.$values();
    }, 0);
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      if (hash && hash !== nil) { $deny_frozen_access(hash); };
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$63(k, v){var $a;

          
          if (k == null) k = nil;
          if (v == null) v = nil;
          return ($a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, '[]=', $a), $a[$a.length - 1]);}, 2);
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::')
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $yield1 = Opal.yield1, $hash = Opal.hash, $hash_init = Opal.hash_init, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $truthy = Opal.truthy, $to_a = Opal.to_a, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,coerce_to!,each,fetch,>=,>,==,compare_by_identity,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,inspect,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,clone,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      $post_args = $slice.call(arguments);
      argv = $post_args;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      $hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    }, 1);
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = $hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, 1);
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        if (other_key == null) other_key = nil;
        if (other_val == null) other_val = nil;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$arity: 2, $$s: self});
      return result;
    }, 1);
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, 1);
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    }, 1);
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    }, 1);
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, 1);
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_put(self, key, value);
      return value;
    
    }, 2);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_init(self);
      return self;
    
    }, 0);
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, 0);
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      $deny_frozen_access(self);

      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, 0);
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      $deny_frozen_access(self);

      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        $hash_put(identity_hash, key, $hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, 0);
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    }, 0);
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      $deny_frozen_access(self);

      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, 1);
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, 0);
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      $deny_frozen_access(self);

      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, 1);
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      $Hash_delete$15.$$p = null;
      
      ;
      
      $deny_frozen_access(self);
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice.call(arguments, 1);
      keys = $post_args;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $yield1(block, [key, value]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      $$each_key.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      $$each_value.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.$$keys.length === 0;
    }, 0);
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice.call(arguments);
      keys = $post_args;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice.call(arguments);
      keys = $post_args;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        if (key == null) key = nil;
        return self.$delete(key);}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      $$fetch_values.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      keys = $post_args;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        if (key == null) key = nil;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      if (level == null) level = 1;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    }, 0);
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    }, 1);
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          key = $$('Opal').$inspect(key)
          value = $$('Opal').$inspect(value)

          result.push(key + '=>' + value);
        }

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    }, 0);
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $hash_put(hash, value, key);
      }

      return hash;
    
    }, 0);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$$keys.length;
    }, 0);
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      $$merge.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      $Hash_merge$excl$27.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      
      $deny_frozen_access(self);
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            $hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = $hash_get(self, key);

            if (value === undefined) {
              $hash_put(self, key, other_value);
              continue;
            }

            $hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      $deny_frozen_access(self);
      Opal.hash_rehash(self);
      return self;
    
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      $Hash_reject$excl$29.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);;
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      $hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        $hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    }, 1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      $Hash_select$excl$32.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      $deny_frozen_access(self);
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, $hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, 0);
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice.call(arguments);
      keys = $post_args;
      
      var result = $hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, 0);
    
    $def(self, '$to_hash', $return_self, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    }, 0);
    
    $def(self, '$transform_keys', function $$transform_keys() {
      var block = $$transform_keys.$$p || nil, self = this;

      $$transform_keys.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = $yield1(block, key);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36() {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      $Hash_transform_keys$excl$36.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = $yield1(block, key);

        $hash_delete(self, key);
        $hash_put(self, new_key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      $$transform_values.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      $Hash_transform_values$excl$39.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(self, key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$values', function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, 0);
    $alias(self, "dup", "clone");
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', null, $nesting);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $return_self = Opal.return_self, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $return_val = Opal.return_val, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,__id__,next,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
    
    }, 1);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, 0);
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, 1);
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, 1);
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, 1);
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, 1);
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, 1);
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, 1);
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, 1);
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, 1);
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, 1);
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, 1);
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, 1);
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, 1);
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, 1);
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, 1);
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    }, 0);
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    }, 0);
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    }, 0);
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($rb_lt(self, 0) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$==', function $Number_$eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, 1);
    $alias(self, "===", "==");
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, 0);
    
    $def(self, '$allbits?', function $Number_allbits$ques$22(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    }, 1);
    
    $def(self, '$anybits?', function $Number_anybits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    }, 1);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, 0);
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      $$denominator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    }, 0);
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      $$downto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$equal?', function $Number_equal$ques$25(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, 1);
    
    $def(self, '$even?', function $Number_even$ques$26() {
      var self = this;

      return self % 2 === 0;
    }, 0);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, 1);
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, 1);
    
    $def(self, '$integer?', function $Number_integer$ques$27() {
      var self = this;

      return self % 1 === 0;
    }, 0);
    
    $def(self, '$is_a?', function $Number_is_a$ques$28(klass) {
      var $yield = $Number_is_a$ques$28.$$p || nil, self = this;

      $Number_is_a$ques$28.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$28, false, true), 'is_a?', [klass], $yield);
    }, 1);
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$29(klass) {
      var $yield = $Number_instance_of$ques$29.$$p || nil, self = this;

      $Number_instance_of$ques$29.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$29, false, true), 'instance_of?', [klass], $yield);
    }, 1);
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, 1);
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    }, 0);
    
    $def(self, '$nobits?', function $Number_nobits$ques$30(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    }, 1);
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$31() {
      var self = this;

      return self == 0 ? nil : self;
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      $$numerator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    }, 0);
    
    $def(self, '$odd?', function $Number_odd$ques$32() {
      var self = this;

      return self % 2 !== 0;
    }, 0);
    
    $def(self, '$ord', $return_self, 0);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      $$quo.$$p = null;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    }, 1);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, 1);
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      $$times.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$to_f', $return_self, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, 0);
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      if (base == null) base = 10;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      if (base == null) base = 10;
      if ($rb_lt(self, 0)) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + (self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      $$divmod.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    }, 1);
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$zero?', function $Number_zero$ques$35() {
      var self = this;

      return self == 0;
    }, 0);
    
    $def(self, '$size', $return_val(4), 0);
    
    $def(self, '$nan?', function $Number_nan$ques$36() {
      var self = this;

      return isNaN(self);
    }, 0);
    
    $def(self, '$finite?', function $Number_finite$ques$37() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, 0);
    
    $def(self, '$infinite?', function $Number_infinite$ques$38() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, 0);
    
    $def(self, '$positive?', function $Number_positive$ques$39() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, 0);
    
    $def(self, '$negative?', function $Number_negative$ques$40() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, 0);
    
    function numberToUint8Array(num) {
      var uint8array = new Uint8Array(8);
      new DataView(uint8array.buffer).setFloat64(0, num, true);
      return uint8array;
    }

    function uint8ArrayToNumber(arr) {
      return new DataView(arr.buffer).getFloat64(0, true);
    }

    function incrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0xff) {
          arr[i] = 0;
        } else {
          arr[i]++;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }

    function decrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0) {
          arr[i] = 0xff;
        } else {
          arr[i]--;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }
  ;
    
    $def(self, '$next_float', function $$next_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY'))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_ge(self, 0)) {
        return incrementNumberBit(Math.abs(self));
      } else {
        return decrementNumberBit(self);
      };
    }, 0);
    
    $def(self, '$prev_float', function $$prev_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY')['$-@']())) {
        return $$$($$$('Float'), 'INFINITY')['$-@']()
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_gt(self, 0)) {
        return decrementNumberBit(self);
      } else {
        return -incrementNumberBit(Math.abs(self));
      };
    }, 0);
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, 1);
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$41(other) {
        
        return !!other.$$is_number;
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $slice = Opal.slice, $coerce_to = Opal.coerce_to, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      $Enumerator_for$1.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $rest_arg, self = this;

      $$initialize.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      $deny_frozen_access(self);
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      $$each.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    }, 0);
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      $$with_index.$$p = null;
      
      ;
      if (offset == null) offset = 0;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      $$each_with_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    }, 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    }, 0);
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        $post_args = $slice.call(arguments);
        i = $post_args;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    }, 0);
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    }, 0);
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    }, 1);
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + (self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    }, 0);
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $return_val = Opal.return_val, $def = Opal.def, $Object = Opal.Object, $slice = Opal.slice, $Kernel = Opal.Kernel, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', $return_val("main"), 0);
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    }, 1);
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    }, 1);
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_multiline_regexp = Opal.global_multiline_regexp, $prop = Opal.prop, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $gvars = Opal.gvars, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $alias = Opal.alias, $const_set = Opal.const_set, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,nil?,class,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,length,each_line,to_proc,to_a,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,dup,__id__,next,intern,pristine');
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    Opal.prop(self.$$prototype, '$$is_string', true);
  ;
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.toString();
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    }, 1);
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $kwargs.$$smap["encoding"];if (encoding == null) encoding = nil;
      
      capacity = $kwargs.$$smap["capacity"];if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, 1);
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    }, 1);
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, 1);
    
    $def(self, '$<=>', function $String_$lt_eq_gt$5(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, 1);
    
    $def(self, '$==', function $String_$eq_eq$6(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, 1);
    
    $def(self, '$=~', function $String_$eq_tilde$7(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, 1);
    
    $def(self, '$[]', function $String_$$$8(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude, range;

      if (index.$$is_range) {
        exclude = index.excl;
        range   = index;
        length  = index.end === nil ? -1 : $coerce_to(index.end, $$$('Integer'), 'to_int');
        index   = index.begin === nil ? 0 : $coerce_to(index.begin, $$$('Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude || range.end === nil) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          $Kernel.$raise($$$('TypeError'))
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$$('MatchData').$new(index, match))

        if (length == null) {
          return match[0];
        }

        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return match[length += match.length];
        }

        if (length >= 0 && length < match.length) {
          return match[length];
        }

        return nil;
      }


      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = $coerce_to(length, $$$('Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.substr(index, length);
    ;
    }, -2);
    
    $def(self, '$b', function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, 0);
    
    $def(self, '$capitalize', function $$capitalize() {
      var self = this;

      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase();
    }, 0);
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, 1);
    
    $def(self, '$casecmp?', function $String_casecmp$ques$9(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, 1);
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return rjustified + ljustified.slice(self.length);
    ;
    }, -2);
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return result;
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return result;
    
    }, 0);
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      return self.charAt(0);
    }, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash2(["freeze"], {"freeze": freeze}));
      if ($eqeq(freeze, true)) {
        if (!copy.$$frozen) { copy.$$frozen = true; }
      } else if ($truthy(freeze['$nil?']())) {
        if (self.$$frozen) { copy.$$frozen = true; }
      };
      return copy;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice.call(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$10($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice.call(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, 'g'), '');
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.slice(prefix.length);
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.slice(0, self.length - suffix.length);
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$downcase', function $$downcase() {
      var self = this;

      return self.toLowerCase();
    }, 0);
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each_line.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $kwargs.$$smap["chomp"];if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, $hash2(["chomp"], {"chomp": chomp}))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value);
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$11() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$end_with?', function $String_end_with$ques$12($a) {
      var $post_args, suffixes, self = this;

      
      $post_args = $slice.call(arguments);
      suffixes = $post_args;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, -1);
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      $$gsub.$$p = null;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    ;
    }, -2);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, 0);
    
    $def(self, '$include?', function $String_include$ques$13(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, 1);
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = $global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    }, 0);
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    $alias(self, "size", "length");
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$lines.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $kwargs.$$smap["chomp"];if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, $hash2(["chomp"], {"chomp": chomp})], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    ;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\u0000\s]*/, '');
    }, 0);
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$14() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, 0);
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      $$match.$$p = null;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$15(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return '';
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    
    }, 0);
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, 0);
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, 0);
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, 0);
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    ;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, 0);
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      $$scan.$$p = null;
      
      ;
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, $hash2(["no_matchdata"], {"no_matchdata": no_matchdata}));
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? Opal.yield1(block, match[0]) : Opal.yield1(block, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$split', function $$split(pattern, limit) {
      var self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [result[0]];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        return result;
      }

      if (limit >= result.length) {
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice.call(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1');
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1');
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$16($a) {
      var $post_args, prefixes, self = this;

      
      $post_args = $slice.call(arguments);
      prefixes = $post_args;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\s\u0000]*|[\s\u0000]*$/g, '');
    }, 0);
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      $$sub.$$p = null;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      if (n == null) n = 16;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      return str;
    
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      if (base == null) base = 10;
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil, proc = nil;

      $$to_proc.$$p = null;
      
      method_name = self.valueOf();
      proc = $send($Kernel, 'proc', [], function $$17($a){var block = $$17.$$p || nil, $post_args, args;

        $$17.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv['$' + method_name];

        if (!body) {
          body = recv.$method_missing;
          args[0] = method_name;
        } else {
          args = args.slice(1);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 0) {
          return body.call(recv);
        } else {
          return body.apply(recv, args);
        }
      ;}, -1);
      proc.$$source_location = nil;
      return proc;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    
    }, 2);
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    
    }, 2);
    
    $def(self, '$upcase', function $$upcase() {
      var self = this;

      return self.toUpperCase();
    }, 0);
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (excl == null) excl = false;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$18(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') { return self; }
      $prop(self, "$$frozen", true);
      return self;
    
    }, 0);
    
    $def(self, '$-@', function $String_$minus$$19() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, 0);
    
    $def(self, '$frozen?', function $String_frozen$ques$20() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, 0);
    $alias(self, "+@", "dup");
    $alias(self, "===", "==");
    $alias(self, "byteslice", "[]");
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    $alias(self, "object_id", "__id__");
    $alias(self, "slice", "[]");
    $alias(self, "succ", "next");
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 1.6.1 */
  "use strict";
  var $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $alias = Opal.alias, $return_val = Opal.return_val, $Opal = Opal.Opal, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $hash2 = Opal.hash2, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('==,raise,inspect,pristine,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    }, 1);
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, 0);
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      $$__send__.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), "" + (self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self['$' + symbol];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', $return_val(false), 0);
    $Opal.$pristine("!");
    
    $def(self, '$!=', function $BasicObject_$not_eq$3(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, 1);
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$instance_eval.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      $$instance_exec.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + (symbol) + "' for " + (inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $Opal = Opal.Opal, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    }, 2);
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice.call(arguments, 3);
      args = $post_args;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice.call(arguments, 3);
      args = $post_args;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, 3);
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")
      };
      return compare;
    }, 2);
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, 1);
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      if (include_all == null) include_all = false;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + (name) + "' is not allowed as a class variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    }, 1);
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + (const_name))
      }
    ;
      return const_name;
    }, 1);
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      $post_args = $slice.call(arguments, 1);
      method_names = $post_args;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $truthy = Opal.truthy, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val, $alias = Opal.alias, $a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      if (flags == null) flags = "r";
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?'](/[wa+]/))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?'](/[wa]/)) && ($not(flags['$match?'](/[r+]/))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', $return_ivar("fd"), 0);
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, 1);
    
    $def(self, '$flush', $return_val(nil), 0);
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    }, 1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    }, 0);
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $a.$ord())
    }, 0);
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    }, 0);
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    }, 0);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (sep == null) sep = false;
      if (limit == null) limit = nil;
      if (opts == null) opts = $hash2([], {});
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = /\r?\n\r?\n/
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = / /
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $b = self.read_buffer.$split(sep, 2), $a = $to_ary($b), (ret = ($a[0] == null ? nil : $a[0])), (self.read_buffer = ($a[1] == null ? nil : $a[1])), $b;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub(/^[\r\n]+/, "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    }, 1);
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    }, 1);
    
    $def(self, '$read', function $$read(integer) {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      if (integer == null) integer = nil;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $a = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();if (sep == null) sep = $gvars["/"];
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
      Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this, s = nil;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
      Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this, s = nil;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
      Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$close', $assign_ivar_val("closed", "both"), 0);
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, 0);
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, 0);
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    }, 0);
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, 0);
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  $$$('STDOUT')['$write_proc='](typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)});
  $$$('STDERR')['$write_proc='](typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)});
  return ($a = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }], $send($$$('STDIN'), 'read_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        $deny_frozen_access(self);
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, 0);
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        $$each.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e && e.$thrower_type == "breaker") {
            return e.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    }, 1);
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    }, 1);
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, 1);
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      $$bind_call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
  })('::', null);
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        if (creation_method == null) creation_method = "step";
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), "" + ("no implicit conversion of " + (self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      }, 0);
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      }, 0);
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      }, 0);
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      }, 1);
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      }, 1);
      
      $def(self, '$first', function $$first(count) {
        var self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this, $ret_or_1 = nil, iter = nil;

        $$each.$$p = null;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
        
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      }, 0);
      
      $def(self, '$last', function $$last(count) {
        var self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      }, 0);
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ", " + (self.bypfx) + (self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ")") : nil));
          return "(" + (self.receiver_num.$inspect()) + "." + (self.creation_method) + (args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + (self.step) + ")"));
          return "((" + (self.range.$inspect()) + ")." + (self.creation_method) + (args) + ")";
        }
      }, 0);
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $return_ivar = Opal.return_ivar, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $rb_ge = Opal.rb_ge, $thrower = Opal.thrower, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,include?,!,<,<=,enum_for,size,upto,to_proc,respond_to?,class,succ,==,===,exclude_end?,eql?,begin,end,last,to_a,>,-@,-,to_i,coerce_to!,ceil,/,is_a?,new,loop,+,*,>=,each_with_index,%,step,bsearch,inspect,[],hash,cover?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      if (exclude == null) exclude = false;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      return self['$include?'](value)
    }, 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    }, 0);
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, beg_cmp = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, end_cmp = nil;

      
      beg_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.begin['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (self.begin['$<=>'](value))))) && ($ret_or_1));
      end_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.end['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (value['$<=>'](self.end))))) && ($ret_or_1));
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(self.excl) ? (($truthy(($ret_or_3 = end_cmp)) ? ($rb_lt(end_cmp, 0)) : ($ret_or_3))) : ($truthy(($ret_or_3 = end_cmp)) ? ($rb_le(end_cmp, 0)) : ($ret_or_3))))) ? (beg_cmp) : ($ret_or_2))))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this, current = nil, last = nil, $ret_or_1 = nil;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + (current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
      
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    }, 0);
    
    $def(self, '$eql?', function $Range_eql$ques$4(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$exclude_end?', $return_ivar("excl"), 0);
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      $$first.$$p = null;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, 0);
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    }, 0);
    
    $def(self, '$size', function $$size() {
      var self = this, infinity = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$$('Float'), 'INFINITY');
      if ((($eqeq(self.begin, infinity) && ($not(self.end['$nil?']()))) || (($eqeq(self.end, infinity['$-@']()) && ($not(self.begin['$nil?']())))))) {
        return 0
      };
      if ($truthy(is_infinite(self))) {
        return infinity
      };
      if (!($eqeqeq($$$('Numeric'), self.begin) && ($eqeqeq($$$('Numeric'), self.end)))) {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0
      };
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, 0);
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      $$step.$$p = null;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$5(){
            
            coerceStepSize();
            return enumeratorSize();
          }, 0)
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              $t_break.$throw()
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            $t_break.$throw()
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$arity: 0, $$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$7(value, idx){
          
          if (value == null) value = nil;
          if (idx == null) idx = nil;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, 2);
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$8(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    }, 1);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    }, 0);
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, 0);
    $alias(self, "==", "eql?");
    $alias(self, "include?", "cover?");
    return $alias(self, "member?", "cover?");
  })('::', null, $nesting);
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 1.6.1 */
  "use strict";
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $slice = Opal.slice, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,==,to_s,__id__');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, 0);
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    }, 0);
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, 1);
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, 1);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0);
    
    $def(self, '$dup', $return_self, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      var body = self.$$class.$$prototype['$' + method];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      if (_include_all == null) _include_all = false;
      var body = self.$$class.$$prototype['$' + method];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_val = Opal.return_val, $ensure_kwargs = Opal.ensure_kwargs, $NilClass = Opal.NilClass, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,new,>,length,Rational,to_i');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', $return_val(true), 0);
    
    $def(self, '$&', $return_val(false), 0);
    
    $def(self, '$|', function $NilClass_$$1(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$^', function $NilClass_$$2(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$==', function $NilClass_$eq_eq$3(other) {
      
      return other === nil;
    }, 1);
    
    $def(self, '$dup', $return_val(nil), 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', $return_val("nil"), 0);
    
    $def(self, '$nil?', $return_val(true), 0);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      
      return Opal.hash();
    }, 0);
    
    $def(self, '$to_i', $return_val(0), 0);
    
    $def(self, '$to_s', $return_val(""), 0);
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    }, 0);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $slice = Opal.slice, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $ensure_kwargs = Opal.ensure_kwargs, $send2 = Opal.send2, $find_super = Opal.find_super, $module = Opal.module, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    Error.stackTraceLimit = 100;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n"));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace);
      }

      return [];
    
    }, 0);
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}, 1))
      return self.backtrace_locations;
    
    }, 0);
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    }, 0);
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      if (str == null) str = nil;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    }, 0);
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      if (kwargs == null) kwargs = nil;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return "" + (self.message) + "\n" + (self.stack)
      };
      kwargs = $hash2(["highlight", "order"], {"highlight": $gvars.stderr['$tty?'](), "order": "top"}).$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ($hash2([], {}))));
      $b = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $b[0]), (order = $b[1]), $b;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + (highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        if (loc == null) loc = nil;
        return "\tfrom " + (loc) + "\n";}, 1).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash2(["highlight"], {"highlight": highlight})))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, 0);
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        if (i == null) i = nil;
        return $rb_plus("  from ", i);}, 1).join("\n");
      }

      return backtrace;
    
    }, 1);
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, 0);
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'FrozenError');

    
    
    self.$attr_reader("receiver");
    return $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $kwargs.$$smap["receiver"];if (receiver == null) receiver = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.receiver = receiver);
    }, -2);
  })('::', $$$('RuntimeError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (value == null) value = nil;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + (self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      if (args == null) args = [];
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $kwargs.$$smap["receiver"];if (receiver == null) receiver = nil;
      
      key = $kwargs.$$smap["key"];if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    }, 0);
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    }, 0);
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return ($klass($nesting[0], null, 'Error'), nil)
  })('::', $nesting);
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["ESPIPE", "Illegal seek", 29], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2], ["ENAMETOOLONG", "File name too long", 36]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        $new$1.$$p = null;
        
        if (name == null) name = nil;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + (name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    }, 0);
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $rb_plus = Opal.rb_plus, $return_val = Opal.return_val, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,class_eval,to_proc,+,subclasses,flatten,map,initialize_copy,allocate,name,to_s');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      $Class_new$1.$$p = null;
      
      ;
      if (superclass == null) superclass = $$('Object');
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, 0);
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    }, 0);
    
    $def(self, '$inherited', $return_val(nil), 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, 1);
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      $Class_new$2.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    }, 0);
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      $$to_s.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    }, 0);
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $Kernel = Opal.Kernel, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $assign_ivar = Opal.assign_ivar, $rb_lt = Opal.rb_lt, $return_self = Opal.return_self, $neqeq = Opal.neqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,===,join,to_str,hash,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,frozen?,__id__,&,!,intersection,to_s,new,item,max,min,>=,**,delete_if,reverse,rotate,rand,at,keep_if,shuffle!,<,sort,sort_by,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments);
      objects = $post_args;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (size == null) size = nil;
      if (obj == null) obj = nil;
      
      $deny_frozen_access(self);

      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    }, 1);
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, 1);
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      return self.concat(other);;
    }, 1);
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      $deny_frozen_access(self);
      self.push(object);
      return self;
    }, 1);
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, 1);
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
      $deny_frozen_access(self);
      data = nil;
      
      var i, size = self.length;

      if (index.$$is_range) {
        if (value.$$is_array)
          data = value.$to_a();
        else if (value['$respond_to?']("to_ary"))
          data = value.$to_ary().$to_a();
        else
          data = [value];

        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      } else {
        if (extra === undefined) {
          (length = 1)
        } else {
          length = value;
          value  = extra;

          if (value.$$is_array)
            data = value.$to_a();
          else if (value['$respond_to?']("to_ary"))
            data = value.$to_ary().$to_a();
          else
            data = [value];
        }

        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      }
    ;
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      $Array_any$ques$12.$$p = null;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, 1);
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      $$bsearch_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, 0);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, 0);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);
      self.splice(0, self.length);
      return self;
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, 1);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      $Array_collect$excl$15.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      $$combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$arity: 0, $$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      $$repeated_combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      $deny_frozen_access(self);

      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, 0);
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      $post_args = $slice.call(arguments);
      others = $post_args;
      $deny_frozen_access(self);
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (other == null) other = nil;
        other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$arity: 1, $$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        if (other == null) other = nil;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      $Array_delete$22.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          $deny_frozen_access(self);

          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, 1);
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $falsy, block)
    ;
      return self;
    }, 0);
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice.call(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return $rb_minus(a, b);}, 2);
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      $post_args = $slice.call(arguments, 1);
      idxs = $post_args;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    }, 1);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      $$dup.$$p = null;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    }, 0);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      $$each_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, 1);
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      $$fill.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      $deny_frozen_access(self);

      var i, length, value;
    ;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), "" + (one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      $$index.$$p = null;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments, 1);
      objects = $post_args;
      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, 0);
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice.call(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$31(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$&'](b);}, 2);
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$32(other) {
      var self = this;

      return self.$intersection(other)['$empty?']()['$!']()
    }, 1);
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      if (sep == null) sep = nil;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new("" + ($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $truthy, block)
    ;
      return self;
    }, 0);
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      $$permutation.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$arity: 0, $$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      $$repeated_permutation.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, 1);
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      $$product.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$36(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Array_reject$excl$37() {
      var block = $Array_reject$excl$37.$$p || nil, self = this, original = nil;

      $Array_reject$excl$37.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $deny_frozen_access(self);
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, 0);
    
    $def(self, '$reverse!', function $Array_reverse$excl$39() {
      var self = this;

      
      $deny_frozen_access(self);
      return self.reverse();;
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      $$rindex.$$p = null;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      if (n == null) n = 1;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$41(cnt) {
      var self = this, ary = nil;

      
      if (cnt == null) cnt = 1;
      
      $deny_frozen_access(self);

      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', $assign_ivar("rng"), 0);
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      }, 1);
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$42(){var self = $$42.$$s == null ? this : $$42.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$select!', function $Array_select$excl$43() {
      var block = $Array_select$excl$43.$$p || nil, self = this;

      $Array_select$excl$43.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$44(){var self = $$44.$$s == null ? this : $$44.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self)

      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$45(rng) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + (j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$46(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      $deny_frozen_access(self);
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      $$sort.$$p = null;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, 0);
    
    $def(self, '$sort!', function $Array_sort$excl$47() {
      var block = $Array_sort$excl$47.$$p || nil, self = this;

      $Array_sort$excl$47.$$p = null;
      
      ;
      
      $deny_frozen_access(self)

      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$48() {
      var block = $Array_sort_by$excl$48.$$p || nil, self = this;

      $Array_sort_by$excl$48.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $deny_frozen_access(self);
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, 0);
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      $$take_while.$$p = null;
      
      ;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, 0);
    
    $def(self, '$to_ary', $return_self, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      $$to_h.$$p = null;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$50(row){var $ret_or_1 = nil;

        
        if (row == null) row = nil;
        row = ($eqeqeq($$$('Array'), row) ? (row.$to_a()) : (($coerce_to(row, $$$('Array'), 'to_ary')).$to_a()));
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + (row.length) + " should be " + (max) + ")")
        };
        return $send((row.length), 'times', [], function $$51(i){var $a, entry = nil;

          
          if (i == null) i = nil;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : (($a = [i, []], $send(result, '[]=', $a), $a[$a.length - 1])));
          return entry['$<<'](row.$at(i));}, 1);}, 1);
      return result;
    }, 0);
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice.call(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$uniq()], function $$52(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$|'](b);}, 2);
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      $$uniq.$$p = null;
      
      ;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, 0);
    
    $def(self, '$uniq!', function $Array_uniq$excl$53() {
      var block = $Array_uniq$excl$53.$$p || nil, self = this;

      $Array_uniq$excl$53.$$p = null;
      
      ;
      
      $deny_frozen_access(self);

      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, 0);
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      out = [];
      $send(args, 'each', [], function $$54(elem){var self = $$54.$$s == null ? this : $$54.$$s, finish = nil, start = nil, i = nil;

        
        if (elem == null) elem = nil;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;
          }
        ;
          return $send(start, 'upto', [finish], function $$55(i){var self = $$55.$$s == null ? this : $$55.$$s;

            
            if (i == null) i = nil;
            return out['$<<'](self.$at(i));}, {$$arity: 1, $$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$arity: 1, $$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      $$instance_variables.$$p = null;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$56(ivar){var $ret_or_1 = nil;

        
        if (ivar == null) ivar = nil;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };}, 1)
    }, 0);
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $const_set = Opal.const_set, nil = Opal.nil, $$$ = Opal.$$$;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.1.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "1.6.1");
  $const_set('::', 'RUBY_RELEASE_DATE', "2022-12-09");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2022 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + ($$$('RUBY_ENGINE_VERSION')) + " (" + ($$$('RUBY_RELEASE_DATE')) + " revision " + ($$$('RUBY_REVISION')) + ")");
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 1.6.1 */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $freeze_props = Opal.freeze_props, $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $ensure_kwargs = Opal.ensure_kwargs, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $eqeqeq = Opal.eqeqeq, $return_self = Opal.return_self, $rb_le = Opal.rb_le, $extract_kwargs = Opal.extract_kwargs, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('!,=~,==,object_id,raise,new,class,coerce_to?,<<,map,caller,nil?,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,coerce_to!,Integer,===,enum_for,result,any?,print,format,puts,<=,length,[],readline,<,first,split,to_str,exception,backtrace,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', $return_val(false), 0);
    
    $def(self, '$!~', function $Kernel_$excl_tilde$1(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, 1);
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$3(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, 1);
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, 1);
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, 1);
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      $$at_exit.$$p = null;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, 0);
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      if (start == null) start = 1;
      if (length == null) length = nil;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$caller_locations', function $$caller_locations($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($send(self, 'caller', $to_a(args)), 'map', [], function $$4(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}, 1);
    }, -1);
    
    $def(self, '$class', function $Kernel_class$5() {
      var self = this;

      return self.$$class;
    }, 0);
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta') && other.$$meta !== null) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash2(["freeze"], {"freeze": freeze}));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other, $kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      self.$initialize_copy(other);
      return self;
    }, -2);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      $$define_singleton_method.$$p = null;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, 1);
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      $$enum_for.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$6(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$exit', function $$exit(status) {
      var $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      if (status == null) status = true;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
      
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice.call(arguments);
      mods = $post_args;
      
      if (mods.length == 0) {
        self.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      $deny_frozen_access(self);

      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (typeof(self) === "object") {
        $freeze_props(self);
        return $freeze(self);
      }
      return self;
    ;
    }, 0);
    
    $def(self, '$frozen?', function $Kernel_frozen$ques$7() {
      var self = this;

      
      switch (typeof(self)) {
      case "string":
      case "symbol":
      case "number":
      case "boolean":
        return true;
      case "object":
        return (self.$$frozen || false);
      default:
        return false;
      }
    
    }, 0);
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    }, 0);
    
    $def(self, '$initialize_copy', $return_val(nil), 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$8(i){var self = $$8.$$s == null ? this : $$8.$$s, ivar = nil, inspect = nil;

            
            if (i == null) i = nil;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + (i) + "=" + (inspect)));}, {$$arity: 1, $$s: self});
        };
        return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + (ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$9(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, 1);
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$10(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, 1);
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, 1);
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, 2);
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + (name) + " not defined");
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$Integer', function $$Integer(value, base) {
      
      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            $Kernel.$raise($$$('FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $Opal['$coerce_to!'](value, $$$('Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value) {
      
      
      var str;

      if (value === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
    
    }, 1);
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return $hash2([], {})
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    }, 1);
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$11(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, 1);
    
    $def(self, '$itself', $return_self, 0);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      $$lambda.$$p = null;
      
      ;
      return Opal.lambda(block);;
    }, 0);
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    }, 1);
    
    $def(self, '$loop', function $$loop() {
      var $yield = $$loop.$$p || nil, self = this, e = nil;

      $$loop.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$12(){
          return $$$($$$('Float'), 'INFINITY')}, 0)
      };
      while ($truthy(true)) {
      
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      };
      return self;
    }, 0);
    
    $def(self, '$nil?', $return_val(false), 0);
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', $to_a(args)))
      };
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, 0);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice.call(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      $send(args, 'each', [], function $$13(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        if (obj == null) obj = nil;
        return $gvars.stdout.$puts(obj.$inspect());}, 1);
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice.call(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      strs = $post_args;
      
      uplevel = $kwargs.$$smap["uplevel"];if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + (uplevel) + ")")
        };
        location = ($c = ($d = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($d === nil || $d == null) ? nil : $d.$split(":in `")), ($c === nil || $c == null) ? nil : $c.$first());
        if ($truthy(location)) {
          location = "" + (location) + ": "
        };
        strs = $send(strs, 'map', [], function $$14(s){
          
          if (s == null) s = nil;
          return "" + (location) + "warning: " + (s);}, 1);
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars["@"] == null) $gvars["@"] = nil;

      
      ;
      if (string == null) string = nil;
      if (backtrace == null) backtrace = nil;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;
      $gvars["@"] = (exception).$backtrace();

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$15(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    }, 1);
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, 1);
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      autoload = $kwargs.$$smap["autoload"];if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      if (seconds == null) seconds = nil;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      if (seed == null) seed = $$('Random').$new_seed();
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    }, 1);
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      $$tap.$$p = null;
      
      ;
      Opal.yield1(block, self);
      return self;
    }, 0);
    
    $def(self, '$to_proc', $return_self, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, 0);
    
    $def(self, '$catch', function $Kernel_catch$17(tag) {
      var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;

      $Kernel_catch$17.$$p = null;
      
      if (tag == null) tag = nil;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$18(tag, obj) {
      
      
      if (obj == null) obj = nil;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      $$open.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      $$yield_self.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], $return_val(1), 0)
      };
      return Opal.yield1($yield, self);;
    }, 0);
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $return_ivar = Opal.return_ivar, $assign_ivar = Opal.assign_ivar, $ivar = Opal.ivar, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $prop = Opal.prop, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $Kernel = Opal.Kernel, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $slice = Opal.slice, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $eqeq = Opal.eqeq, $return_val = Opal.return_val, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('module_eval,to_proc,===,raise,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,bind,call,class,frozen?,name,append_features,included,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,class_exec,module_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, 0);
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    }, 1);
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, 1);
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, 1);
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, 1);
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      $deny_frozen_access(self);
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, 2);
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      if (jsid == null) jsid = mid;
      $deny_frozen_access(self);
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, 0);
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      $deny_frozen_access(includer);
      Opal.append_features(self, includer);
      return self;
    }, 1);
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = $ivar(name);

        var body = $return_ivar(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = $ivar(name);

        var body = $assign_ivar(ivar)

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      $deny_frozen_access(self);

      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + (const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };
      }
      return nil;
    
    }, 2);
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    }, 1);
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, 0);
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, 1);
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, 2);
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, 1);
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, 1);
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, 0);
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          if (o == null) o = nil;
          if (c == null) c = nil;
          return o.$const_get(c);}, 2)
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ("" + (self) + "::" + (name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + (full_const_name), name));
    }, 1);
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      $const_set(self, name, value);
      return value;
    }, 2);
    
    $def(self, '$public_constant', $return_val(nil), 0);
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      $$define_method.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
    ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($eqeqeq($$$('Proc'), ($ret_or_2 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_2) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_2) ? ($lambda(function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s, bound = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        bound = method.$bind(self);
        return $send(bound, 'call', $to_a(args));}, {$$arity: -1, $$s: self})) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + (block.$class()) + " (expected Proc/Method)"))))));
      
      if (typeof(Proxy) !== 'undefined') {
        var meta = Object.create(null)

        block.$$proxy_target = block
        block = new Proxy(block, {
          apply: function(target, self, args) {
            var old_name = target.$$jsid
            target.$$jsid = name;
            try {
              return target.apply(self, args);
            } catch(e) {
              if (e === target.$$brk || e === target.$$ret) return e.$v;
              throw e;
            } finally {
              target.$$jsid = old_name
            }
          }
        })
      }

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, '$' + name, block);
    ;
    }, -2);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$base_module')) { $prop(self, '$$base_module', null); }

      return $freeze(self);
    ;
    }, 0);
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (!(typeof name === "string" || name.$$is_string)) {
          self.$raise($$$('TypeError'), "" + (self.$name()) + " is not a symbol nor a string")
        }
        $deny_frozen_access(self);

        Opal.rdef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$12() {
      var self = this;

      return !!self.$$is_singleton;
    }, 0);
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice.call(arguments);
      mods = $post_args;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, 0);
    
    $def(self, '$include?', function $Module_include$ques$13(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, 1);
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      if (include_super == null) include_super = true;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', $return_val(nil), 0);
    
    $def(self, '$extended', $return_val(nil), 0);
    
    $def(self, '$extend_object', function $$extend_object(object) {
      
      
      $deny_frozen_access(object);
      return nil;
    }, 1);
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$module_eval.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "" + ("wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      $$module_exec.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$15(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, 1);
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      
      $deny_frozen_access(self);

      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, 0);
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice.call(arguments);
      mods = $post_args;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      $deny_frozen_access(prepender);

      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, 1);
    
    $def(self, '$prepended', $return_val(nil), 0);
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.const_remove(self, name);;
    }, 1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, 0);
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (!(typeof name === "string" || name.$$is_string)) {
          self.$raise($$$('TypeError'), "" + (self.$name()) + " is not a symbol nor a string")
        }
        $deny_frozen_access(self);

        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this, copy = nil;

      $$dup.$$p = null;
      
      copy = $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, 0);
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, 1);
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    }, 1);
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      $$refine.$$p = null;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = {};
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    }, 1);
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    }, 1);
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      $$inspect.$$p = null;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + (self.refined_class.$inspect()) + "@" + (self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    }, 0)
  })('::', $Module);
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.block = block;
        return self;
      }, 0);
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        $post_args = $slice.call(arguments);
        values = $post_args;
        
        var value = Opal.yieldX(self.block, values);

        if (value && value.$thrower_type == "break") {
          throw value;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      }, 1);
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          $post_args = $slice.call(arguments);
          values = $post_args;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      }, 0);
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        $post_args = $slice.call(arguments);
        enums = $post_args;
        $deny_frozen_access(self);
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        $$each.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$arity: 0, $$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          if (enum$ == null) enum$ = nil;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$arity: 1, $$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try { var $t_return = $thrower('return'); 
        var $post_args, args, self = this, accum = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          if (enum$ == null) enum$ = nil;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            $t_return.$throw(size)
          };
          return (accum = $rb_plus(accum, size));}, {$$arity: 1, $$ret: $t_return});
        return accum;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        }
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          if (enum$ == null) enum$ = nil;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };}, 1);
        self.iterated = [];
        return self;
      }, 0);
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      }, 0);
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $return_self = Opal.return_self, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $rest_arg, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        $Lazy_for$1.$$p = null;
        
        $post_args = $slice.call(arguments, 1);
        $rest_arg = $post_args;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($rest_arg)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (size == null) size = nil;
        $deny_frozen_access(self);
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          if (yielder == null) yielder = nil;
          $post_args = $slice.call(arguments, 1);
          each_args = $post_args;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              $post_args = $slice.call(arguments);
              args = $post_args;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', $return_self, 0);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      }, 0);
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        $$collect_concat.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);}, 1)
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);}, 1);
            }
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 1);
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        $$drop_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 0);
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        $$enum_for.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
        args = $post_args;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        $$find_all.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        $$grep.$$p = null;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice.call(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice.call(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      }, 1);
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        $$reject.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      }, 1);
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        $$take_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, 0);
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.load_normalized("opal");

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.6.1 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.queue(function(Opal) {/* Generated by Opal 1.6.1 */
  var $send = Opal.send, $neqeq = Opal.neqeq, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('require,ready?,[],attr,find,on,!=,html=');
  
  self.$require("opal");
  return $send($$('Document'), 'ready?', [], function $$1(){var current_url = nil;

    
    current_url = $$('Element').$find(".legislation_website").$attr()['$[]']("href");
    return $send($$('Element').$find("LegislationWebsite"), 'on', ["click"], function $$2(){var $a, current_page_url = nil;

      
      current_page_url = $$('Element').$find("LegislationWebsite").$attr()['$[]']("href");
      if ($neqeq(current_page_url, current_url)) {
        return ($a = [current_page_url], $send($$('Element').$find("current_page"), 'html=', $a), $a[$a.length - 1])
      } else {
        return nil
      };}, 0);}, 0);
});

Opal.queue(function(Opal) {/* Generated by Opal 1.6.1 */
  var $Kernel = Opal.Kernel, nil = Opal.nil;

  Opal.add_stubs('exit');
  return $Kernel.$exit()
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKGdsb2JhbF9vYmplY3QuY29uc29sZSA9PSBudWxsKSB7XG4gICAgZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuY29uc29sZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlID0ge307XG4gIH1cblxuICBpZiAoISgnbG9nJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9OyB9XG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxuXG4gIGlmICh0eXBlb2YoZ2xvYmFsX29iamVjdC5PcGFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XG4gICAgcmV0dXJuIGdsb2JhbF9vYmplY3QuT3BhbDtcbiAgfVxuXG4gIHZhciBuaWw7XG5cbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcbiAgdmFyIEJhc2ljT2JqZWN0O1xuXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxuICAvLyBUaGUgbGVhZGluZyB1bmRlcnNjb3JlIGlzIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIHdpbmRvdy5PYmplY3QoKVxuICB2YXIgX09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE1vZHVsZSBjbGFzc1xuICB2YXIgTW9kdWxlO1xuXG4gIC8vIFRoZSBhY3R1YWwgQ2xhc3MgY2xhc3NcbiAgdmFyIENsYXNzO1xuXG4gIC8vIFRoZSBPcGFsLk9wYWwgY2xhc3MgKGhlbHBlcnMgZXRjLilcbiAgdmFyIF9PcGFsO1xuXG4gIC8vIFRoZSBLZXJuZWwgbW9kdWxlXG4gIHZhciBLZXJuZWw7XG5cbiAgLy8gVGhlIE9wYWwgb2JqZWN0IHRoYXQgaXMgZXhwb3NlZCBnbG9iYWxseVxuICB2YXIgT3BhbCA9IGdsb2JhbF9vYmplY3QuT3BhbCA9IHt9O1xuXG4gIC8vIFRoaXMgaXMgYSB1c2VmdWwgcmVmZXJlbmNlIHRvIGdsb2JhbCBvYmplY3QgaW5zaWRlIHJ1YnkgZmlsZXNcbiAgT3BhbC5nbG9iYWwgPSBnbG9iYWxfb2JqZWN0O1xuXG4gIC8vIENvbmZpZ3VyZSBydW50aW1lIGJlaGF2aW9yIHdpdGggcmVnYXJkcyB0byByZXF1aXJlIGFuZCB1bnN1cHBvcnRlZCBmZWF0dXJlc1xuICBPcGFsLmNvbmZpZyA9IHtcbiAgICBtaXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk6ICdlcnJvcicsICAgICAgICAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgdW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHk6ICd3YXJuaW5nJywgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIGV4cGVyaW1lbnRhbF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLC8vIHdhcm5pbmcsIGlnbm9yZVxuICAgIGVuYWJsZV9zdGFja190cmFjZTogdHJ1ZSAgICAgICAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlXG4gIH07XG5cbiAgLy8gTWluaWZ5IGNvbW1vbiBmdW5jdGlvbiBjYWxsc1xuICB2YXIgJGhhc19vd24gICA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyICRiaW5kICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbiAgdmFyICRzZXRfcHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4gIHZhciAkc2xpY2UgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICB2YXIgJHNwbGljZSAgICA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG5cbiAgLy8gTmlsIG9iamVjdCBpZCBpcyBhbHdheXMgNFxuICB2YXIgbmlsX2lkID0gNDtcblxuICAvLyBHZW5lcmF0ZXMgZXZlbiBzZXF1ZW50aWFsIG51bWJlcnMgZ3JlYXRlciB0aGFuIDRcbiAgLy8gKG5pbF9pZCkgdG8gc2VydmUgYXMgdW5pcXVlIGlkcyBmb3IgcnVieSBvYmplY3RzXG4gIHZhciB1bmlxdWVfaWQgPSBuaWxfaWQ7XG5cbiAgLy8gUmV0dXJuIG5leHQgdW5pcXVlIGlkXG4gIGZ1bmN0aW9uICR1aWQoKSB7XG4gICAgdW5pcXVlX2lkICs9IDI7XG4gICAgcmV0dXJuIHVuaXF1ZV9pZDtcbiAgfTtcbiAgT3BhbC51aWQgPSAkdWlkO1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkID09IG51bGwpIHtcbiAgICAgICRwcm9wKG9iaiwgJyQkaWQnLCAkdWlkKCkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICB2YXIgJGd2YXJzID0gT3BhbC5ndmFycyA9IHt9O1xuXG4gIC8vIEV4aXQgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gIC8vIChTZWUgbm9kZWpzIGFuZCBjaHJvbWUgZm9yIGV4YW1wbGVzKVxuICBPcGFsLmV4aXQgPSBmdW5jdGlvbihzdGF0dXMpIHsgaWYgKCRndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKTtcbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAkZ3ZhcnNbXCIhXCJdID0gZXhjZXB0aW9uO1xuICAgICAgJGd2YXJzW1wiQFwiXSA9IGV4Y2VwdGlvbi4kYmFja3RyYWNlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJGd2YXJzW1wiIVwiXSA9ICRndmFyc1tcIkBcIl0gPSBuaWw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uICRwcm9wKG9iamVjdCwgbmFtZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZihvYmplY3QpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yOlxuICAgICAgLy8gICBzID0gXCJzdHJpbmdcIlxuICAgICAgLy8gICBkZWYgcy5tOyBlbmRcbiAgICAgIC8vIFN0cmluZyBjbGFzcyBpcyB0aGUgb25seSBjbGFzcyB0aGF0OlxuICAgICAgLy8gKyBjb21waWxlcyB0byBKUyBwcmltaXRpdmVcbiAgICAgIC8vICsgYWxsb3dzIG1ldGhvZCBkZWZpbml0aW9uIGRpcmVjdGx5IG9uIGluc3RhbmNlc1xuICAgICAgLy8gbnVtYmVycywgdHJ1ZSwgZmFsc2UgYW5kIG51bGwgZG8gbm90IHN1cHBvcnQgaXQuXG4gICAgICBvYmplY3RbbmFtZV0gPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwucHJvcCA9ICRwcm9wO1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSBPcGFsLnByb3A7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS1cblxuICB2YXIgJHRydXRoeSA9IE9wYWwudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIGZhbHNlICE9PSB2YWwgJiYgbmlsICE9PSB2YWwgJiYgdW5kZWZpbmVkICE9PSB2YWwgJiYgbnVsbCAhPT0gdmFsICYmICghKHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pIHx8IHRydWUgPT09IHZhbC52YWx1ZU9mKCkpO1xuICB9O1xuXG4gIE9wYWwuZmFsc3kgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gISR0cnV0aHkodmFsKTtcbiAgfTtcblxuICBPcGFsLnR5cGVfZXJyb3IgPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZCkge1xuICAgIG9iamVjdCA9IG9iamVjdC4kJGNsYXNzO1xuXG4gICAgaWYgKGNvZXJjZWQgJiYgbWV0aG9kKSB7XG4gICAgICBjb2VyY2VkID0gY29lcmNlZC4kJGNsYXNzO1xuICAgICAgcmV0dXJuIE9wYWwuVHlwZUVycm9yLiRuZXcoXG4gICAgICAgIFwiY2FuJ3QgY29udmVydCBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlICtcbiAgICAgICAgXCIgKFwiICsgb2JqZWN0ICsgXCIjXCIgKyBtZXRob2QgKyBcIiBnaXZlcyBcIiArIGNvZXJjZWQgKyBcIilcIlxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGVcbiAgICAgIClcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5jb2VyY2VfdG8gPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncykge1xuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ3RvX2ludCcgJiYgdHlwZSA9PT0gT3BhbC5JbnRlZ2VyICYmIG9iamVjdC4kJGlzX251bWJlcilcbiAgICAgIHJldHVybiBvYmplY3QgPCAwID8gTWF0aC5jZWlsKG9iamVjdCkgOiBNYXRoLmZsb29yKG9iamVjdCk7XG5cbiAgICBpZiAobWV0aG9kID09PSAndG9fc3RyJyAmJiB0eXBlID09PSBPcGFsLlN0cmluZyAmJiBvYmplY3QuJCRpc19zdHJpbmcpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKE9wYWwuaXNfYShvYmplY3QsIHR5cGUpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgLy8gRmFzdCBwYXRoIGZvciB0aGUgbW9zdCBjb21tb24gc2l0dWF0aW9uXG4gICAgaWYgKG9iamVjdFsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSAmJiBvYmplY3QuJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIGJvZHkgPSBvYmplY3RbJyQnICsgbWV0aG9kXTtcbiAgICAgIGlmIChib2R5ID09IG51bGwgfHwgYm9keS4kJHN0dWIpIHRocm93IE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgICAgcmV0dXJuIGJvZHkuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAoIW9iamVjdFsnJHJlc3BvbmRfdG8/J10obWV0aG9kKSkge1xuICAgICAgdGhyb3cgT3BhbC50eXBlX2Vycm9yKG9iamVjdCwgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MgPT0gbnVsbCkgYXJncyA9IFtdO1xuICAgIHJldHVybiBPcGFsLnNlbmQob2JqZWN0LCBtZXRob2QsIGFyZ3MpO1xuICB9XG5cbiAgT3BhbC5yZXNwb25kX3RvID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBpbmNsdWRlX2FsbCkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHJldHVybiBmYWxzZTtcbiAgICBpbmNsdWRlX2FsbCA9ICEhaW5jbHVkZV9hbGw7XG4gICAgdmFyIGJvZHkgPSBvYmpbanNpZF07XG5cbiAgICBpZiAob2JqWyckcmVzcG9uZF90bz8nXS4kJHByaXN0aW5lKSB7XG4gICAgICBpZiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFvYmpbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhY2VQb2ludCBzdXBwb3J0XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBTdXBwb3J0IGZvciBgVHJhY2VQb2ludC50cmFjZSg6Y2xhc3MpIGRvIC4uLiBlbmRgXG4gIE9wYWwudHJhY2VfY2xhc3MgPSBmYWxzZTtcbiAgT3BhbC50cmFjZXJzX2Zvcl9jbGFzcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzc19vcl9tb2R1bGUpIHtcbiAgICB2YXIgaSwgaWksIHRyYWNlcjtcblxuICAgIGZvcihpID0gMCwgaWkgPSBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHRyYWNlciA9IE9wYWwudHJhY2Vyc19mb3JfY2xhc3NbaV07XG4gICAgICB0cmFjZXIudHJhY2Vfb2JqZWN0ID0ga2xhc3Nfb3JfbW9kdWxlO1xuICAgICAgdHJhY2VyLmJsb2NrLiRjYWxsKHRyYWNlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoIWNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQpIHtcbiAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgT3BhbC5LZXJuZWwuJHJlcXVpcmUoY3JlZi4kJGF1dG9sb2FkW25hbWVdLnBhdGgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uID0gZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5yZXF1aXJlZCA9IHRydWU7XG4gICAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3JlZi4kJGF1dG9sb2FkW25hbWVdLmxvYWRlZCAmJiAhY3JlZi4kJGF1dG9sb2FkW25hbWVdLnJlcXVpcmVkKSB7XG4gICAgICBpZiAoY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbikgeyB0aHJvdyBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29uc3RhbnRzXG4gIC8vIC0tLS0tLS0tLVxuICAvL1xuICAvLyBGb3IgZnV0dXJlIHJlZmVyZW5jZTpcbiAgLy8gLSBUaGUgUmFpbHMgYXV0b2xvYWRpbmcgZ3VpZGUgKGh0dHA6Ly9ndWlkZXMucnVieW9ucmFpbHMub3JnL3Y1LjAvYXV0b2xvYWRpbmdfYW5kX3JlbG9hZGluZ19jb25zdGFudHMuaHRtbClcbiAgLy8gLSBAQ29ucmFkSXJ3aW4ncyAyMDEyIHBvc3Qgb24g4oCcRXZlcnl0aGluZyB5b3UgZXZlciB3YW50ZWQgdG8ga25vdyBhYm91dCBjb25zdGFudCBsb29rdXAgaW4gUnVieeKAnSAoaHR0cDovL2NpcncuaW4vYmxvZy9jb25zdGFudC1sb29rdXAuaHRtbClcbiAgLy9cbiAgLy8gTGVnZW5kIG9mIE1SSSBjb25jZXB0cy9uYW1lczpcbiAgLy8gLSBjb25zdGFudCByZWZlcmVuY2UgKGNyZWYpOiB0aGUgbW9kdWxlL2NsYXNzIHRoYXQgYWN0cyBhcyBhIG5hbWVzcGFjZVxuICAvLyAtIG5lc3Rpbmc6IHRoZSBuYW1lc3BhY2VzIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNjb3BlLCBlLmcuIG5lc3RpbmcgaW5zaWRlXG4gIC8vICAgICAgICAgICAgYG1vZHVsZSBBOyBtb2R1bGUgQjo6QzsgZW5kOyBlbmRgIGlzIGBbQjo6QywgQV1gXG5cbiAgLy8gR2V0IHRoZSBjb25zdGFudCBpbiB0aGUgc2NvcGUgb2YgdGhlIGN1cnJlbnQgY3JlZlxuICBmdW5jdGlvbiBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKSB7XG4gICAgaWYgKGNyZWYpIHtcbiAgICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkgeyByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdOyB9XG4gICAgICBpZiAoY3JlZi4kJGF1dG9sb2FkICYmIGNyZWYuJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGNvbnN0YW50O1xuXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGUgbmVzdGluZyBpcyBub3QgZW1wdHkgdGhlIGNvbnN0YW50IGlzIGxvb2tlZCB1cCBpbiBpdHMgZWxlbWVudHNcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgZm9yIChpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0YW50ID0gbmVzdGluZ1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgICAgfSBlbHNlIGlmIChuZXN0aW5nW2ldLiQkYXV0b2xvYWQgJiYgbmVzdGluZ1tpXS4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQobmVzdGluZ1tpXSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudFxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGFuY2VzdG9ycztcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMoY3JlZik7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkY29uc3QgJiYgJGhhc19vd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfSBlbHNlIGlmIChhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZCAmJiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGFuY2VzdG9yc1tpXSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCBPYmplY3QncyBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50LFxuICAvLyBidXQgb25seSBpZiBjcmVmIGlzIG1pc3Npbmcgb3IgYSBtb2R1bGUuXG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZi4kJGlzX21vZHVsZSkge1xuICAgICAgcmV0dXJuIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCBjb25zdF9taXNzaW5nIGlmIG5vdGhpbmcgZWxzZSB3b3JrZWRcbiAgZnVuY3Rpb24gY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKSB7XG4gICAgcmV0dXJuIChjcmVmIHx8IF9PYmplY3QpLiRjb25zdF9taXNzaW5nKG5hbWUpO1xuICB9XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGp1c3QgaW4gdGhlIGN1cnJlbnQgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2BcbiAgT3BhbC5jb25zdF9nZXRfbG9jYWwgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XG4gIH07XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IHJlbGF0aXZlIHRvIGEgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2AgKHdoZW4gdGhlXG4gIC8vIGNvbnN0YW50IGlzIHByZWZpeGVkIGJ5IGA6OmApLlxuICBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0LCBjYWNoZSwgY2FjaGVkLCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG5cbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBBIHNob3J0cGF0aCBmb3IgY2FsbHMgbGlrZSA6OlN0cmluZyA9PiAkJCQoXCJTdHJpbmdcIilcbiAgICAgIHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKF9PYmplY3QsIGNyZWYpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkKF9PYmplY3QsIGNyZWYsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgaWYgKChjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xuICAgICAgJHByb3AoY3JlZiwgJyQkY29uc3RfY2FjaGUnLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgIGNhY2hlID0gY3JlZi4kJGNvbnN0X2NhY2hlO1xuICAgIH1cbiAgICBjYWNoZWQgPSBjYWNoZVtuYW1lXTtcblxuICAgIGlmIChjYWNoZWQgPT0gbnVsbCB8fCBjYWNoZWRbMF0gIT09IGN1cnJlbnRfdmVyc2lvbikge1xuICAgICAgKChyZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKSkgICAgICAgICAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkpICAgICAgIT0gbnVsbCk7XG4gICAgICBjYWNoZVtuYW1lXSA9IFtjdXJyZW50X3ZlcnNpb24sIHJlc3VsdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlZFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgfHwgc2tpcF9taXNzaW5nID8gcmVzdWx0IDogY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRwcm9wKG5lc3RpbmcsICckJGNvbnN0X2NhY2hlJywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZTtcbiAgICB9XG4gICAgY2FjaGVkID0gY2FjaGVbbmFtZV07XG5cbiAgICBpZiAoY2FjaGVkID09IG51bGwgfHwgY2FjaGVkWzBdICE9PSBjdXJyZW50X3ZlcnNpb24pIHtcbiAgICAgICgocmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkpICAgICAgICAgICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfbmVzdGluZyhuZXN0aW5nLCBuYW1lKSkgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkpICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX09iamVjdChjcmVmLCBuYW1lKSkgICAgICAgICAhPSBudWxsKTtcblxuICAgICAgY2FjaGVbbmFtZV0gPSBbY3VycmVudF92ZXJzaW9uLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XG4gIH07XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGNvbnN0YW50IG9uIGEgY3JlZiBhbmQgb3Bwb3J0dW5pc3RpY2FsbHkgc2V0IHRoZSBuYW1lIG9mXG4gIC8vIHVubmFtZWQgY2xhc3Nlcy9tb2R1bGVzLlxuICBmdW5jdGlvbiAkY29uc3Rfc2V0KGNyZWYsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGNyZWYgPT0gbnVsbCB8fCBjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICh2YWx1ZS4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpZiAodmFsdWUuJCRuYW1lID09IG51bGwgfHwgdmFsdWUuJCRuYW1lID09PSBuaWwpIHZhbHVlLiQkbmFtZSA9IG5hbWU7XG4gICAgICBpZiAodmFsdWUuJCRiYXNlX21vZHVsZSA9PSBudWxsKSB2YWx1ZS4kJGJhc2VfbW9kdWxlID0gY3JlZjtcbiAgICB9XG5cbiAgICBjcmVmLiQkY29uc3QgPSAoY3JlZi4kJGNvbnN0IHx8IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIGNyZWYuJCRjb25zdFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gQWRkIGEgc2hvcnQgaGVscGVyIHRvIG5hdmlnYXRlIGNvbnN0YW50cyBtYW51YWxseS5cbiAgICAvLyBAZXhhbXBsZVxuICAgIC8vICAgT3BhbC4kJC5SZWdleHAuJCQuSUdOT1JFQ0FTRVxuICAgIGNyZWYuJCQgPSBjcmVmLiQkY29uc3Q7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIC8vIEV4cG9zZSB0b3AgbGV2ZWwgY29uc3RhbnRzIG9udG8gdGhlIE9wYWwgb2JqZWN0XG4gICAgaWYgKGNyZWYgPT09IF9PYmplY3QpIE9wYWxbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIE5hbWUgbmV3IGNsYXNzIGRpcmVjdGx5IG9udG8gY3VycmVudCBzY29wZSAoT3BhbC5Gb28uQmF6ID0ga2xhc3MpXG4gICAgJHByb3AoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIE9wYWwuY29uc3Rfc2V0ID0gJGNvbnN0X3NldDtcblxuICAvLyBHZXQgYWxsIHRoZSBjb25zdGFudHMgcmVhY2hhYmxlIGZyb20gYSBnaXZlbiBjcmVmLCBieSBkZWZhdWx0IHdpbGwgaW5jbHVkZVxuICAvLyBpbmhlcml0ZWQgY29uc3RhbnRzLlxuICBPcGFsLmNvbnN0YW50cyA9IGZ1bmN0aW9uKGNyZWYsIGluaGVyaXQpIHtcbiAgICBpZiAoaW5oZXJpdCA9PSBudWxsKSBpbmhlcml0ID0gdHJ1ZTtcblxuICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbY3JlZl0sIGksIGlpLCBjb25zdGFudHMgPSB7fSwgY29uc3RhbnQ7XG5cbiAgICBpZiAoaW5oZXJpdCkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KCRhbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoJGFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG5cbiAgICAgIC8vIERvIG5vdCBzaG93IE9iamVjdHMgY29uc3RhbnRzIHVubGVzcyB3ZSdyZSBxdWVyeWluZyBPYmplY3QgaXRzZWxmXG4gICAgICBpZiAoY3JlZiAhPT0gX09iamVjdCAmJiBtb2R1bGUgPT0gX09iamVjdCkgYnJlYWs7XG5cbiAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkY29uc3QpIHtcbiAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgZm9yIChjb25zdGFudCBpbiBtb2R1bGUuJCRhdXRvbG9hZCkge1xuICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbnN0YW50cyk7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGEgY29uc3RhbnQgZnJvbSBhIGNyZWYuXG4gIE9wYWwuY29uc3RfcmVtb3ZlID0gZnVuY3Rpb24oY3JlZiwgbmFtZSkge1xuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICB2YXIgb2xkID0gY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgZGVsZXRlIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIHJldHVybiBvbGQ7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkYXV0b2xvYWRbbmFtZV07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cblxuICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJjb25zdGFudCBcIitjcmVmK1wiOjpcIitjcmVmLiRuYW1lKCkrXCIgbm90IGRlZmluZWRcIik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBhIGN1cnJpZWQgY29uc3RfZ2V0X3JlbGF0aXZlLlxuICBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZV9mYWN0b3J5ID0gZnVuY3Rpb24obmVzdGluZykge1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiBPcGFsLiQkKG5lc3RpbmcsIG5hbWUsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0dXAgc29tZSBzaG9ydGN1dHMgdG8gcmVkdWNlIGNvbXBpbGVkIHNpemVcbiAgT3BhbC4kJCA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlO1xuICBPcGFsLiQkJCA9IE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZDtcbiAgT3BhbC4kciA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlX2ZhY3Rvcnk7XG5cbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXG4gIC8vIG1ldGhvZCB3aGljaCBlaXRoZXIgcmV0dXJucyBhbiBleGlzdGluZyBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSwgb3IgY3JlYXRlc1xuICAvLyBhIG5ldyBjbGFzcyBpbiB0aGUgZ2l2ZW4gYGJhc2VgIHNjb3BlLlxuICAvL1xuICAvLyBJZiBhIGNvbnN0YW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLCB0aGVuIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0XG4gIC8vIGl0IGlzIGEgY2xhc3MgYW5kIGFsc28gdGhhdCB0aGUgc3VwZXJjbGFzc2VzIG1hdGNoLiBJZiBlaXRoZXIgb2YgdGhlc2VcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXG4gIC8vIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBydWJ5IGNvZGUuXG4gIC8vXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXG4gIC8vIHNpbXBseSBzbyB0aGF0IGNsYXNzZXMgc2hvdyB1cCB3aXRoIG5pY2VseSBmb3JtYXR0ZWQgbmFtZXMgaW5zaWRlIGRlYnVnZ2Vyc1xuICAvLyBpbiB0aGUgd2ViIGJyb3dzZXIgKG9yIG5vZGUvc3Byb2NrZXRzKS5cbiAgLy9cbiAgLy8gVGhlIGBzY29wZWAgaXMgdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIGZyb20uIFdlIHVzZSB0aGlzIHRvIGdldCB0aGUgc2NvcGUgZm9yIHdoZXJlIHRoZSBjbGFzcyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxuICAvLyB1c2UgdGhhdCBhcyB0aGUgc2NvcGUgaW5zdGVhZC5cbiAgLy9cbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBAcGFyYW0gc3VwZXJjbGFzcyAgIFtDbGFzcyxudWxsXSBzdXBlcmNsYXNzIG9mIHRoZSBuZXcgY2xhc3MgKG1heSBiZSBudWxsKVxuICAvLyBAcGFyYW0gc2luZ2xldG9uICAgIFtCb29sZWFuLG51bGxdIGEgdHJ1ZSB2YWx1ZSBkZW5vdGVzIHdlIHdhbnQgdG8gYWxsb2NhdGVcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHNpbmdsZXRvblxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIGZ1bmN0aW9uICRhbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzLCBzaW5nbGV0b24pIHtcbiAgICB2YXIga2xhc3M7XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmIHN1cGVyY2xhc3MuJCRicmlkZ2UpIHtcbiAgICAgIC8vIEluaGVyaXRhbmNlIGZyb20gYnJpZGdlZCBjbGFzc2VzIHJlcXVpcmVzXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xuICAgICAga2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgc2VsZiA9IG5ldyAoJGJpbmQuYXBwbHkoc3VwZXJjbGFzcy4kJGNvbnN0cnVjdG9yLCBbbnVsbF0uY29uY2F0KGFyZ3MpKSkoKTtcblxuICAgICAgICAvLyBhbmQgcmVwbGFjaW5nIGEgX19wcm90b19fIG1hbnVhbGx5XG4gICAgICAgICRzZXRfcHJvdG8oc2VsZiwga2xhc3MuJCRwcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2xhc3MgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gbmlsKSB7XG4gICAgICAkcHJvcChrbGFzcywgJ2Rpc3BsYXlOYW1lJywgJzo6JytuYW1lKTtcbiAgICB9XG5cbiAgICAkcHJvcChrbGFzcywgJyQkbmFtZScsIG5hbWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkcHJvdG90eXBlJywga2xhc3MucHJvdG90eXBlKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3QnLCB7fSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2NsYXNzJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHN1cGVyJywgc3VwZXJjbGFzcyk7XG4gICAgJHByb3Aoa2xhc3MsICckJGN2YXJzJywge30pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChrbGFzcywgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRhbmNlc3RvcnMnLCBbXSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG4gICAgJHByb3Aoa2xhc3MsICckJHN1YmNsYXNzZXMnLCBbXSk7XG5cbiAgICAkcHJvcChrbGFzcy4kJHByb3RvdHlwZSwgJyQkY2xhc3MnLCBrbGFzcyk7XG5cbiAgICAvLyBCeSBkZWZhdWx0IGlmIHRoZXJlIGFyZSBubyBzaW5nbGV0b24gY2xhc3MgbWV0aG9kc1xuICAgIC8vIF9fcHJvdG9fXyBpcyBDbGFzcy5wcm90b3R5cGVcbiAgICAvLyBMYXRlciBzaW5nbGV0b24gbWV0aG9kcyBnZW5lcmF0ZSBhIHNpbmdsZXRvbl9jbGFzc1xuICAgIC8vIGFuZCBpbmplY3QgaXQgaW50byBhbmNlc3RvcnMgY2hhaW5cbiAgICBpZiAoT3BhbC5DbGFzcykge1xuICAgICAgJHNldF9wcm90byhrbGFzcywgT3BhbC5DbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwpIHtcbiAgICAgICRzZXRfcHJvdG8oa2xhc3MuJCRwcm90b3R5cGUsIHN1cGVyY2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gICAgICBpZiAoc2luZ2xldG9uICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIExldCdzIG5vdCBmb3JiaWQgR0MgZnJvbSBjbGVhbmluZyB1cCBvdXJcbiAgICAgICAgLy8gc3ViY2xhc3Nlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBXZWFrUmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBjbGVhbiB1cCBvdXIgYXJyYXkgZnJvbSBlbXB0eSBvYmplY3RzLlxuICAgICAgICAgIHZhciBpLCBzdWJjbGFzcywgcmVidWlsdF9zdWJjbGFzc2VzID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJjbGFzcyA9IHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKHN1YmNsYXNzLmRlcmVmKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZWJ1aWx0X3N1YmNsYXNzZXMucHVzaChzdWJjbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdywgbGV0J3MgYWRkIG91ciBjbGFzcy5cbiAgICAgICAgICByZWJ1aWx0X3N1YmNsYXNzZXMucHVzaChuZXcgV2Vha1JlZihrbGFzcykpO1xuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzID0gcmVidWlsdF9zdWJjbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBlcmNsYXNzLiQkbWV0YSkge1xuICAgICAgICAvLyBJZiBzdXBlcmNsYXNzIGhhcyBtZXRhY2xhc3MgdGhlbiB3ZSBoYXZlIGV4cGxpY2l0ZWx5IGluaGVyaXQgaXQuXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSAkYWxsb2NhdGVfY2xhc3M7XG5cblxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNsYXNzIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgdmFyIGtsYXNzID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGV4aXN0cyBpbiB0aGUgc2NvcGUsIHRoZW4gd2UgbXVzdCB1c2UgdGhhdFxuICAgIGlmIChrbGFzcykge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcobmFtZSArIFwiIGlzIG5vdCBhIGNsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgaWYgKGtsYXNzLiQkc3VwZXIgIT09IHN1cGVyY2xhc3MpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG1pc21hdGNoIGZvciBjbGFzcyBcIiArIGtsYXNzLiQkbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XG4gICAgdmFyIGJyaWRnZWQ7XG5cbiAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBzY29wZSA9PSAnOjonKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoXG4gICAgICBzdXBlcmNsYXNzICE9IG51bGwgJiYgKCFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5IHx8IChcbiAgICAgICAgc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSAmJiAhc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpXG4gICAgICApKVxuICAgICkge1xuICAgICAgaWYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcbiAgICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3MgKFwiICsgKFxuICAgICAgICAgIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgfHwgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci4kJG5hbWUpKSB8fFxuICAgICAgICAgIHR5cGVvZihzdXBlcmNsYXNzKVxuICAgICAgICApICsgXCIgZ2l2ZW4pXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKGtsYXNzICE9IG51bGwpIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBleGlzdGluZyBjbGFzcyBoYXMgc2FtZSBzdXBlcmNsYXNzXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gQ2xhc3MgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIGdpdmVuIHN1cGVyY2xhc3MuLi5cblxuICAgICAgLy8gTm90IHNwZWNpZnlpbmcgYSBzdXBlcmNsYXNzIG1lYW5zIHdlIGNhbiBhc3N1bWUgaXQgdG8gYmUgT2JqZWN0XG4gICAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICAgIHN1cGVyY2xhc3MgPSBfT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAgICBrbGFzcyA9ICRhbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzKTtcbiAgICAgICRjb25zdF9zZXQoc2NvcGUsIG5hbWUsIGtsYXNzKTtcblxuICAgICAgLy8gQ2FsbCAuaW5oZXJpdGVkKCkgaG9vayB3aXRoIG5ldyBjbGFzcyBvbiB0aGUgc3VwZXJjbGFzc1xuICAgICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgICBPcGFsLmJyaWRnZShicmlkZ2VkLCBrbGFzcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKGtsYXNzKTsgfVxuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIC8vIERlZmluZSBuZXcgbW9kdWxlIChvciByZXR1cm4gZXhpc3RpbmcgbW9kdWxlKS4gVGhlIGdpdmVuIGBzY29wZWAgaXMgYmFzaWNhbGx5XG4gIC8vIHRoZSBjdXJyZW50IGBzZWxmYCB2YWx1ZSB0aGUgYG1vZHVsZWAgc3RhdGVtZW50IHdhcyBkZWZpbmVkIGluLiBJZiB0aGlzIGlzXG4gIC8vIGEgcnVieSBtb2R1bGUgb3IgY2xhc3MsIHRoZW4gaXQgaXMgdXNlZCwgb3RoZXJ3aXNlIGlmIHRoZSBzY29wZSBpcyBhIHJ1YnlcbiAgLy8gb2JqZWN0IHRoZW4gdGhhdCBvYmplY3RzIHJlYWwgcnVieSBjbGFzcyBpcyB1c2VkIChlLmcuIGlmIHRoZSBzY29wZSBpcyB0aGVcbiAgLy8gbWFpbiBvYmplY3QsIHRoZW4gdGhlIHRvcCBsZXZlbCBgT2JqZWN0YCBjbGFzcyBpcyB1c2VkIGFzIHRoZSBzY29wZSkuXG4gIC8vXG4gIC8vIElmIGEgbW9kdWxlIG9mIHRoZSBnaXZlbiBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgc2NvcGUsIHRoZW4gdGhhdFxuICAvLyBpbnN0YW5jZSBpcyBqdXN0IHJldHVybmVkLlxuICAvL1xuICAvLyBJZiB0aGVyZSBpcyBhIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBzY29wZSwgdGhlbiBhbiBlcnJvciBpc1xuICAvLyBnZW5lcmF0ZWQgaW5zdGVhZCAoY2Fubm90IGhhdmUgYSBjbGFzcyBhbmQgbW9kdWxlIG9mIHNhbWUgbmFtZSBpbiBzYW1lIHNjb3BlKS5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBtb2R1bGUgaXMgY3JlYXRlZCBpbiB0aGUgc2NvcGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoYXRcbiAgLy8gbmV3IGluc3RhbmNlIGlzIHJldHVybmVkIGJhY2sgKHRvIGJlIHJlZmVyZW5jZWQgYXQgcnVudGltZSkuXG4gIC8vXG4gIC8vIEBwYXJhbSAgc2NvcGUgW01vZHVsZSwgQ2xhc3NdIGNsYXNzIG9yIG1vZHVsZSB0aGlzIGRlZmluaXRpb24gaXMgaW5zaWRlXG4gIC8vIEBwYXJhbSAgaWQgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgbmV3IChvciBleGlzdGluZykgbW9kdWxlXG4gIC8vXG4gIC8vIEByZXR1cm4gW01vZHVsZV1cbiAgZnVuY3Rpb24gJGFsbG9jYXRlX21vZHVsZShuYW1lKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKXt9O1xuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJHByb3AoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy5jb25zdHJ1Y3RvcicpO1xuXG4gICAgJHByb3AobW9kdWxlLCAnJCRuYW1lJywgbmFtZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkY29uc3QnLCB7fSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRpc19tb2R1bGUnLCB0cnVlKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRjdmFycycsIHt9KTtcbiAgICAkcHJvcChtb2R1bGUsICckJGljbGFzc2VzJywgW10pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRhbmNlc3RvcnMnLCBbbW9kdWxlXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuICBPcGFsLmFsbG9jYXRlX21vZHVsZSA9ICRhbGxvY2F0ZV9tb2R1bGU7XG5cbiAgZnVuY3Rpb24gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuICAgIGlmIChtb2R1bGUgPT0gbnVsbCAmJiBzY29wZSA9PT0gX09iamVjdCkgbW9kdWxlID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIGlmICghbW9kdWxlLiQkaXNfbW9kdWxlICYmIG1vZHVsZSAhPT0gX09iamVjdCkge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KG5hbWUgKyBcIiBpcyBub3QgYSBtb2R1bGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIE9wYWwubW9kdWxlID0gZnVuY3Rpb24oc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlO1xuXG4gICAgaWYgKHNjb3BlID09IG51bGwgfHwgc2NvcGUgPT0gJzo6Jykge1xuICAgICAgLy8gR2xvYmFsIHNjb3BlXG4gICAgICBzY29wZSA9IF9PYmplY3Q7XG4gICAgfSBlbHNlIGlmICghc2NvcGUuJCRpc19jbGFzcyAmJiAhc2NvcGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIC8vIFNjb3BlIGlzIGFuIG9iamVjdCwgdXNlIGl0cyBjbGFzc1xuICAgICAgc2NvcGUgPSBzY29wZS4kJGNsYXNzO1xuICAgIH1cblxuICAgIG1vZHVsZSA9IGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUgPT0gbnVsbCkge1xuICAgICAgLy8gTW9kdWxlIGRvZXNudCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZS4uLlxuICAgICAgbW9kdWxlID0gJGFsbG9jYXRlX21vZHVsZShuYW1lKTtcbiAgICAgICRjb25zdF9zZXQoc2NvcGUsIG5hbWUsIG1vZHVsZSk7XG4gICAgfVxuXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKG1vZHVsZSk7IH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIHRvIHNldCAkJG1ldGEgb24ga2xhc3MsIG1vZHVsZSBvciBpbnN0YW5jZVxuICBmdW5jdGlvbiBzZXRfbWV0YShvYmosIG1ldGEpIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgb2JqLiQkbWV0YSA9IG1ldGE7XG4gICAgfSBlbHNlIHtcbiAgICAgICRwcm9wKG9iaiwgJyQkbWV0YScsIG1ldGEpO1xuICAgIH1cbiAgICBpZiAob2JqLiQkZnJvemVuKSB7XG4gICAgICAvLyBJZiBhIG9iamVjdCBpcyBmcm96ZW4gKHNlYWxlZCksIGZyZWV6ZSAkJG1ldGEgdG9vLlxuICAgICAgLy8gTm8gbmVlZCB0byBpbmplY3QgJCRtZXRhLiQkcHJvdG90eXBlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4sXG4gICAgICAvLyBhcyAkJG1ldGEgY2Fubm90IGJlIG1vZGlmaWVkIGFueXdheS5cbiAgICAgIG9iai4kJG1ldGEuJGZyZWV6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2V0X3Byb3RvKG9iaiwgbWV0YS4kJHByb3RvdHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEJ1aWxkIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIGFuIGV4aXN0aW5nIGNsYXNzLiBDbGFzcyBvYmplY3QgYXJlIGJ1aWx0XG4gIC8vIHdpdGggdGhlaXIgc2luZ2xldG9uIGNsYXNzIGFscmVhZHkgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgaW5oZXJpdGluZ1xuICAvLyBmcm9tIHRoZWlyIHN1cGVyY2xhc3Mgb2JqZWN0ICh1cCB0byBgQ2xhc3NgIGl0c2VsZikuXG4gIC8vXG4gIC8vIE5PVEU6IEFjdHVhbGx5IGluIE1SSSBhIGNsYXNzJyBzaW5nbGV0b24gY2xhc3MgaW5oZXJpdHMgZnJvbSBpdHNcbiAgLy8gc3VwZXJjbGFzcycgc2luZ2xldG9uIGNsYXNzIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSBDbGFzcy5cbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzIFtDbGFzc11cbiAgLy8gQHJldHVybiBbQ2xhc3NdXG4gIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24oa2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRtZXRhKSB7XG4gICAgICByZXR1cm4ga2xhc3MuJCRtZXRhO1xuICAgIH1cblxuICAgIC8vIFRoZSBzaW5nbGV0b25fY2xhc3Mgc3VwZXJjbGFzcyBpcyB0aGUgc2luZ2xldG9uX2NsYXNzIG9mIGl0cyBzdXBlcmNsYXNzO1xuICAgIC8vIGJ1dCBCYXNpY09iamVjdCBoYXMgbm8gc3VwZXJjbGFzcyAoaXRzIGAkJHN1cGVyYCBpcyBudWxsKSwgdGh1cyB3ZVxuICAgIC8vIGZhbGxiYWNrIG9uIGBDbGFzc2AuXG4gICAgdmFyIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIHZhciBtZXRhID0gJGFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIHRydWUpO1xuXG4gICAgJHByb3AobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3AobWV0YSwgJyQkc2luZ2xldG9uX29mJywga2xhc3MpO1xuICAgIHNldF9tZXRhKGtsYXNzLCBtZXRhKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJHByb3Aoa2xhc3MsICckJGNsYXNzJywgT3BhbC5DbGFzcyk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICBPcGFsLmJ1aWxkX21vZHVsZV9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihtb2QpIHtcbiAgICBpZiAobW9kLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIG1vZC4kJG1ldGE7XG4gICAgfVxuXG4gICAgdmFyIG1ldGEgPSAkYWxsb2NhdGVfY2xhc3MobnVsbCwgT3BhbC5Nb2R1bGUsIHRydWUpO1xuXG4gICAgJHByb3AobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3AobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICBzZXRfbWV0YShtb2QsIG1ldGEpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJHByb3AobW9kLCAnJCRjbGFzcycsIE9wYWwuTW9kdWxlKTtcblxuICAgIHJldHVybiBtZXRhO1xuICB9O1xuXG4gIC8vIEJ1aWxkIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIGEgUnVieSAobm9uIGNsYXNzKSBPYmplY3QuXG4gIC8vXG4gIC8vIEBwYXJhbSBvYmplY3QgW09iamVjdF1cbiAgLy8gQHJldHVybiBbQ2xhc3NdXG4gIE9wYWwuYnVpbGRfb2JqZWN0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBzdXBlcmNsYXNzID0gb2JqZWN0LiQkY2xhc3MsXG4gICAgICAgIGtsYXNzID0gJGFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcywgdHJ1ZSk7XG5cbiAgICAkcHJvcChrbGFzcywgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgIHNldF9tZXRhKG9iamVjdCwga2xhc3MpO1xuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIE9wYWwuaXNfbWV0aG9kID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAocHJvcFswXSA9PT0gJyQnICYmIHByb3BbMV0gIT09ICckJyk7XG4gIH07XG5cbiAgT3BhbC5pbnN0YW5jZV9tZXRob2RzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgdmFyIGV4Y2x1ZGUgPSBbXSwgcmVzdWx0cyA9IFtdLCBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMob2JqLiQkbWV0YSB8fCBvYmouJCRjbGFzcyk7XG4gIH07XG5cbiAgT3BhbC5vd25fbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmouJCRtZXRhID8gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhvYmouJCRtZXRhKSA6IFtdO1xuICB9O1xuXG4gIE9wYWwucmVjZWl2ZXJfbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBtb2QgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKTtcbiAgICB2YXIgc2luZ2xldG9uX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZCk7XG4gICAgdmFyIGluc3RhbmNlX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZC4kJHN1cGVyKTtcbiAgICByZXR1cm4gc2luZ2xldG9uX21ldGhvZHMuY29uY2F0KGluc3RhbmNlX21ldGhvZHMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHBhaXJzIG9mIG5hbWVzL3ZhbHVlc1xuICAvLyBmb3IgYWxsIGNsYXNzIHZhcmlhYmxlcyBkZWZpbmVkIGluIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vIGFuZCBpdHMgYW5jZXN0b3JzLlxuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEByZXR1cm4gW09iamVjdF1cbiAgT3BhbC5jbGFzc192YXJpYWJsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcblxuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgYW5jZXN0b3IuJCRjdmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZXRzIGNsYXNzIHZhcmlhYmxlIHdpdGggc3BlY2lmaWVkICtuYW1lKyBmcm9tIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ11cbiAgT3BhbC5jbGFzc192YXJpYWJsZV9nZXQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUsIHRvbGVyYW50KSB7XG4gICAgaWYgKCRoYXNfb3duLmNhbGwobW9kdWxlLiQkY3ZhcnMsIG5hbWUpKVxuICAgICAgcmV0dXJuIG1vZHVsZS4kJGN2YXJzW25hbWVdO1xuXG4gICAgdmFyIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgIGksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcblxuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0b2xlcmFudClcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoJ3VuaW5pdGlhbGl6ZWQgY2xhc3MgdmFyaWFibGUgJytuYW1lKycgaW4gJyttb2R1bGUuJG5hbWUoKSk7XG5cbiAgICByZXR1cm4gbmlsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSb290KHByb3RvKSB7XG4gICAgcmV0dXJuIHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmIHByb3RvLmhhc093blByb3BlcnR5KCckJHJvb3QnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9pbmNsdWRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgICAvLyBzdXBlcmNsYXNzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICBpZiAobW9kKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XG4gICAgICB9XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9wcmVwZW5kZWRfbW9kdWxlcyhtb2R1bGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIG1vZCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGlmIChtb2R1bGUuJCRwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICAgIGlmIChwcm90byA9PT0gbW9kdWxlLiQkcHJvdG90eXBlLiQkZGVmaW5lX21ldGhvZHNfb24pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgICBpZiAobW9kKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cblxuICAvLyBUaGUgYWN0dWFsIGluY2x1c2lvbiBvZiBhIG1vZHVsZSBpbnRvIGEgY2xhc3MuXG4gIC8vXG4gIC8vICMjIENsYXNzIGAkJHBhcmVudGAgYW5kIGBpY2xhc3NgXG4gIC8vXG4gIC8vIFRvIGhhbmRsZSBgc3VwZXJgIGNhbGxzLCBldmVyeSBjbGFzcyBoYXMgYSBgJCRwYXJlbnRgLiBUaGlzIHBhcmVudCBpc1xuICAvLyB1c2VkIHRvIHJlc29sdmUgdGhlIG5leHQgY2xhc3MgZm9yIGEgc3VwZXIgY2FsbC4gQSBub3JtYWwgY2xhc3Mgd291bGRcbiAgLy8gaGF2ZSB0aGlzIHBvaW50IHRvIGl0cyBzdXBlcmNsYXNzLiBIb3dldmVyLCBpZiBhIGNsYXNzIGluY2x1ZGVzIGEgbW9kdWxlXG4gIC8vIHRoZW4gdGhpcyB3b3VsZCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBtb2R1bGUuIFRoZSBtb2R1bGUgd291bGRcbiAgLy8gYWxzbyBoYXZlIHRvIHRoZW4gcG9pbnQgaXRzIGAkJHBhcmVudGAgdG8gdGhlIGFjdHVhbCBzdXBlcmNsYXNzLiBXZVxuICAvLyBjYW5ub3QgbW9kaWZ5IG1vZHVsZXMgbGlrZSB0aGlzLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGluY2x1ZGVkIGluIG1vcmVcbiAgLy8gdGhlbiBvbmUgY2xhc3MuIFRvIGZpeCB0aGlzLCB3ZSBhY3R1YWxseSBpbnNlcnQgYW4gYGljbGFzc2AgYXMgdGhlIGNsYXNzJ1xuICAvLyBgJCRwYXJlbnRgIHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIHRoZSBzdXBlcmNsYXNzLiBUaGUgYGljbGFzc2AgYWN0cyBhc1xuICAvLyBhIHByb3h5IHRvIHRoZSBhY3R1YWwgbW9kdWxlLCBzbyB0aGUgYHN1cGVyYCBjaGFpbiBjYW4gdGhlbiBzZWFyY2ggaXQgZm9yXG4gIC8vIHRoZSByZXF1aXJlZCBtZXRob2QuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV0gdGhlIG1vZHVsZSB0byBpbmNsdWRlXG4gIC8vIEBwYXJhbSBpbmNsdWRlciBbTW9kdWxlXSB0aGUgdGFyZ2V0IGNsYXNzIHRvIGluY2x1ZGUgbW9kdWxlIGludG9cbiAgLy8gQHJldHVybiBbbnVsbF1cbiAgT3BhbC5hcHBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIGluY2x1ZGVyKSB7XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRwcm9wKGljbGFzcywgJyQkaW5jbHVkZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVyX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMoaW5jbHVkZXIpLFxuICAgICAgICBjaGFpbiA9IGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSxcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXG4gICAgICAgIGVuZF9jaGFpbl9vbjtcblxuICAgIGlmIChpbmNsdWRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBpbmNsdWRlXG5cbiAgICAgIC8vIGluY2x1ZGVyIC0+IGNoYWluLmZpcnN0IC0+IC4uLmNoYWluLi4uIC0+IGNoYWluLmxhc3QgLT4gaW5jbHVkZXIucGFyZW50XG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGluY2x1ZGVyLiQkcHJvdG90eXBlO1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluY2x1ZGVyLiQkcHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG1vZHVsZSBoYXMgYmVlbiBhbHJlYWR5IGluY2x1ZGVkLFxuICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwdXQgaXQgaW50byB0aGUgYW5jZXN0b3JzIGNoYWluIGFnYWluLFxuICAgICAgLy8gYnV0IHRoaXMgbW9kdWxlIG1heSBoYXZlIG5ldyBpbmNsdWRlZCBtb2R1bGVzLlxuICAgICAgLy8gSWYgaXQncyB0cnVlIHdlIG5lZWQgdG8gY29weSB0aGVtLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBzaW1wbGVzdCB3YXkgaXMgdG8gcmVwbGFjZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgICAgLy8gICAgICAgICAgcGFyZW50XG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5wcmV2aW9zIGNoYWluIG9mIG1vZHVsZS5pbmNsdWRlZF9tb2R1bGVzIC4uLlxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgXCJuZXh0IGFuY2VzdG9yXCIgKGhhcyBhICQkcm9vdCBmbGFnIG9yIGlzIGEgcmVhbCBjbGFzcylcbiAgICAgIC8vXG4gICAgICAvLyB0b1xuICAgICAgLy8gICAgICAgICAgcGFyZW50XG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgIGBtb2R1bGVgIGljbGFzcyAoaGFzIGEgJCRyb290IGZsYWcpXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgLi4ucmVnZW5lcmF0ZWQgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXNcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGludGVybWVkaWF0ZSBjbGFzc2VzIGJldHdlZW4gYHBhcmVudGAgYW5kIGBuZXh0IGFuY2VzdG9yYC5cbiAgICAgIC8vIEl0IGRvZXNuJ3QgYnJlYWsgYW55IHByb3RvdHlwZXMgb2Ygb3RoZXIgb2JqZWN0cyBhcyB3ZSBkb24ndCBjaGFuZ2UgY2xhc3MgcmVmZXJlbmNlcy5cblxuICAgICAgdmFyIHBhcmVudCA9IGluY2x1ZGVyLiQkcHJvdG90eXBlLCBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG5cbiAgICAgIHdoaWxlIChtb2R1bGVfaWNsYXNzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1vZHVsZV9pY2xhc3MuJCRtb2R1bGUgPT09IG1vZHVsZSAmJiBpc1Jvb3QobW9kdWxlX2ljbGFzcykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IG1vZHVsZV9pY2xhc3M7XG4gICAgICAgIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX2ljbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2R1bGVfaWNsYXNzKSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgYmVlbiBkaXJlY3RseSBpbmNsdWRlZFxuICAgICAgICB2YXIgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcblxuICAgICAgICAvLyBza2lwIG5vbi1yb290IGljbGFzc2VzICh0aGF0IHdlcmUgcmVjdXJzaXZlbHkgaW5jbHVkZWQpXG4gICAgICAgIHdoaWxlIChuZXh0X2FuY2VzdG9yLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmICFpc1Jvb3QobmV4dF9hbmNlc3RvcikpIHtcbiAgICAgICAgICBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5leHRfYW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IG5leHRfYW5jZXN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb2R1bGUgaGFzIG5vdCBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkIGJ1dCB3YXMgaW4gYW5jZXN0b3IgY2hhaW4gYmVjYXVzZSBpdCB3YXMgaW5jbHVkZWQgYnkgYW5vdGhlciBtb2R1bGVcbiAgICAgICAgLy8gaW5jbHVkZSBpdCBkaXJlY3RseVxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGluY2x1ZGVyLiQkcHJvdG90eXBlO1xuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25faW5jbHVkZWRfbW9kdWxlcyBjYWNoZVxuICAgIGluY2x1ZGVyLiQkb3duX2luY2x1ZGVkX21vZHVsZXMgPSBvd25faW5jbHVkZWRfbW9kdWxlcyhpbmNsdWRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBPcGFsLnByZXBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIHByZXBlbmRlcikge1xuICAgIC8vIEhlcmUgd2UgY2hhbmdlIHRoZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgIC8vXG4gICAgLy8gICBwcmVwZW5kZXJcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICAvL1xuICAgIC8vIHRvOlxuICAgIC8vXG4gICAgLy8gZHVtbXkocHJlcGVuZGVyKVxuICAgIC8vICAgICAgfFxuICAgIC8vICBpY2xhc3MobW9kdWxlKVxuICAgIC8vICAgICAgfFxuICAgIC8vIGljbGFzcyhwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gICAgcGFyZW50XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkcHJvcChpY2xhc3MsICckJHByZXBlbmRlZCcsIHRydWUpO1xuICAgICAgaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjaGFpbiA9IGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSxcbiAgICAgICAgZHVtbXlfcHJlcGVuZGVyID0gcHJlcGVuZGVyLiQkcHJvdG90eXBlLFxuICAgICAgICBwcmV2aW91c19wYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZHVtbXlfcHJlcGVuZGVyKSxcbiAgICAgICAgcHJlcGVuZGVyX2ljbGFzcyxcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXG4gICAgICAgIGVuZF9jaGFpbl9vbjtcblxuICAgIGlmIChkdW1teV9wcmVwZW5kZXIuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgLy8gVGhlIG1vZHVsZSBhbHJlYWR5IGhhcyBzb21lIHByZXBlbmRlZCBtb2R1bGVzXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbWFrZSBpdCBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBkdW1teV9wcmVwZW5kZXIuJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFraW5nIHRoZSBtb2R1bGUgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhwcmVwZW5kZXIpO1xuICAgICAgZmx1c2hfbWV0aG9kc19pbihwcmVwZW5kZXIpO1xuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkdW1teScsIHRydWUpO1xuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhwcmVwZW5kZXIpO1xuXG4gICAgaWYgKHByZXBlbmRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBwcmVwZW5kXG5cbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gZHVtbXlfcHJlcGVuZGVyO1xuXG4gICAgICAvLyBuZXh0ICQkcm9vdCBvciBwcmVwZW5kZXJfaWNsYXNzIG9yIG5vbi0kJGljbGFzc1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlcik7XG4gICAgICB3aGlsZSAoZW5kX2NoYWluX29uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRyb290JykgfHxcbiAgICAgICAgICBlbmRfY2hhaW5fb24gPT09IHByZXBlbmRlcl9pY2xhc3MgfHxcbiAgICAgICAgICAhZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJGljbGFzcycpXG4gICAgICAgICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVuZF9jaGFpbl9vbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJQcmVwZW5kaW5nIGEgbW9kdWxlIG11bHRpcGxlIHRpbWVzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9wcmVwZW5kZWRfbW9kdWxlcyBjYWNoZVxuICAgIHByZXBlbmRlci4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcyA9IG93bl9wcmVwZW5kZWRfbW9kdWxlcyhwcmVwZW5kZXIpO1xuXG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmx1c2hfbWV0aG9kc19pbihtb2R1bGUpIHtcbiAgICB2YXIgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGUsXG4gICAgICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICBkZWxldGUgcHJvdG9bcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlX2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJGlzX21vZHVsZSkge1xuICAgICAgbW9kdWxlLiQkaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICAvLyBEdW1teSBpY2xhc3MgZG9lc24ndCByZWNlaXZlIHVwZGF0ZXMgd2hlbiB0aGUgbW9kdWxlIGdldHMgYSBuZXcgbWV0aG9kLlxuICBmdW5jdGlvbiBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSB7fSxcbiAgICAgICAgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGU7XG5cbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgJHByb3AoaWNsYXNzLCBwcm9wLCBwcm90b1twcm9wXSk7XG4gICAgfVxuXG4gICAgJHByb3AoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkcHJvcChpY2xhc3MsICckJG1vZHVsZScsIG1vZHVsZSk7XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoLCBmaXJzdCA9IGljbGFzc2VzWzBdO1xuXG4gICAgJHByb3AoZmlyc3QsICckJHJvb3QnLCB0cnVlKTtcblxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogZmlyc3QgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaWNsYXNzZXNbaV07XG4gICAgICAkc2V0X3Byb3RvKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cblxuICAgIHJldHVybiB7IGZpcnN0OiBpY2xhc3Nlc1swXSwgbGFzdDogaWNsYXNzZXNbbGVuZ3RoIC0gMV0gfTtcbiAgfVxuXG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc29tZSBjb3JlIFJ1YnkgY2xhc3NlcyBhcmUgdG9sbC1mcmVlIGJyaWRnZWQgdG8gdGhlaXJcbiAgLy8gbmF0aXZlIEphdmFTY3JpcHQgY291bnRlcnBhcnRzIChlLmcuIGEgUnVieSBBcnJheSBpcyBhIEphdmFTY3JpcHQgQXJyYXkpLlxuICAvL1xuICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldHVwIGEgbmF0aXZlIGNvbnN0cnVjdG9yIChlLmcuIEFycmF5KSwgdG8gaGF2ZVxuICAvLyBpdHMgcHJvdG90eXBlIGFjdCBsaWtlIGEgbm9ybWFsIFJ1YnkgY2xhc3MuIEZpcnN0bHksIGEgbmV3IFJ1YnkgY2xhc3MgaXNcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXG4gIC8vIHRhcmdldCBmb3IgdGhlIG5ldyBjbGFzcy4gTm90ZTogYWxsIGJyaWRnZWQgY2xhc3NlcyBhcmUgc2V0IHRvIGluaGVyaXRcbiAgLy8gZnJvbSBPYmplY3QuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzICAgICAgIFtDbGFzc10gdGhlIFJ1YnkgY2xhc3MgdG8gYnJpZGdlXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxuICAvLyBAcmV0dXJuIFtDbGFzc10gcmV0dXJucyB0aGUgcGFzc2VkIFJ1YnkgY2xhc3NcbiAgLy9cbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XG4gICAgaWYgKG5hdGl2ZV9rbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRicmlkZ2UnKSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJhbHJlYWR5IGJyaWRnZWRcIik7XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0b3IgaXMgYSBKUyBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlIGNoYWluIGxpa2U6XG4gICAgLy8gLSBjb25zdHJ1Y3RvclxuICAgIC8vICAgLSBzdXBlclxuICAgIC8vXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGluamVjdCBvdXIgY2xhc3MgKHdpdGggaXRzIHByb3RvdHlwZSBjaGFpbilcbiAgICAvLyBiZXR3ZWVuIGNvbnN0cnVjdG9yIGFuZCBzdXBlci4gRm9yIGV4YW1wbGUsIGFmdGVyIGluamVjdGluZyA6Ok9iamVjdFxuICAgIC8vIGludG8gSlMgU3RyaW5nIHdlIGdldDpcbiAgICAvL1xuICAgIC8vIC0gY29uc3RydWN0b3IgKHdpbmRvdy5TdHJpbmcpXG4gICAgLy8gICAtIE9wYWwuT2JqZWN0XG4gICAgLy8gICAgIC0gT3BhbC5LZXJuZWxcbiAgICAvLyAgICAgICAtIE9wYWwuQmFzaWNPYmplY3RcbiAgICAvLyAgICAgICAgIC0gc3VwZXIgKHdpbmRvdy5PYmplY3QpXG4gICAgLy8gICAgICAgICAgIC0gbnVsbFxuICAgIC8vXG4gICAgJHByb3AobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRwcm90b3R5cGUnLCBuYXRpdmVfa2xhc3MucHJvdG90eXBlKTtcblxuICAgICRwcm9wKGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRicmlkZ2UnLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwcm90b1RvTW9kdWxlKHByb3RvKSB7XG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRtb2R1bGU7XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRjbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvd25fYW5jZXN0b3JzKG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGUuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMuY29uY2F0KFttb2R1bGVdKS5jb25jYXQobW9kdWxlLiQkb3duX2luY2x1ZGVkX21vZHVsZXMpO1xuICB9XG5cbiAgLy8gVGhlIEFycmF5IG9mIGFuY2VzdG9ycyBmb3IgYSBnaXZlbiBtb2R1bGUvY2xhc3NcbiAgZnVuY3Rpb24gJGFuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgeyByZXR1cm4gW107IH1cblxuICAgIGlmIChtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9PT0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLiQkYW5jZXN0b3JzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbW9kcywgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbW9kcyA9IG93bl9hbmNlc3RvcnMobW9kdWxlKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS4kJHN1cGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBtb2RzID0gJGFuY2VzdG9ycyhtb2R1bGUuJCRzdXBlciksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzID0gcmVzdWx0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgT3BhbC5hbmNlc3RvcnMgPSAkYW5jZXN0b3JzO1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhcImZvbyxiYXIsYmF6PVwiKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuICAgIHZhciBzdHViLCBleGlzdGluZ19tZXRob2Q7XG4gICAgc3R1YnMgPSBzdHVicy5zcGxpdCgnLCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHViID0gJyQnK3N0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICAvLyBPcGFsLnN0dWJfZm9yKHN0dWIpIGlzIHRoZSBtZXRob2RfbWlzc2luZ19zdHViXG4gICAgJHByb3AocHJvdG90eXBlLCBzdHViLCBPcGFsLnN0dWJfZm9yKHN0dWIpKTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSB0aGUgbWV0aG9kX21pc3Npbmcgc3R1YiBmb3IgYSBnaXZlbiBtZXRob2QgbmFtZS5cbiAgLy9cbiAgLy8gQHBhcmFtIG1ldGhvZF9uYW1lIFtTdHJpbmddIFRoZSBqcy1uYW1lIG9mIHRoZSBtZXRob2QgdG8gc3R1YiAoZS5nLiBcIiRmb29cIilcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxuICBPcGFsLnN0dWJfZm9yID0gZnVuY3Rpb24obWV0aG9kX25hbWUpIHtcblxuICAgIGZ1bmN0aW9uIG1ldGhvZF9taXNzaW5nX3N0dWIoKSB7XG4gICAgICAvLyBDb3B5IGFueSBnaXZlbiBibG9jayBvbnRvIHRoZSBtZXRob2RfbWlzc2luZyBkaXNwYXRjaGVyXG4gICAgICB0aGlzLiRtZXRob2RfbWlzc2luZy4kJHAgPSBtZXRob2RfbWlzc2luZ19zdHViLiQkcDtcblxuICAgICAgLy8gU2V0IGJsb2NrIHByb3BlcnR5IHRvIG51bGwgcmVhZHkgZm9yIHRoZSBuZXh0IGNhbGwgKHN0b3AgZmFsc2UtcG9zaXRpdmVzKVxuICAgICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHAgPSBudWxsO1xuXG4gICAgICAvLyBjYWxsIG1ldGhvZCBtaXNzaW5nIHdpdGggY29ycmVjdCBhcmdzIChyZW1vdmUgJyQnIHByZWZpeCBvbiBtZXRob2QgbmFtZSlcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgICAgcmV0dXJuIHRoaXMuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHRoaXMsIFttZXRob2RfbmFtZS5zbGljZSgxKV0uY29uY2F0KGFyZ3NfYXJ5KSk7XG4gICAgfVxuXG4gICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHN0dWIgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG1ldGhvZF9taXNzaW5nX3N0dWI7XG4gIH07XG5cblxuICAvLyBNZXRob2RzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBtZXRob2RzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSBvd25lciBvZiB0aGUgbWV0aG9kICttZXRoK1xuICAvLyBAcGFyYW0gbWV0aCBbU3RyaW5nXSBtZXRob2QgbmFtZSB0aGF0IGdvdCB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG9iamVjdCwgbWV0aCkge1xuICAgIHZhciBpbnNwZWN0ID0gJyc7XG4gICAgaWYgKG9iamVjdC4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJG5hbWUgKyAnLic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5zcGVjdCArPSBvYmplY3QuJCRjbGFzcy4kJG5hbWUgKyAnIyc7XG4gICAgfVxuICAgIGluc3BlY3QgKz0gbWV0aDtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdbJyArIGluc3BlY3QgKyAnXSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAnICsgYWN0dWFsICsgJywgZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBibG9ja3NcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIGJsb2NrXG4gIC8vIEBwYXJhbSBleHBlY3RlZCBbRml4bnVtXSBleHBlY3RlZCBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEBwYXJhbSBjb250ZXh0IFtPYmplY3RdIGNvbnRleHQgb2YgdGhlIGJsb2NrIGRlZmluaXRpb25cbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmJsb2NrX2FjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgY29udGV4dCkge1xuICAgIHZhciBpbnNwZWN0ID0gXCJgYmxvY2sgaW4gXCIgKyBjb250ZXh0ICsgXCInXCI7XG5cbiAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhpbnNwZWN0ICsgJzogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gJyArIGFjdHVhbCArICcsIGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcpJyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0X2FuY2VzdG9ycyhvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSAmJiBvYmouJCRtZXRhICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJGFuY2VzdG9ycyhvYmouJCRtZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICRhbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTdXBlciBkaXNwYXRjaGVyXG4gIE9wYWwuZmluZF9zdXBlciA9IGZ1bmN0aW9uKG9iaiwgbWlkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBhbGxvd19zdHVicykge1xuICAgIHZhciBqc2lkID0gJyQnICsgbWlkLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMob2JqKTtcblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgc3VwZXJfbWV0aG9kID0gcHJvdG9banNpZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGVmY2hlY2sgJiYgc3VwZXJfbWV0aG9kICYmIHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgb2JqLiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XG4gICAgICAvLyBtZXRob2RfbWlzc2luZyBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgIHRocm93IE9wYWwuTm9NZXRob2RFcnJvci4kbmV3KCdzdXBlcjogbm8gc3VwZXJjbGFzcyBtZXRob2QgYCcrbWlkK1wiJyBmb3IgXCIrb2JqLCBtaWQpO1xuICAgIH1cblxuICAgIHJldHVybiAoc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiAhYWxsb3dfc3R1YnMpID8gbnVsbCA6IHN1cGVyX21ldGhvZDtcbiAgfTtcblxuICAvLyBJdGVyIGRpc3BhdGNoZXIgZm9yIHN1cGVyIGluIGEgYmxvY2tcbiAgT3BhbC5maW5kX2Jsb2NrX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFxuICAgICAgICBcImltcGxpY2l0IGFyZ3VtZW50IHBhc3Npbmcgb2Ygc3VwZXIgZnJvbSBtZXRob2QgZGVmaW5lZCBieSBkZWZpbmVfbWV0aG9kKCkgaXMgbm90IHN1cHBvcnRlZC4gXCIgK1xuICAgICAgICBcIlNwZWNpZnkgYWxsIGFyZ3VtZW50cyBleHBsaWNpdGx5XCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRfZnVuYy4kJGRlZikge1xuICAgICAgY2FsbF9qc2lkID0gY3VycmVudF9mdW5jLiQkanNpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5maW5kX3N1cGVyKG9iaiwgY2FsbF9qc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrKTtcbiAgfTtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlciA9IE9wYWwuZmluZF9zdXBlcjtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gT3BhbC5maW5kX2Jsb2NrX3N1cGVyO1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvciB8fCBjYW5kaWRhdGVbJyQ9PT0nXShleGNlcHRpb24pKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgT3BhbC5pc19hID0gZnVuY3Rpb24ob2JqZWN0LCBrbGFzcykge1xuICAgIGlmIChrbGFzcyAhPSBudWxsICYmIG9iamVjdC4kJG1ldGEgPT09IGtsYXNzIHx8IG9iamVjdC4kJGNsYXNzID09PSBrbGFzcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdC4kJGlzX251bWJlciAmJiBrbGFzcy4kJGlzX251bWJlcl9jbGFzcykge1xuICAgICAgcmV0dXJuIChrbGFzcy4kJGlzX2ludGVnZXJfY2xhc3MpID8gKG9iamVjdCAlIDEpID09PSAwIDogdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhvYmplY3QuJCRpc19jbGFzcyA/IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpIDogKG9iamVjdC4kJG1ldGEgfHwgb2JqZWN0LiQkY2xhc3MpKTtcblxuICAgIHJldHVybiBhbmNlc3RvcnMuaW5kZXhPZihrbGFzcykgIT09IC0xO1xuICB9O1xuXG4gIC8vIEhlbHBlcnMgZm9yIGV4dHJhY3Rpbmcga3dzcGxhdHNcbiAgLy8gVXNlZCBmb3I6IHsgKipoIH1cbiAgT3BhbC50b19oYXNoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19oYXNoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9faGFzaCcsIHRydWUpKSB7XG4gICAgICB2YXIgaGFzaCA9IHZhbHVlLiR0b19oYXNoKCk7XG4gICAgICBpZiAoaGFzaC4kJGlzX2hhc2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIkNhbid0IGNvbnZlcnQgXCIgKyB2YWx1ZS4kJGNsYXNzICtcbiAgICAgICAgICBcIiB0byBIYXNoIChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19oYXNoIGdpdmVzIFwiICsgaGFzaC4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgdmFsdWUuJCRjbGFzcyArIFwiIGludG8gSGFzaFwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgaW1wbGVtZW50aW5nIG11bHRpcGxlIGFzc2lnbm1lbnRcbiAgLy8gT3VyIGNvZGUgZm9yIGV4dHJhY3RpbmcgdGhlIHZhbHVlcyBhbmQgYXNzaWduaW5nIHRoZW0gb25seSB3b3JrcyBpZiB0aGVcbiAgLy8gcmV0dXJuIHZhbHVlIGlzIGEgSlMgYXJyYXkuXG4gIC8vIFNvIGlmIHdlIGdldCBhbiBBcnJheSBzdWJjbGFzcywgZXh0cmFjdCB0aGUgd3JhcHBlZCBKUyBhcnJheSBmcm9tIGl0XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSBzb21ldGhpbmcgKG5vIHNwbGF0KVxuICBPcGFsLnRvX2FyeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hcnknLCB0cnVlKSkge1xuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hcnkoKTtcbiAgICAgIGlmIChhcnkgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIkNhbid0IGNvbnZlcnQgXCIgKyB2YWx1ZS4kJGNsYXNzICtcbiAgICAgICAgICBcIiB0byBBcnJheSAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9fYXJ5IGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yOiBhLCBiID0gKnNvbWV0aGluZyAod2l0aCBzcGxhdClcbiAgT3BhbC50b19hID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgLy8gQSBzcGxhdHRlZCBhcnJheSBtdXN0IGJlIGNvcGllZFxuICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2EoKTtcbiAgICAgIGlmIChhcnkgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIkNhbid0IGNvbnZlcnQgXCIgKyB2YWx1ZS4kJGNsYXNzICtcbiAgICAgICAgICBcIiB0byBBcnJheSAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9fYSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGZvciBleHRyYWN0aW5nIGtleXdvcmQgYXJndW1lbnRzIGZyb20gYXJndW1lbnRzIHBhc3NlZCB0b1xuICAvLyBKUyBmdW5jdGlvbi4gSWYgcHJvdmlkZWQgK2FyZ3VtZW50cysgbGlzdCBkb2Vzbid0IGhhdmUgYSBIYXNoXG4gIC8vIGFzIGEgbGFzdCBpdGVtLCByZXR1cm5zIGEgYmxhbmsgSGFzaC5cbiAgLy9cbiAgLy8gQHBhcmFtIHBhcmFtZXRlcnMgW0FycmF5XVxuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmV4dHJhY3Rfa3dhcmdzID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICAgIHZhciBrd2FyZ3MgPSBwYXJhbWV0ZXJzW3BhcmFtZXRlcnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGt3YXJncyAhPSBudWxsICYmIE9wYWwucmVzcG9uZF90byhrd2FyZ3MsICckdG9faGFzaCcsIHRydWUpKSB7XG4gICAgICAkc3BsaWNlLmNhbGwocGFyYW1ldGVycywgcGFyYW1ldGVycy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBrd2FyZ3M7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gZ2V0IGEgbGlzdCBvZiByZXN0IGtleXdvcmQgYXJndW1lbnRzLiBNZXRob2QgdGFrZXMgdGhlIGdpdmVuXG4gIC8vIGtleXdvcmQgYXJncywgaS5lLiB0aGUgaGFzaCBsaXRlcmFsIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNvbnRhaW5pbmcgYWxsXG4gIC8vIGtleXdvcmQgYXJndWVtbnRzIHBhc3NlZCB0byBtZXRob2QsIGFzIHdlbGwgYXMgdGhlIHVzZWQgYXJncyB3aGljaCBhcmVcbiAgLy8gdGhlIG5hbWVzIG9mIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgZGVmaW5lZC4gVGhpcyBtZXRob2QgdGhlblxuICAvLyBqdXN0IHJldHVybnMgYWxsIGtleS92YWx1ZSBwYWlycyB3aGljaCBoYXZlIG5vdCBiZWVuIHVzZWQsIGluIGEgbmV3XG4gIC8vIGhhc2ggbGl0ZXJhbC5cbiAgLy9cbiAgLy8gQHBhcmFtIGdpdmVuX2FyZ3MgW0hhc2hdIGFsbCBrd2FyZ3MgZ2l2ZW4gdG8gbWV0aG9kXG4gIC8vIEBwYXJhbSB1c2VkX2FyZ3MgW09iamVjdDxTdHJpbmc6IHRydWU+XSBhbGwga2V5cyB1c2VkIGFzIG5hbWVkIGt3YXJnc1xuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmt3cmVzdGFyZ3MgPSBmdW5jdGlvbihnaXZlbl9hcmdzLCB1c2VkX2FyZ3MpIHtcbiAgICB2YXIga2V5cyAgICAgID0gW10sXG4gICAgICAgIG1hcCAgICAgICA9IHt9LFxuICAgICAgICBrZXkgICAgICAgICAgICxcbiAgICAgICAgZ2l2ZW5fbWFwID0gZ2l2ZW5fYXJncy4kJHNtYXA7XG5cbiAgICBmb3IgKGtleSBpbiBnaXZlbl9tYXApIHtcbiAgICAgIGlmICghdXNlZF9hcmdzW2tleV0pIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIG1hcFtrZXldID0gZ2l2ZW5fbWFwW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuaGFzaDIoa2V5cywgbWFwKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIGlmICh0eXBlb2YoYmxvY2tvcHRzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJsb2NrLiQkYXJpdHkgPSBibG9ja29wdHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihibG9ja29wdHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmFzc2lnbihibG9jaywgYmxvY2tvcHRzKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxscyBwYXNzZWQgbWV0aG9kIG9uIGEgcnVieSBvYmplY3Qgd2l0aCBhcmd1bWVudHMgYW5kIGJsb2NrOlxuICAvL1xuICAvLyBDYW4gdGFrZSBhIG1ldGhvZCBvciBhIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyAxLiBXaGVuIG1ldGhvZCBuYW1lIGdldHMgcGFzc2VkIGl0IGludm9rZXMgaXQgYnkgaXRzIG5hbWVcbiAgLy8gICAgYW5kIGNhbGxzICdtZXRob2RfbWlzc2luZycgd2hlbiBvYmplY3QgZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgbWV0aG9kIHRoYXQgdGFrZXMgYSBibG9jayBvciBhIHNwbGF0LlxuICAvLyAyLiBXaGVuIG1ldGhvZCAoaS5lLiBtZXRob2QgYm9keSkgZ2V0cyBwYXNzZWQsIGl0IGRvZXNuJ3QgdHJpZ2dlciAnbWV0aG9kX21pc3NpbmcnXG4gIC8vICAgIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHRoZSBuYW1lIG9mIHRoZSBhY3R1YWwgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgJ3N1cGVyJy5cbiAgLy9cbiAgLy8gQGV4YW1wbGVcbiAgLy8gICB2YXIgbXlfYXJyYXkgPSBbMSwgMiwgMywgNF1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdsZW5ndGgnKSAgICAgICAgICAgICAgICAgICAgIyA9PiA0XG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheS4kbGVuZ3RoKSAgICAgICAgICAgICMgPT4gNFxuICAvL1xuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ3JldmVyc2UhJykgICAgICAgICAgICAgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXlbJyRyZXZlcnNlISddJykgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvL1xuICAvLyBAcGFyYW0gcmVjdiBbT2JqZWN0XSBydWJ5IG9iamVjdFxuICAvLyBAcGFyYW0gbWV0aG9kIFtGdW5jdGlvbiwgU3RyaW5nXSBtZXRob2QgYm9keSBvciBuYW1lIG9mIHRoZSBtZXRob2RcbiAgLy8gQHBhcmFtIGFyZ3MgW0FycmF5XSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGxcbiAgLy8gQHBhcmFtIGJsb2NrIFtGdW5jdGlvbl0gcnVieSBibG9ja1xuICAvLyBAcGFyYW0gYmxvY2tvcHRzIFtPYmplY3QsIE51bWJlcl0gb3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQgb24gdGhlIGJsb2NrXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxuICBPcGFsLnNlbmQgPSBmdW5jdGlvbihyZWN2LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICB2YXIgYm9keTtcblxuICAgIGlmICh0eXBlb2YobWV0aG9kKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm9keSA9IG1ldGhvZDtcbiAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YobWV0aG9kKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJvZHkgPSByZWN2WyckJyttZXRob2RdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwiUGFzc2VkIG1ldGhvZCBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICB9O1xuXG4gIE9wYWwuc2VuZDIgPSBmdW5jdGlvbihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5yZWZpbmVkX3NlbmQgPSBmdW5jdGlvbihyZWZpbmVtZW50X2dyb3VwcywgcmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKSB7XG4gICAgdmFyIGksIGosIGssIGFuY2VzdG9ycywgYW5jZXN0b3IsIHJlZmluZW1lbnRzLCByZWZpbmVtZW50LCByZWZpbmVfbW9kdWxlcywgcmVmaW5lX21vZHVsZSwgYm9keTtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMocmVjdik7XG5cbiAgICAvLyBGb3IgYWxsIGFuY2VzdG9ycyB0aGF0IHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgY2xvc2VzdCB0byB0aGUgZnVydGhlc3QuLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNlc3RvciA9IE9wYWwuaWQoYW5jZXN0b3JzW2ldKTtcblxuICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50IGdyb3VwcyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3Qgc2NvcGUgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVmaW5lbWVudF9ncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVmaW5lbWVudHMgPSByZWZpbmVtZW50X2dyb3Vwc1tqXTtcblxuICAgICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnRzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBgdXNpbmdgIGNhbGwgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICAgIGZvciAoayA9IHJlZmluZW1lbnRzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzID09PSAndW5kZWZpbmVkJykgY29udGludWU7XG5cbiAgICAgICAgICAvLyBBIHNpbmdsZSBtb2R1bGUgYmVpbmcgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgb2YgdGhlIGB1c2luZ2AgY2FsbCBjb250YWlucyBtdWx0aXBsZVxuICAgICAgICAgIC8vIHJlZmluZW1lbnQgbW9kdWxlc1xuICAgICAgICAgIHJlZmluZV9tb2R1bGVzID0gcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzO1xuXG4gICAgICAgICAgLy8gRG9lcyB0aGlzIG1vZHVsZSByZWZpbmUgYSBnaXZlbiBjYWxsIGZvciBhIGdpdmVuIGFuY2VzdG9yIG1vZHVsZT9cbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlZmluZV9tb2R1bGUgPSByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl07XG5cbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIGRlZmluZSBhIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGw/XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlLiQkcHJvdG90eXBlWyckJyttZXRob2RdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9keSA9IHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJyQnK21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKTtcbiAgfTtcblxuICBPcGFsLmxhbWJkYSA9IGZ1bmN0aW9uKGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XG5cbiAgICBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cyk7XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEBwYXJhbSBibG9ja29wdHMgW09iamVjdCwgTnVtYmVyXSBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgYm9keVxuICAvLyBAcmV0dXJuIFtudWxsXVxuICAvL1xuICBPcGFsLmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSwgYmxvY2tvcHRzKSB7XG4gICAgYXBwbHlfYmxvY2tvcHRzKGJvZHksIGJsb2Nrb3B0cyk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgbWV0aG9kIGRlZmluaXRpb24gaW4gdGhlXG4gICAgLy8gdG9wLWxldmVsIG5hbWVzcGFjZVxuICAgIGlmIChvYmogPT09IE9wYWwudG9wKSB7XG4gICAgICByZXR1cm4gT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgLy8gaWYgaW5zdGFuY2VfZXZhbCBpcyBpbnZva2VkIG9uIGEgbW9kdWxlL2NsYXNzLCBpdCBzZXRzIGluc3RfZXZhbF9tb2RcbiAgICBlbHNlIGlmICghb2JqLiQkZXZhbCAmJiBvYmouJCRpc19hX21vZHVsZSkge1xuICAgICAgcmV0dXJuIE9wYWwuZGVmbihvYmosIGpzaWQsIGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgJGRlbnlfZnJvemVuX2FjY2Vzcyhtb2R1bGUpO1xuXG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIG5hbWUgPSBqc2lkLnN1YnN0cigxKTtcblxuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cbiAgICAkcHJvcChwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRwcm9wKGljbGFzcywganNpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpbmdsZXRvbl9vZiA9IG1vZHVsZS4kJHNpbmdsZXRvbl9vZjtcbiAgICBpZiAobW9kdWxlLiRtZXRob2RfYWRkZWQgJiYgIW1vZHVsZS4kbWV0aG9kX2FkZGVkLiQkc3R1YiAmJiAhc2luZ2xldG9uX29mKSB7XG4gICAgICBtb2R1bGUuJG1ldGhvZF9hZGRlZChuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZCAmJiAhc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkLiQkc3R1Yikge1xuICAgICAgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkKG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIERlZmluZSBhIHNpbmdsZXRvbiBtZXRob2Qgb24gdGhlIGdpdmVuIG9iamVjdCAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZzID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5LCBibG9ja29wdHMpIHtcbiAgICBhcHBseV9ibG9ja29wdHMoYm9keSwgYmxvY2tvcHRzKTtcblxuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSk7XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3JlbW92ZV9tZXRob2QuXG4gIE9wYWwucmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCkge1xuICAgIGlmICghJGhhc19vd24uY2FsbChvYmouJCRwcm90b3R5cGUsIGpzaWQpKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwibWV0aG9kICdcIiArIGpzaWQuc3Vic3RyKDEpICsgXCInIG5vdCBkZWZpbmVkIGluIFwiICsgb2JqLiRuYW1lKCkpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvYmouJCRwcm90b3R5cGVbanNpZF07XG5cbiAgICBpZiAob2JqLiQkaXNfc2luZ2xldG9uKSB7XG4gICAgICBpZiAob2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG9iai4kbWV0aG9kX3JlbW92ZWQgJiYgIW9iai4kbWV0aG9kX3JlbW92ZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSAjdW5kZWZfbWV0aG9kLlxuICBPcGFsLnVkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoIW9iai4kJHByb3RvdHlwZVtqc2lkXSB8fCBvYmouJCRwcm90b3R5cGVbanNpZF0uJCRzdHViKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwibWV0aG9kICdcIiArIGpzaWQuc3Vic3RyKDEpICsgXCInIG5vdCBkZWZpbmVkIGluIFwiICsgb2JqLiRuYW1lKCkpO1xuICAgIH1cblxuICAgIE9wYWwuYWRkX3N0dWJfZm9yKG9iai4kJHByb3RvdHlwZSwganNpZCk7XG5cbiAgICBpZiAob2JqLiQkaXNfc2luZ2xldG9uKSB7XG4gICAgICBpZiAob2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG9iai4kbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiRtZXRob2RfdW5kZWZpbmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc19tZXRob2RfYm9keShib2R5KSB7XG4gICAgcmV0dXJuICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpO1xuICB9XG5cbiAgT3BhbC5hbGlhcyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2xkKSB7XG4gICAgdmFyIGlkICAgICA9ICckJyArIG5hbWUsXG4gICAgICAgIG9sZF9pZCA9ICckJyArIG9sZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgYWxpYXM7XG5cbiAgICAvLyBBbGlhc2luZyBvbiBtYWluIG1lYW5zIGFsaWFzaW5nIG9uIE9iamVjdC4uLlxuICAgIGlmICh0eXBlb2Ygb2JqLiQkcHJvdG90eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqID0gT3BhbC5PYmplY3Q7XG4gICAgfVxuXG4gICAgYm9keSA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdO1xuXG4gICAgLy8gV2hlbiBydW5uaW5nIGluc2lkZSAjaW5zdGFuY2VfZXZhbCB0aGUgYWxpYXMgcmVmZXJzIHRvIGNsYXNzIG1ldGhvZHMuXG4gICAgaWYgKG9iai4kJGV2YWwpIHtcbiAgICAgIHJldHVybiBPcGFsLmFsaWFzKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBuYW1lLCBvbGQpO1xuICAgIH1cblxuICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkpIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG9iai4kJHN1cGVyO1xuXG4gICAgICB3aGlsZSAodHlwZW9mKGJvZHkpICE9PSBcImZ1bmN0aW9uXCIgJiYgYW5jZXN0b3IpIHtcbiAgICAgICAgYm9keSAgICAgPSBhbmNlc3RvcltvbGRfaWRdO1xuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLiQkc3VwZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkgJiYgb2JqLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgIC8vIHRyeSB0byBsb29rIGludG8gT2JqZWN0XG4gICAgICAgIGJvZHkgPSBPcGFsLk9iamVjdC4kJHByb3RvdHlwZVtvbGRfaWRdXG4gICAgICB9XG5cbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBtZXRob2QgYFwiICsgb2xkICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBib2R5IGlzIGl0c2VsZiBhbiBhbGlhcyB1c2UgdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAvLyB0byBrZWVwIHRoZSBtYXggZGVwdGggYXQgMS5cbiAgICBpZiAoYm9keS4kJGFsaWFzX29mKSBib2R5ID0gYm9keS4kJGFsaWFzX29mO1xuXG4gICAgLy8gV2UgbmVlZCBhIHdyYXBwZXIgYmVjYXVzZSBvdGhlcndpc2UgcHJvcGVydGllc1xuICAgIC8vIHdvdWxkIGJlIG92ZXJ3cml0dGVuIG9uIHRoZSBvcmlnaW5hbCBib2R5LlxuICAgIGFsaWFzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmxvY2sgPSBhbGlhcy4kJHAsIGFyZ3MsIGksIGlpO1xuXG4gICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIGFsaWFzLiQkcCA9IG51bGw7XG5cbiAgICAgIHJldHVybiBPcGFsLnNlbmQodGhpcywgYm9keSwgYXJncywgYmxvY2spO1xuICAgIH07XG5cbiAgICAvLyBBc3NpZ24gdGhlICdsZW5ndGgnIHZhbHVlIHdpdGggZGVmaW5lUHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIGluIHN0cmljdCBtb2RlIHRoZSBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG4gICAgLy8gSXQgZG9lc24ndCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzIChsaWtlIENocm9tZSAzOCksIHdoZXJlXG4gICAgLy8gYW4gZXhjZXB0aW9uIGlzIHRocm93biBicmVha2luZyBPcGFsIGFsdG9nZXRoZXIuXG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbGlhcywgJ2xlbmd0aCcsIHsgdmFsdWU6IGJvZHkubGVuZ3RoIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBUcnkgdG8gbWFrZSB0aGUgYnJvd3NlciBwaWNrIHRoZSByaWdodCBuYW1lXG4gICAgYWxpYXMuZGlzcGxheU5hbWUgICAgICAgPSBuYW1lO1xuXG4gICAgYWxpYXMuJCRhcml0eSAgICAgICAgICAgPSBib2R5LiQkYXJpdHk7XG4gICAgYWxpYXMuJCRwYXJhbWV0ZXJzICAgICAgPSBib2R5LiQkcGFyYW1ldGVycztcbiAgICBhbGlhcy4kJHNvdXJjZV9sb2NhdGlvbiA9IGJvZHkuJCRzb3VyY2VfbG9jYXRpb247XG4gICAgYWxpYXMuJCRhbGlhc19vZiAgICAgICAgPSBib2R5O1xuICAgIGFsaWFzLiQkYWxpYXNfbmFtZSAgICAgID0gbmFtZTtcblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBhbGlhcyk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIE9wYWwuYWxpYXNfZ3ZhciA9IGZ1bmN0aW9uKG5ld19uYW1lLCBvbGRfbmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkZ3ZhcnMsIG5ld19uYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRndmFyc1tvbGRfbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdfdmFsdWUpIHtcbiAgICAgICAgJGd2YXJzW29sZF9uYW1lXSA9IG5ld192YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmlsO1xuICB9XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIGhhc2guJCRrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGhhc2guJCRzbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnVja2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2dldCA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Y2tldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIHZhciBpLCBrZXlzID0gaGFzaC4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZSwga2V5X3RtcDtcblxuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSBrZXkgPSBrZXkudmFsdWVPZigpO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5X3RtcCA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleV90bXAuJCRpc19zdHJpbmcgJiYgdHlwZW9mIGtleV90bXAgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBrZXlfdG1wID0ga2V5X3RtcC52YWx1ZU9mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5X3RtcCA9PT0ga2V5KSB7XG4gICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgZGVsZXRlIGhhc2guJCRzbWFwW2tleV07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoID0ga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdLCBsYXN0X2J1Y2tldDtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIHZhbHVlID0gYnVja2V0LnZhbHVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzW2ldID09PSBidWNrZXQpIHtcbiAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9yZWhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhc2guJCRrZXlzLmxlbmd0aCwga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoaGFzaC4kJGtleXNbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGtleV9oYXNoID0gaGFzaC4kJGtleXNbaV0ua2V5LiRoYXNoKCk7XG5cbiAgICAgIGlmIChrZXlfaGFzaCA9PT0gaGFzaC4kJGtleXNbaV0ua2V5X2hhc2gpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaGFzaC4kJGtleXNbaV0ua2V5X2hhc2ggPSBrZXlfaGFzaDtcblxuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3VtZW50c19sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBoYXNoLCBpLCBsZW5ndGgsIGtleSwgdmFsdWU7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0uJCRpc19oYXNoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG4gICAgT3BhbC5oYXNoX2luaXQoaGFzaCk7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJ2YWx1ZSBub3Qgb2YgbGVuZ3RoIDI6IFwiICsgYXJnc1tpXS4kaW5zcGVjdCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSBhcmdzW2ldWzBdO1xuICAgICAgICAgIHZhbHVlID0gYXJnc1tpXVsxXTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYXJncywga2V5KSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgdmFyIHJlc2VydmVkX2l2YXJfbmFtZXMgPSBbXG4gICAgLy8gcHJvcGVydGllc1xuICAgIFwiY29uc3RydWN0b3JcIiwgXCJkaXNwbGF5TmFtZVwiLCBcIl9fY291bnRfX1wiLCBcIl9fbm9TdWNoTWV0aG9kX19cIixcbiAgICBcIl9fcGFyZW50X19cIiwgXCJfX3Byb3RvX19cIixcbiAgICAvLyBtZXRob2RzXG4gICAgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcInZhbHVlT2ZcIlxuICBdO1xuXG4gIC8vIEdldCB0aGUgaXZhciBuYW1lIGZvciBhIGdpdmVuIG5hbWUuXG4gIC8vIE1vc3RseSBhZGRzIGEgdHJhaWxpbmcgJCB0byByZXNlcnZlZCBuYW1lcy5cbiAgLy9cbiAgT3BhbC5pdmFyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChyZXNlcnZlZF9pdmFyX25hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICBuYW1lICs9IFwiJFwiO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIFN1cHBvcnQgZm9yICNmcmVlemVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGhlbHBlciB0aGF0IGNhbiBiZSB1c2VkIGZyb20gbWV0aG9kc1xuICBmdW5jdGlvbiAkZGVueV9mcm96ZW5fYWNjZXNzKG9iaikge1xuICAgIGlmIChvYmouJCRmcm96ZW4pIHtcbiAgICAgIHRocm93IE9wYWwuRnJvemVuRXJyb3IuJG5ldyhcImNhbid0IG1vZGlmeSBmcm96ZW4gXCIgKyAob2JqLiRjbGFzcygpKSArIFwiOiBcIiArIChvYmopLCBPcGFsLmhhc2gyKFtcInJlY2VpdmVyXCJdLCB7XCJyZWNlaXZlclwiOiBvYmp9KSk7XG4gICAgfVxuICB9O1xuICBPcGFsLmRlbnlfZnJvemVuX2FjY2VzcyA9ICRkZW55X2Zyb3plbl9hY2Nlc3M7XG5cbiAgLy8gY29tbW9uICNmcmVlemUgcnVudGltZSBzdXBwb3J0XG4gIE9wYWwuZnJlZXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgJHByb3Aob2JqLCBcIiQkZnJvemVuXCIsIHRydWUpO1xuXG4gICAgLy8gc2V0ICQkaWRcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnJCRpZCcpKSB7ICRwcm9wKG9iaiwgJyQkaWQnLCAkdWlkKCkpOyB9XG5cbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgLy8gZnJlZXplICQkbWV0YSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHNldFxuICAgICAgb2JqLiQkbWV0YS4kZnJlZXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuc3VyZSAkJG1ldGEgY2FuIGJlIHNldCBsYXppbHksICQkbWV0YSBpcyBmcm96ZW4gd2hlbiBzZXQgaW4gcnVudGltZS5qc1xuICAgICAgJHByb3Aob2JqLCAnJCRtZXRhJywgbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gJCRjb21wYXJhYmxlIGlzIHVzZWQgaW50ZXJuYWxseSBhbmQgc2V0IG11bHRpcGxlIHRpbWVzXG4gICAgLy8gZGVmaW5pbmcgaXQgYmVmb3JlIHNlYWxpbmcgZW5zdXJlcyBpdCBjYW4gYmUgbW9kaWZpZWQgbGF0ZXIgb25cbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnJCRjb21wYXJhYmxlJykpIHsgJHByb3Aob2JqLCAnJCRjb21wYXJhYmxlJywgbnVsbCk7IH1cblxuICAgIC8vIHNlYWwgdGhlIE9iamVjdFxuICAgIE9iamVjdC5zZWFsKG9iaik7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIGZyZXplIHByb3BzLCBtYWtlIHNldHRlcnMgb2YgaW5zdGFuY2UgdmFyaWFibGVzIHRocm93IEZyb3plbkVycm9yXG4gIE9wYWwuZnJlZXplX3Byb3BzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHByb3AsIHByb3BfdHlwZSwgZGVzYztcblxuICAgIGZvcihwcm9wIGluIG9iaikge1xuICAgICAgcHJvcF90eXBlID0gdHlwZW9mKHByb3ApO1xuXG4gICAgICAvLyBwcm9wX3R5cGUgXCJvYmplY3RcIiBoZXJlIGlzIGEgU3RyaW5nKCksIHNraXAgJCBwcm9wc1xuICAgICAgaWYgKChwcm9wX3R5cGUgPT09IFwic3RyaW5nXCIgfHwgcHJvcF90eXBlID09PSBcIm9iamVjdFwiKSAmJiBwcm9wWzBdID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICBpZiAoZGVzYyAmJiBkZXNjLmVudW1lcmFibGUgJiYgZGVzYy53cml0YWJsZSkge1xuICAgICAgICAvLyBjcmVhdGUgY2xvc3VyZSB0byByZXRhaW4gY3VycmVudCB2YWx1ZSBhcyBjdlxuICAgICAgICAvLyBmb3IgT3BhbCAyLjAgbGV0IGZvciBjdiBzaG91bGQgZG8gdGhlIHRyaWNrLCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb25cbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHNldCB2IHRvIHVuZGVmaW5lZCwgYXMgaWYgdGhlIHByb3BlcnR5IGlzIG5vdCBzZXRcbiAgICAgICAgICB2YXIgY3YgPSBvYmpbcHJvcF07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGN2OyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfdmFsKSB7ICRkZW55X2Zyb3plbl9hY2Nlc3Mob2JqKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnZXhwc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gRXNjYXBlIFJlZ2V4cCBzcGVjaWFsIGNoYXJzIGxldHRpbmcgdGhlIHJlc3VsdGluZyBzdHJpbmcgYmUgdXNlZCB0byBidWlsZFxuICAvLyBhIG5ldyBSZWdleHAuXG4gIC8vXG4gIE9wYWwuZXNjYXBlX3JlZ2V4cCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFstW1xcXVxcL3t9KCkqKz8uXiRcXFxcfCBdKS9nLCAnXFxcXCQxJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXG5dL2csICdcXFxcbicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxyXS9nLCAnXFxcXHInKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcZl0vZywgJ1xcXFxmJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHRdL2csICdcXFxcdCcpO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGdsb2JhbCBSZWdleHAgZnJvbSBhIFJlZ0V4cCBvYmplY3QgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZyBhdHRyaWJ1dGUpLlxuICAvL1xuICBPcGFsLmdsb2JhbF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gcGF0dGVybjsgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgZmxhZ1xuICAgIH1cbiAgICBpZiAocGF0dGVybi4kJGcgPT0gbnVsbCkge1xuICAgICAgcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAocGF0dGVybi5tdWx0aWxpbmUgPyAnZ20nIDogJ2cnKSArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuLiQkZy5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm4uJCRnO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGdsb2JhbCBtdWx0aWxpbmUgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGdtIG9yICQkZyBhdHRyaWJ1dGUpLlxuICAvL1xuICBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciByZXN1bHQsIGZsYWdzO1xuXG4gICAgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgYW5kIG11bHRpbGluZSBmbGFnXG4gICAgaWYgKHBhdHRlcm4uZ2xvYmFsICYmIHBhdHRlcm4ubXVsdGlsaW5lKSByZXR1cm4gcGF0dGVybjtcblxuICAgIGZsYWdzID0gJ2dtJyArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJyk7XG4gICAgaWYgKHBhdHRlcm4ubXVsdGlsaW5lKSB7XG4gICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlICQkZyBhdHRyaWJ1dGUgYmVjYXVzZSB0aGUgUmVnZXhwIGlzIGFscmVhZHkgbXVsdGlsaW5lXG4gICAgICBpZiAocGF0dGVybi4kJGcgPT0gbnVsbCkge1xuICAgICAgICBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0dGVybi4kJGdtID09IG51bGwpIHtcbiAgICAgICAgcGF0dGVybi4kJGdtID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH1cbiAgICByZXN1bHQubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb21iaW5lIG11bHRpcGxlIHJlZ2V4cCBwYXJ0cyB0b2dldGhlclxuICBPcGFsLnJlZ2V4cCA9IGZ1bmN0aW9uKHBhcnRzLCBmbGFncykge1xuICAgIHZhciBwYXJ0O1xuICAgIHZhciBpZ25vcmVDYXNlID0gdHlwZW9mIGZsYWdzICE9PSAndW5kZWZpbmVkJyAmJiBmbGFncyAmJiBmbGFncy5pbmRleE9mKCdpJykgPj0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChwYXJ0Lmlnbm9yZUNhc2UgIT09IGlnbm9yZUNhc2UpXG4gICAgICAgICAgT3BhbC5LZXJuZWwuJHdhcm4oXG4gICAgICAgICAgICBcImlnbm9yZSBjYXNlIGRvZXNuJ3QgbWF0Y2ggZm9yIFwiICsgcGFydC5zb3VyY2UuJGluc3BlY3QoKSxcbiAgICAgICAgICAgIE9wYWwuaGFzaCh7dXBsZXZlbDogMX0pXG4gICAgICAgICAgKVxuXG4gICAgICAgIHBhcnQgPSBwYXJ0LnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0ID09PSAnJykgcGFydCA9ICcoPzonICsgcGFydCArICcpJztcbiAgICAgIHBhcnRzW2ldID0gcGFydDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpLCBmbGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVxdWlyZSBzeXN0ZW1cbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICBPcGFsLm1vZHVsZXMgICAgICAgICA9IHt9O1xuICBPcGFsLmxvYWRlZF9mZWF0dXJlcyA9IFsnY29yZWxpYi9ydW50aW1lJ107XG4gIE9wYWwuY3VycmVudF9kaXIgICAgID0gJy4nO1xuICBPcGFsLnJlcXVpcmVfdGFibGUgICA9IHsnY29yZWxpYi9ydW50aW1lJzogdHJ1ZX07XG5cbiAgT3BhbC5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHBhcnRzLCBwYXJ0LCBuZXdfcGFydHMgPSBbXSwgU0VQQVJBVE9SID0gJy8nO1xuXG4gICAgaWYgKE9wYWwuY3VycmVudF9kaXIgIT09ICcuJykge1xuICAgICAgcGF0aCA9IE9wYWwuY3VycmVudF9kaXIucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGF0aDtcbiAgICB9XG5cbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgJycpO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLihyYnxvcGFsfGpzKSQvLCAnJyk7XG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgKHBhcnQgPT09ICcuLicpID8gbmV3X3BhcnRzLnBvcCgpIDogbmV3X3BhcnRzLnB1c2gocGFydClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3X3BhcnRzLmpvaW4oU0VQQVJBVE9SKTtcbiAgfTtcblxuICBPcGFsLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgdmFyIGksIGwsIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aHNbaV0pO1xuXG4gICAgICBpZiAoT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBPcGFsLmxvYWRlZF9mZWF0dXJlcy5wdXNoKHBhdGgpO1xuICAgICAgT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5sb2FkX25vcm1hbGl6ZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgT3BhbC5sb2FkZWQoW3BhdGhdKTtcblxuICAgIHZhciBtb2R1bGUgPSBPcGFsLm1vZHVsZXNbcGF0aF07XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICB2YXIgcmV0dmFsID0gbW9kdWxlKE9wYWwpO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiByZXR2YWwgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIC8vIEEgc3BlY2lhbCBjYXNlIG9mIHJlcXVpcmUgaGF2aW5nIGFuIGFzeW5jIHRvcDpcbiAgICAgICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGF3YWl0IGl0LlxuICAgICAgICByZXR1cm4gcmV0dmFsLnRoZW4oJHJldHVybl92YWwodHJ1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzZXZlcml0eSA9IE9wYWwuY29uZmlnLm1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTtcbiAgICAgIHZhciBtZXNzYWdlICA9ICdjYW5ub3QgbG9hZCBzdWNoIGZpbGUgLS0gJyArIHBhdGg7XG5cbiAgICAgIGlmIChzZXZlcml0eSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGlmIChPcGFsLkxvYWRFcnJvcikge1xuICAgICAgICAgIHRocm93IE9wYWwuTG9hZEVycm9yLiRuZXcobWVzc2FnZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBtZXNzYWdlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNldmVyaXR5ID09PSBcIndhcm5pbmdcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IExvYWRFcnJvcjogJyArIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIE9wYWwubG9hZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XG4gIH07XG5cblxuICAvLyBTdHJpbmdzXG4gIC8vIC0tLS0tLS1cblxuICBPcGFsLmVuY29kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gU2V0cyB0aGUgZW5jb2Rpbmcgb24gYSBzdHJpbmcsIHdpbGwgdHJlYXQgc3RyaW5nIGxpdGVyYWxzIGFzIGZyb3plbiBzdHJpbmdzXG4gIC8vIHJhaXNpbmcgYSBGcm96ZW5FcnJvci5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0ciBbU3RyaW5nXSB0aGUgc3RyaW5nIG9uIHdoaWNoIHRoZSBlbmNvZGluZyBzaG91bGQgYmUgc2V0XG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBjYW5vbmljYWwgbmFtZSBvZiB0aGUgZW5jb2RpbmdcbiAgLy8gQHBhcmFtIHR5cGUgW1N0cmluZ10gcG9zc2libGUgdmFsdWVzIGFyZSBlaXRoZXIgYFwiZW5jb2RpbmdcImAsIGBcImludGVybmFsX2VuY29kaW5nXCJgLCBvciBgdW5kZWZpbmVkXG4gIE9wYWwuc2V0X2VuY29kaW5nID0gZnVuY3Rpb24oc3RyLCBuYW1lLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInVuZGVmaW5lZFwiKSB0eXBlID0gXCJlbmNvZGluZ1wiO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIuJCRmcm96ZW4gPT09IHRydWUpXG4gICAgICB0aHJvdyBPcGFsLkZyb3plbkVycm9yLiRuZXcoXCJjYW4ndCBtb2RpZnkgZnJvemVuIFN0cmluZ1wiKTtcblxuICAgIHZhciBlbmNvZGluZyA9IE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gc3RyW3R5cGVdKSB7IHJldHVybiBzdHI7IH1cblxuICAgIHN0clt0eXBlXSA9IGVuY29kaW5nO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvLyBGZXRjaGVzIHRoZSBlbmNvZGluZyBmb3IgdGhlIGdpdmVuIG5hbWUgb3IgcmFpc2VzIEFyZ3VtZW50RXJyb3IuXG4gIE9wYWwuZmluZF9lbmNvZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnaXN0ZXIgPSBPcGFsLmVuY29kaW5ncztcbiAgICB2YXIgZW5jb2RpbmcgPSByZWdpc3RlcltuYW1lXSB8fCByZWdpc3RlcltuYW1lLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICghZW5jb2RpbmcpIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gXCIgKyBuYW1lKTtcbiAgICByZXR1cm4gZW5jb2Rpbmc7XG4gIH1cblxuICAvLyBAcmV0dXJucyBhIFN0cmluZyBvYmplY3Qgd2l0aCB0aGUgZW5jb2Rpbmcgc2V0IGZyb20gYSBzdHJpbmcgbGl0ZXJhbFxuICBPcGFsLmVuYyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSkge1xuICAgIHZhciBkdXAgPSBuZXcgU3RyaW5nKHN0cik7XG4gICAgZHVwID0gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBuYW1lKTtcbiAgICBkdXAuaW50ZXJuYWxfZW5jb2RpbmcgPSBkdXAuZW5jb2Rpbmc7XG4gICAgcmV0dXJuIGR1cFxuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGludGVybmFsIGVuY29kaW5nIHNldCB0byBCaW5hcnlcbiAgT3BhbC5iaW5hcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiBPcGFsLnNldF9lbmNvZGluZyhkdXAsIFwiYmluYXJ5XCIsIFwiaW50ZXJuYWxfZW5jb2RpbmdcIik7XG4gIH1cblxuICBPcGFsLmxhc3RfcHJvbWlzZSA9IG51bGw7XG4gIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gZmFsc2U7XG5cbiAgLy8gUnVuIGEgYmxvY2sgb2YgY29kZSwgYnV0IGlmIGl0IHJldHVybnMgYSBQcm9taXNlLCBkb24ndCBydW4gdGhlIG5leHRcbiAgLy8gb25lLCBidXQgcXVldWUgaXQuXG4gIE9wYWwucXVldWUgPSBmdW5jdGlvbihwcm9jKSB7XG4gICAgaWYgKE9wYWwubGFzdF9wcm9taXNlKSB7XG4gICAgICAvLyBUaGUgYXN5bmMgcGF0aCBpcyB0YWtlbiBvbmx5IGlmIGFueXRoaW5nIGJlZm9yZSByZXR1cm5lZCBhXG4gICAgICAvLyBQcm9taXNlKFYyKS5cbiAgICAgIE9wYWwubGFzdF9wcm9taXNlID0gT3BhbC5sYXN0X3Byb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbikgcmV0dXJuIHByb2MoT3BhbCk7XG4gICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoT3BhbC5yZXNwb25kX3RvKGVycm9yLCAnJGZ1bGxfbWVzc2FnZScpKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvci4kZnVsbF9tZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIC8vIEFib3J0IGZ1cnRoZXIgZXhlY3V0aW9uXG4gICAgICAgIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgT3BhbC5leGl0KDEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gT3BhbC5sYXN0X3Byb21pc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJldCA9IHByb2MoT3BhbCk7XG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgcmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBPcGFsLmxhc3RfcHJvbWlzZSA9IHJldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gT3BlcmF0b3IgaGVscGVyc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgZnVuY3Rpb24gYXJlX2JvdGhfbnVtYmVycyhsLHIpIHsgcmV0dXJuIHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJyB9XG5cbiAgT3BhbC5yYl9wbHVzICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgKyByIDogbFsnJCsnXShyKTsgfVxuICBPcGFsLnJiX21pbnVzICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCAtIHIgOiBsWyckLSddKHIpOyB9XG4gIE9wYWwucmJfdGltZXMgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsICogciA6IGxbJyQqJ10ocik7IH1cbiAgT3BhbC5yYl9kaXZpZGUgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgLyByIDogbFsnJC8nXShyKTsgfVxuICBPcGFsLnJiX2x0ICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCA8IHIgOiBsWyckPCddKHIpOyB9XG4gIE9wYWwucmJfZ3QgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsID4gciA6IGxbJyQ+J10ocik7IH1cbiAgT3BhbC5yYl9sZSAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPD0gciA6IGxbJyQ8PSddKHIpOyB9XG4gIE9wYWwucmJfZ2UgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsID49IHIgOiBsWyckPj0nXShyKTsgfVxuXG4gIC8vIE9wdGltaXplZCBoZWxwZXJzIGZvciBjYWxscyBsaWtlICR0cnV0aHkoKGEpWyckPT09J10oYikpIC0+ICRlcWVxZXEoYSwgYilcbiAgZnVuY3Rpb24gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocywgcmhzKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbGhzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcmhzID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgKHR5cGVvZiBsaHMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByaHMgPT09ICdzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRlcWVxKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyA9PT0gcmhzIDogJHRydXRoeSgobGhzKVsnJD09J10ocmhzKSk7XG4gIH07XG4gIE9wYWwuZXFlcSA9ICRlcWVxO1xuICBPcGFsLmVxZXFlcSA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyA9PT0gcmhzIDogJHRydXRoeSgobGhzKVsnJD09PSddKHJocykpO1xuICB9O1xuICBPcGFsLm5lcWVxID0gZnVuY3Rpb24obGhzLCByaHMpIHtcbiAgICByZXR1cm4gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocyxyaHMpID8gbGhzICE9PSByaHMgOiAkdHJ1dGh5KChsaHMpWyckIT0nXShyaHMpKTtcbiAgfTtcbiAgT3BhbC5ub3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBhcmcgfHwgbnVsbCA9PT0gYXJnIHx8IGZhbHNlID09PSBhcmcgfHwgbmlsID09PSBhcmcpIHJldHVybiB0cnVlO1xuICAgIGlmICh0cnVlID09PSBhcmcgfHwgYXJnWyckISddLiQkcHJpc3RpbmUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gJHRydXRoeShhcmdbJyQhJ10oKSk7XG4gIH1cblxuICAvLyBTaG9ydGN1dHMgLSBvcHRpbWl6ZWQgZnVuY3Rpb24gZ2VuZXJhdG9ycyBmb3Igc2ltcGxlIGtpbmRzIG9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiAkcmV0dXJuX3ZhbChhcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfVxuICBPcGFsLnJldHVybl92YWwgPSAkcmV0dXJuX3ZhbDtcblxuICBPcGFsLnJldHVybl9zZWxmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgT3BhbC5yZXR1cm5faXZhciA9IGZ1bmN0aW9uKGl2YXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7IHJldHVybiBuaWw7IH1cbiAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xuICAgIH1cbiAgfVxuICBPcGFsLmFzc2lnbl9pdmFyID0gZnVuY3Rpb24oaXZhcikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3ModGhpcyk7XG4gICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgT3BhbC5hc3NpZ25faXZhcl92YWwgPSBmdW5jdGlvbihpdmFyLCBzdGF0aWNfdmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2Vzcyh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gc3RhdGljX3ZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBQcmltaXRpdmVzIGZvciBoYW5kbGluZyBwYXJhbWV0ZXJzXG4gIE9wYWwuZW5zdXJlX2t3YXJncyA9IGZ1bmN0aW9uKGt3YXJncykge1xuICAgIGlmIChrd2FyZ3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaDIoW10sIHt9KTtcbiAgICB9IGVsc2UgaWYgKGt3YXJncy4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBrd2FyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdleHBlY3RlZCBrd2FyZ3MnKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmdldF9rd2FyZyA9IGZ1bmN0aW9uKGt3YXJncywga2V5KSB7XG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGt3YXJncy4kJHNtYXAsIGtleSkpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdtaXNzaW5nIGtleXdvcmQ6ICcra2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGt3YXJncy4kJHNtYXBba2V5XTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIE9wYWwuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdCA9ICRhbGxvY2F0ZV9jbGFzcygnQmFzaWNPYmplY3QnLCBudWxsKTtcbiAgT3BhbC5PYmplY3QgICAgICA9IF9PYmplY3QgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdPYmplY3QnLCBPcGFsLkJhc2ljT2JqZWN0KTtcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdNb2R1bGUnLCBPcGFsLk9iamVjdCk7XG4gIE9wYWwuQ2xhc3MgICAgICAgPSBDbGFzcyAgICAgICA9ICRhbGxvY2F0ZV9jbGFzcygnQ2xhc3MnLCBPcGFsLk1vZHVsZSk7XG4gIE9wYWwuT3BhbCAgICAgICAgPSBfT3BhbCAgICAgICA9ICRhbGxvY2F0ZV9tb2R1bGUoJ09wYWwnKTtcbiAgT3BhbC5LZXJuZWwgICAgICA9IEtlcm5lbCAgICAgID0gJGFsbG9jYXRlX21vZHVsZSgnS2VybmVsJyk7XG5cbiAgJHNldF9wcm90byhPcGFsLkJhc2ljT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk9iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5Nb2R1bGUsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuQ2xhc3MsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gIC8vIEJhc2ljT2JqZWN0IGNhbiByZWFjaCBpdHNlbGYsIGF2b2lkIGNvbnN0X3NldCB0byBza2lwIHRoZSAkJGJhc2VfbW9kdWxlIGxvZ2ljXG4gIEJhc2ljT2JqZWN0LiQkY29uc3QuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdDtcblxuICAvLyBBc3NpZ24gYmFzaWMgY29uc3RhbnRzXG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJCYXNpY09iamVjdFwiLCAgQmFzaWNPYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiT2JqZWN0XCIsICAgICAgIF9PYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiTW9kdWxlXCIsICAgICAgIE1vZHVsZSk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJDbGFzc1wiLCAgICAgICAgQ2xhc3MpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiT3BhbFwiLCAgICAgICAgIF9PcGFsKTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIktlcm5lbFwiLCAgICAgICBLZXJuZWwpO1xuXG4gIC8vIEZpeCBib290ZWQgY2xhc3NlcyB0byBoYXZlIGNvcnJlY3QgLmNsYXNzIHZhbHVlXG4gIEJhc2ljT2JqZWN0LiQkY2xhc3MgPSBDbGFzcztcbiAgX09iamVjdC4kJGNsYXNzICAgICA9IENsYXNzO1xuICBNb2R1bGUuJCRjbGFzcyAgICAgID0gQ2xhc3M7XG4gIENsYXNzLiQkY2xhc3MgICAgICAgPSBDbGFzcztcbiAgX09wYWwuJCRjbGFzcyAgICAgICA9IE1vZHVsZTtcbiAgS2VybmVsLiQkY2xhc3MgICAgICA9IE1vZHVsZTtcblxuICAvLyBGb3J3YXJkIC50b1N0cmluZygpIHRvICN0b19zXG4gICRwcm9wKF9PYmplY3QuJCRwcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b19zID0gdGhpcy4kdG9fcygpO1xuICAgIGlmICh0b19zLiQkaXNfc3RyaW5nICYmIHR5cGVvZih0b19zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGEgc3RyaW5nIGNyZWF0ZWQgdXNpbmcgbmV3IFN0cmluZygnc3RyaW5nJylcbiAgICAgIHJldHVybiB0b19zLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRvX3M7XG4gICAgfVxuICB9KTtcblxuICAvLyBNYWtlIEtlcm5lbCNyZXF1aXJlIGltbWVkaWF0ZWx5IGF2YWlsYWJsZSBhcyBpdCdzIG5lZWRlZCB0byByZXF1aXJlIGFsbCB0aGVcbiAgLy8gb3RoZXIgY29yZWxpYiBmaWxlcy5cbiAgJHByb3AoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcblxuICAvLyBJbnN0YW50aWF0ZSB0aGUgbWFpbiBvYmplY3RcbiAgT3BhbC50b3AgPSBuZXcgX09iamVjdCgpO1xuICBPcGFsLnRvcC4kdG9fcyA9IE9wYWwudG9wLiRpbnNwZWN0ID0gJHJldHVybl92YWwoJ21haW4nKTtcbiAgT3BhbC50b3AuJGRlZmluZV9tZXRob2QgPSB0b3BfZGVmaW5lX21ldGhvZDtcblxuICAvLyBGb3dhcmQgY2FsbHMgdG8gZGVmaW5lX21ldGhvZCBvbiB0aGUgdG9wIG9iamVjdCB0byBPYmplY3RcbiAgZnVuY3Rpb24gdG9wX2RlZmluZV9tZXRob2QoKSB7XG4gICAgdmFyIGFyZ3MgPSBPcGFsLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgYmxvY2sgPSB0b3BfZGVmaW5lX21ldGhvZC4kJHA7XG4gICAgdG9wX2RlZmluZV9tZXRob2QuJCRwID0gbnVsbDtcbiAgICByZXR1cm4gT3BhbC5zZW5kKF9PYmplY3QsICdkZWZpbmVfbWV0aG9kJywgYXJncywgYmxvY2spXG4gIH07XG5cbiAgLy8gTmlsXG4gIE9wYWwuTmlsQ2xhc3MgPSAkYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG4gIG5pbC4kJGZyb3plbiA9IHRydWU7XG4gIG5pbC4kJGNvbXBhcmFibGUgPSBmYWxzZTtcbiAgT2JqZWN0LnNlYWwobmlsKTtcblxuICBPcGFsLnRocm93ZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRocm93ZXIgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgJyt0eXBlKTtcbiAgICB0aHJvd2VyLiR0aHJvd2VyX3R5cGUgPSB0eXBlO1xuICAgIHRocm93ZXIuJHRocm93ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9IG5pbDtcbiAgICAgIHRocm93ZXIuJHYgPSB2YWx1ZTtcbiAgICAgIHRocm93IHRocm93ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gdGhyb3dlcjtcbiAgfTtcblxuICBPcGFsLnRfZXZhbF9yZXR1cm4gPSBPcGFsLnRocm93ZXIoXCJyZXR1cm5cIik7XG5cbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcblxuICAvLyBJZiBlbmFibGUtZmlsZS1zb3VyY2UtZW1iZWQgY29tcGlsZXIgb3B0aW9uIGlzIGVuYWJsZWQsIGVhY2ggbW9kdWxlIGxvYWRlZCB3aWxsIGFkZCBpdHNcbiAgLy8gc291cmNlcyB0byB0aGlzIG9iamVjdFxuICBPcGFsLmZpbGVfc291cmNlcyA9IHt9O1xufSkuY2FsbCh0aGlzKTtcbk9wYWwubG9hZGVkKFtcImNvcmVsaWIvcnVudGltZS5qc1wiXSk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVGO0FBQ0U7O0FBRUY7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVGO0FBQ0U7O0FBRUY7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOzs7QUFHQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUU7QUFDRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUY7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNPO0FBQ1Q7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTg3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pcmIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBEZWJ1ZyBpcyBhIGhlbHBlciBtb2R1bGUgdGhhdCBhbGxvd3MgdXMgdG8gY29uZHVjdCBzb21lIGRlYnVnZ2luZyBvblxuIyBhIGxpdmUgY29kZWJhc2UuIEl0IGdvZXMgd2l0aCBhbiBhc3N1bXB0aW9uLCB0aGF0IG9wYWwtcGFyc2VyIG9yXG4jIG9wYWwtcmVwbHV0aWxzIHdpbGwgbm90IGJlIGxvYWRlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGRvIHdoYXQgd2UgY2FuXG4jIHRvIHByb3Zpc2lvbiBpdC5cblxubW9kdWxlIE9wYWxcbiAgbW9kdWxlIElSQlxuICAgIGRlZiBzZWxmLmVuc3VyZV9sb2FkZWQobGlicmFyeSlcbiAgICAgIHJldHVybiBpZiBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgLmluY2x1ZGU/IGxpYnJhcnlcblxuICAgICAgdmVyc2lvbiA9IGlmIFJVQllfRU5HSU5FX1ZFUlNJT04uaW5jbHVkZT8gJ2RldidcbiAgICAgICAgICAgICAgICAgICdtYXN0ZXInXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgUlVCWV9FTkdJTkVfVkVSU0lPTlxuICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB1cmwgPSBcImh0dHBzOi8vY2RuLm9wYWxyYi5jb20vb3BhbC8je3ZlcnNpb259LyN7bGlicmFyeX0uanNcIlxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGxpYmNvZGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlclxuICAgICAgICAgIHZhciByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgICAgICAgIHIuc2VuZCgnJyk7XG4gICAgICAgICAgbGliY29kZSA9IHIucmVzcG9uc2VUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgXCJZb3UgbmVlZCB0byBwcm92aXNpb24gI3tsaWJyYXJ5fSB5b3Vyc2VsZiBpbiB0aGlzIGVudmlyb25tZW50XCJ9XG4gICAgICAgIH1cblxuICAgICAgICAobmV3IEZ1bmN0aW9uKCdPcGFsJywgbGliY29kZSkpKE9wYWwpO1xuXG4gICAgICAgIE9wYWwucmVxdWlyZShsaWJyYXJ5KTtcbiAgICAgIH1cblxuICAgICAgOjpLZXJuZWwucmFpc2UgXCJDb3VsZCBub3QgbG9hZCAje2xpYnJhcnl9IGZvciBzb21lIHJlYXNvblwiIHVubGVzcyBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgLmluY2x1ZGU/IGxpYnJhcnlcbiAgICBlbmRcblxuICAgIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpvdXRwdXRcblxuICAgIGRlZiBzZWxmLnByZXBhcmVfY29uc29sZSgmYmxvY2spXG4gICAgICBzZWxmLm91dHB1dCA9ICcnXG5cbiAgICAgIG9yaWdpbmFsID0ge1xuICAgICAgICAkc3Rkb3V0ID0+IC0+KGkpIHsgJHN0ZG91dCA9IGkgfSxcbiAgICAgICAgJHN0ZGVyciA9PiAtPihpKSB7ICRzdGRlcnIgPSBpIH0sXG4gICAgICB9XG5cbiAgICAgICMgUHJlcGFyZSBhIGJldHRlciBwcm9tcHQgZXhwZXJpZW5jZSBmb3IgYSBicm93c2VyXG4gICAgICBpZiBicm93c2VyP1xuICAgICAgICBvcmlnaW5hbC5lYWNoIGRvIHxwaXBlLCBwaXBlX3NldHRlcnxcbiAgICAgICAgICBuZXdfcGlwZSA9IHBpcGUuZHVwXG4gICAgICAgICAgbmV3X3BpcGUud3JpdGVfcHJvYyA9IHByb2MgZG8gfHN0cnxcbiAgICAgICAgICAgIHNlbGYub3V0cHV0ICs9IHN0clxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgPSBvdXRwdXQuc3BsaXQoXCJcXG5cIikubGFzdCgzMCkuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgKz0gXCJcXG5cIiBpZiBzdHIuZW5kX3dpdGg/IFwiXFxuXCJcblxuICAgICAgICAgICAgcGlwZS53cml0ZV9wcm9jLmNhbGwoc3RyKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIG5ld19waXBlLnR0eSA9IGZhbHNlXG4gICAgICAgICAgcGlwZV9zZXR0ZXIuY2FsbChuZXdfcGlwZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgb3JpZ2luYWxfcmVhZF9wcm9jID0gJHN0ZGluLnJlYWRfcHJvY1xuICAgICAgICAkc3RkaW4ucmVhZF9wcm9jID0gYGZ1bmN0aW9uKHMpIHsgdmFyIHAgPSBwcm9tcHQoI3tvdXRwdXR9KTsgaWYgKHAgIT09IG51bGwpIHJldHVybiBwICsgXCJcXG5cIjsgcmV0dXJuIG5pbDsgfWBcbiAgICAgIGVuZFxuXG4gICAgICB5aWVsZFxuICAgIGVuc3VyZVxuICAgICAgb3JpZ2luYWwuZWFjaCBkbyB8cGlwZSwgcGlwZV9zZXR0ZXJ8XG4gICAgICAgIHBpcGVfc2V0dGVyLmNhbGwocGlwZSlcbiAgICAgIGVuZFxuICAgICAgJHN0ZGluLnJlYWRfcHJvYyA9IG9yaWdpbmFsX3JlYWRfcHJvY1xuICAgICAgc2VsZi5vdXRwdXQgPSAnJ1xuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuYnJvd3Nlcj9cbiAgICAgIGB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YocHJvbXB0KSAhPT0gJ3VuZGVmaW5lZCdgXG4gICAgZW5kXG5cbiAgICBMSU5FQlJFQUtTID0gW1xuICAgICAgJ3VuZXhwZWN0ZWQgdG9rZW4gJGVuZCcsXG4gICAgICAndW50ZXJtaW5hdGVkIHN0cmluZyBtZWV0cyBlbmQgb2YgZmlsZSdcbiAgICBdLmZyZWV6ZVxuXG4gICAgY2xhc3MgU2lsZW5jZXJcbiAgICAgIGRlZiBpbml0aWFsaXplXG4gICAgICAgIEBzdGRlcnIgPSAkc3RkZXJyXG4gICAgICBlbmRcblxuICAgICAgZGVmIHNpbGVuY2VcbiAgICAgICAgQGNvbGxlY3RvciA9IDo6U3RyaW5nSU8ubmV3XG4gICAgICAgICRzdGRlcnIgPSBAY29sbGVjdG9yXG4gICAgICAgIHlpZWxkXG4gICAgICBlbnN1cmVcbiAgICAgICAgJHN0ZGVyciA9IEBzdGRlcnJcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgd2FybmluZ3NcbiAgICAgICAgQGNvbGxlY3Rvci5zdHJpbmdcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OkJpbmRpbmdcbiAgZGVmIGlyYlxuICAgIDo6T3BhbDo6SVJCLmVuc3VyZV9sb2FkZWQoJ29wYWwtcmVwbHV0aWxzJylcblxuICAgIHNpbGVuY2VyID0gOjpPcGFsOjpJUkI6OlNpbGVuY2VyLm5ld1xuXG4gICAgOjpPcGFsOjpJUkIucHJlcGFyZV9jb25zb2xlIGRvXG4gICAgICBsb29wIGRvXG4gICAgICAgIHByaW50ICc+PiAnXG4gICAgICAgIGxpbmUgPSBnZXRzXG4gICAgICAgIGJyZWFrIHVubGVzcyBsaW5lXG4gICAgICAgIGNvZGUgPSAnJ1xuXG4gICAgICAgIHB1dHMgbGluZSBpZiA6Ok9wYWw6OklSQi5icm93c2VyP1xuXG4gICAgICAgIGlmIGxpbmUuc3RhcnRfd2l0aD8gJ2xzICdcbiAgICAgICAgICBjb2RlID0gbGluZVszLi4tMV1cbiAgICAgICAgICBtb2RlID0gOmxzXG4gICAgICAgIGVsc2lmIGxpbmUgPT0gXCJsc1xcblwiXG4gICAgICAgICAgY29kZSA9ICdzZWxmJ1xuICAgICAgICAgIG1vZGUgPSA6bHNcbiAgICAgICAgZWxzaWYgbGluZS5zdGFydF93aXRoPyAnc2hvdyAnXG4gICAgICAgICAgY29kZSA9IGxpbmVbNS4uLTFdXG4gICAgICAgICAgbW9kZSA9IDpzaG93XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb2RlID0gbGluZVxuICAgICAgICAgIG1vZGUgPSA6aW5zcGVjdFxuICAgICAgICBlbmRcblxuICAgICAgICBqc19jb2RlID0gbmlsXG5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBzaWxlbmNlci5zaWxlbmNlIGRvXG4gICAgICAgICAgICBqc19jb2RlID0gYE9wYWwuY29tcGlsZShjb2RlLCB7aXJiOiB0cnVlfSlgXG4gICAgICAgICAgZW5kXG4gICAgICAgIHJlc2N1ZSBTeW50YXhFcnJvciA9PiBlXG4gICAgICAgICAgaWYgOjpPcGFsOjpJUkI6OkxJTkVCUkVBS1MuaW5jbHVkZT8oZS5tZXNzYWdlKVxuICAgICAgICAgICAgcHJpbnQgJy4uICdcbiAgICAgICAgICAgIGxpbmUgPSBnZXRzXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIGxpbmVcbiAgICAgICAgICAgIHB1dHMgbGluZSBpZiA6Ok9wYWw6OklSQi5icm93c2VyP1xuICAgICAgICAgICAgY29kZSArPSBsaW5lXG4gICAgICAgICAgICByZXRyeVxuICAgICAgICAgIGVsc2lmIHNpbGVuY2VyLndhcm5pbmdzLmVtcHR5P1xuICAgICAgICAgICAgd2FybiBlLmZ1bGxfbWVzc2FnZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgTW9zdCBsaWtlbHkgYSBwYXJzZXIgZXJyb3JcbiAgICAgICAgICAgIHdhcm4gc2lsZW5jZXIud2FybmluZ3NcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICAgICAgaWYgbW9kZSA9PSA6c2hvd1xuICAgICAgICAgIHB1dHMganNfY29kZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICBlbmRcblxuICAgICAgICBwdXRzIDo6UkVQTFV0aWxzLmV2YWxfYW5kX3ByaW50KGpzX2NvZGUsIG1vZGUsIGZhbHNlLCBzZWxmKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbiV4e1xuICAvLyBSdW4gaW4gV2ViVG9vbHMgY29uc29sZSB3aXRoOiBPcGFsLmlyYihjID0+IGV2YWwoYykpXG4gIE9wYWwuaXJiID0gZnVuY3Rpb24oZnVuKSB7XG4gICAgI3s6OkJpbmRpbmcubmV3KGBmdW5gKS5pcmJ9XG4gIH1cblxuICBPcGFsLmxvYWRfcGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgT3BhbC5PcGFsLklSQi4kZW5zdXJlX2xvYWRlZCgnb3BhbC1wYXJzZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgT3BhbC5ldmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIE9wYWwuZXZhbCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xuICAgICAgcmV0dXJuIE9wYWwuZXZhbChzdHIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgT3BhbC5jb21waWxlID09PSAndW5kZWZpbmVkJykge1xuICAgIE9wYWwuY29tcGlsZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xuICAgICAgcmV0dXJuIE9wYWwuY29tcGlsZShzdHIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+IiwiPG1vZHVsZTpJUkI+IiwiZW5zdXJlX2xvYWRlZCIsInNlbGYiLCJsaWJyYXJ5IiwiaW5jbHVkZT8iLCJ2ZXJzaW9uIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInVybCIsIktlcm5lbCIsInJhaXNlIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsInByZXBhcmVfY29uc29sZSIsIm91dHB1dD0iLCJvcmlnaW5hbCIsIiRzdGRvdXQiLCJibG9jayBpbiBwcmVwYXJlX2NvbnNvbGUiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmVwYXJlX2NvbnNvbGUiLCIkc3RkZXJyIiwiYnJvd3Nlcj8iLCJlYWNoIiwicGlwZSIsInBpcGVfc2V0dGVyIiwibmV3X3BpcGUiLCJkdXAiLCJ3cml0ZV9wcm9jPSIsInByb2MiLCJzdHIiLCJibG9jayAoMyBsZXZlbHMpIGluIHByZXBhcmVfY29uc29sZSIsIisiLCJvdXRwdXQiLCJzcGxpdCIsImxhc3QiLCIzMCIsImpvaW4iLCJlbmRfd2l0aD8iLCJ3cml0ZV9wcm9jIiwiY2FsbCIsInR0eT0iLCJvcmlnaW5hbF9yZWFkX3Byb2MiLCIkc3RkaW4iLCJyZWFkX3Byb2MiLCJyZWFkX3Byb2M9IiwiZnJlZXplIiwiPGNsYXNzOlNpbGVuY2VyPiIsImluaXRpYWxpemUiLCJAc3RkZXJyIiwic2lsZW5jZSIsIkBjb2xsZWN0b3IiLCJTdHJpbmdJTyIsIm5ldyIsIndhcm5pbmdzIiwic3RyaW5nIiwiPGNsYXNzOkJpbmRpbmc+IiwiaXJiIiwiT3BhbDo6SVJCIiwiT3BhbCIsInNpbGVuY2VyIiwiT3BhbDo6SVJCOjpTaWxlbmNlciIsImJsb2NrIGluIGlyYiIsImJsb2NrICgyIGxldmVscykgaW4gaXJiIiwibG9vcCIsImJsb2NrICgzIGxldmVscykgaW4gaXJiIiwicHJpbnQiLCJsaW5lIiwiZ2V0cyIsImNvZGUiLCJwdXRzIiwic3RhcnRfd2l0aD8iLCJbXSIsIjMiLCItMSIsIm1vZGUiLCI1IiwianNfY29kZSIsImJsb2NrICg0IGxldmVscykgaW4gaXJiIiwiU3ludGF4RXJyb3IiLCJlIiwiT3BhbDo6SVJCOjpMSU5FQlJFQUtTIiwibWVzc2FnZSIsImVtcHR5PyIsIndhcm4iLCJmdWxsX21lc3NhZ2UiLCJSRVBMVXRpbHMiLCJldmFsX2FuZF9wcmludCIsIkJpbmRpbmciXSwibWFw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QUEsQ0FBQUEsQ0FBdkIsQ0FBQTtrQkFDRS9FLElBQUFnRixNQUFBQSxDQUFLSixDQUFDSyxjQUFBQSxDQUFBQSxDQUFORDtnQkFERjtrQkFJRWhGLElBQUFnRixNQUFBQSxDQUFLeEIsUUFBUU4sVUFBQUEsQ0FBQUEsQ0FBYjhCO2dCQUpGO2NBUkY7WUFBQSxDQUhFO1VBQUEsQ0FBQTtVQW1CRixJQUFBLE1BQUdULElBQUgsRUFBVyxNQUFYLENBQUE7O1lBQ0V2RSxJQUFBa0UsTUFBQUEsQ0FBS08sT0FBTFA7WUFDQSxTQUFBLFFBQUE7VUFGRjtVQUtBTCxPQUFBN0QsSUFBQWtFLE1BQUFBLENBQUtnQixnQkFBV0MsZ0JBQUFBLENBQWdCVixPQUEzQixFQUFvQ0YsSUFBcEMsRUFBMEMsS0FBMUMsRUFBaUR2RSxJQUF0Q21GLENBQWhCakIsRUFqREZQLENBQUFBLEdBQUFBLHVDQUFBQSxDQUFBQyxDQUFBQTtVQUFBQTtVQUFBQTtRQUFBQSxDQUFBQSxJQURGRixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBV2hELEVBTGIyQztRQUFBQTtRQUFBQTtNQUFBQTtJQUFBQSxDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBOztBQStEQXhEO0FBQ0FBO0FBQ0FBLElBQU13RixjQUFTbkMsS0FBQUEsQ0FBTXJELEdBQU5xRCxDQUFXSSxLQUFBQSxDQUFBQTtBQUMxQnpEOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQTlMQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2JpbmRpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpCaW5kaW5nXG4gICMgQHByaXZhdGVcbiAgZGVmIGluaXRpYWxpemUoanNldmFsLCBzY29wZV92YXJpYWJsZXMgPSBbXSwgcmVjZWl2ZXIgPSB1bmRlZmluZWQsIHNvdXJjZV9sb2NhdGlvbiA9IG5pbClcbiAgICBAanNldmFsLCBAc2NvcGVfdmFyaWFibGVzLCBAcmVjZWl2ZXIsIEBzb3VyY2VfbG9jYXRpb24gPSBcXFxuICAgICAganNldmFsLCBzY29wZV92YXJpYWJsZXMsIHJlY2VpdmVyLCBzb3VyY2VfbG9jYXRpb25cbiAgICByZWNlaXZlciA9IGpzX2V2YWwoJ3NlbGYnKSB1bmxlc3MgYHR5cGVvZiByZWNlaXZlciAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYganNfZXZhbCgqYXJncylcbiAgICBpZiBAanNldmFsXG4gICAgICBAanNldmFsLmNhbGwoKmFyZ3MpXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgJ0V2YWx1YXRpb24gb24gYSBQcm9jI2JpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX2dldChzeW1ib2wpXG4gICAganNfZXZhbChzeW1ib2wpXG4gIHJlc2N1ZSA6OkV4Y2VwdGlvblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImxvY2FsIHZhcmlhYmxlIGAje3N5bWJvbH0nIGlzIG5vdCBkZWZpbmVkIGZvciAje2luc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX3NldChzeW1ib2wsIHZhbHVlKVxuICAgIGBPcGFsLkJpbmRpbmcudG1wX3ZhbHVlID0gdmFsdWVgXG4gICAganNfZXZhbChcIiN7c3ltYm9sfSA9IE9wYWwuQmluZGluZy50bXBfdmFsdWVcIilcbiAgICBgZGVsZXRlIE9wYWwuQmluZGluZy50bXBfdmFsdWVgXG4gICAgdmFsdWVcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlc1xuICAgIEBzY29wZV92YXJpYWJsZXNcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX2RlZmluZWQ/KHZhbHVlKVxuICAgIEBzY29wZV92YXJpYWJsZXMuaW5jbHVkZT8odmFsdWUpXG4gIGVuZFxuXG4gIGRlZiBldmFsKHN0ciwgZmlsZSA9IG5pbCwgbGluZSA9IG5pbClcbiAgICByZXR1cm4gcmVjZWl2ZXIgaWYgc3RyID09ICdzZWxmJ1xuXG4gICAgOjpLZXJuZWwuZXZhbChzdHIsIHNlbGYsIGZpbGUsIGxpbmUpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWNlaXZlciwgOnNvdXJjZV9sb2NhdGlvblxuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgYmluZGluZ1xuICAgIDo6S2VybmVsLnJhaXNlIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgZHluYW1pYyBjYWxscyB0byBiaW5kaW5nXCJcbiAgZW5kXG5lbmRcblxuVE9QTEVWRUxfQklORElORyA9IDo6QmluZGluZy5uZXcoXG4gICV4e1xuICAgIGZ1bmN0aW9uKGpzKSB7XG4gICAgICByZXR1cm4gKG5ldyBGdW5jdGlvbihcInNlbGZcIiwgXCJyZXR1cm4gXCIgKyBqcykpKHNlbGYpO1xuICAgIH1cbiAgfSxcbiAgW10sIHNlbGYsIFsnPG1haW4+JywgMF1cbilcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJpbmRpbmc+IiwiaW5pdGlhbGl6ZSIsImpzZXZhbCIsInNjb3BlX3ZhcmlhYmxlcyIsInJlY2VpdmVyIiwic291cmNlX2xvY2F0aW9uIiwiQGpzZXZhbCIsIkBzY29wZV92YXJpYWJsZXMiLCJAcmVjZWl2ZXIiLCJAc291cmNlX2xvY2F0aW9uIiwic2VsZiIsImpzX2V2YWwiLCJjYWxsIiwiYXJncyIsIktlcm5lbCIsInJhaXNlIiwibG9jYWxfdmFyaWFibGVfZ2V0Iiwic3ltYm9sIiwiRXhjZXB0aW9uIiwiTmFtZUVycm9yIiwiaW5zcGVjdCIsImxvY2FsX3ZhcmlhYmxlX3NldCIsInZhbHVlIiwibG9jYWxfdmFyaWFibGVzIiwibG9jYWxfdmFyaWFibGVfZGVmaW5lZD8iLCJpbmNsdWRlPyIsImV2YWwiLCJzdHIiLCJmaWxlIiwibGluZSIsImF0dHJfcmVhZGVyIiwiPG1vZHVsZTpLZXJuZWw+IiwiYmluZGluZyIsIkJpbmRpbmciLCJuZXciLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7OztBQUVFQyxJQUFBQSwwQkFBQUEsc0JBQWVDLE1BQUQsRUFBU0MsZUFBVCxFQUErQkMsUUFBL0IsRUFBcURDLGVBQW5FSjtBQUFBQSxNQUFBQTs7O01BQXVCLCtDQUFrQjs7TUFBMEIsK0NBQWtCO01BQ25GLEtBQ0UsQ0FBQUMsTUFBQSxFQUFRQyxlQUFSLEVBQXlCQyxRQUF6QixFQUFtQ0MsZUFBbkMsQ0FERixFQUFBQyxDQUFBQSxjQUFBLEtBQUFBLENBQUEsRUFBU0MsQ0FBQUEsdUJBQVQsS0FBU0EsQ0FBVCxFQUEyQkMsQ0FBQUEsZ0JBQTNCLEtBQTJCQSxDQUEzQixFQUFzQ0MsQ0FBQUEsdUJBQXRDLEtBQXNDQSxDQUF0QztNQUVBLElBQUEsUUFBbUNSLDZCQUFuQyxDQUFBO1FBTEpBLE9BQUE7TUFLSTtRQUFBQSxPQUFBRyxDQUFBQSxXQUFXTSxJQUFBQyxTQUFBQSxDQUFRVixNQUFSVSxDQUFYUDtNQUFBO0lBSEZILENBQUFBLElBQUFBOztBQU1BVSxJQUFBQSx1QkFBQUEsbUJBUkYsRUFRRUE7QUFBQUEsTUFBQUE7OztNQVJGO01BUWM7TUFDVixJQUFBLFFBQUdMLFdBQUgsQ0FBQTtRQUNFSyxPQUFPQyxNQUFQTixXQUFPTSxRQUFBQSxFQUFNLE1BQUNDLElBQUQsQ0FBTkQ7TUFEVDtRQUdFRCxPQUFBRyxPQUFRQyxPQUFBQSxDQUFPSiwrQ0FBUEk7TUFIVjtJQURGSixDQUFBQSxJQUFBQTs7QUFRQUssSUFBQUEsa0NBQUFBLDhCQUF1QkMsTUFBdkJEO0FBQUFBLE1BQUFBOztNQUNFO1FBQUFBLE9BQUFOLElBQUFDLFNBQUFBLENBQVFNLE1BQVJOO01BQUE7UUFDRixzQkFBTyxDQUFBTyxnQkFBQSxDQUFQO1VBQUE7WUFDRUYsT0FBQUYsT0FBUUMsT0FBQUEsQ0FBT0ksZ0JBQWYsRUFBNkJILGtCQUFELEdBQUEsQ0FBbUJDLE1BQW5CLENBQUEsR0FBMEJELHVCQUExQixHQUFBLENBQWlETixJQUFBVSxTQUFBQSxDQUFBQSxDQUFqRCxDQUFwQkw7VUFEVjtRQUFBLENBREU7TUFBQTtJQURGQyxDQUFBQSxHQUFBQTs7QUFNQUssSUFBQUEsa0NBQUFBLDhCQUF1QkosTUFBRCxFQUFTSyxLQUEvQkQ7QUFBQUEsTUFBQUE7OztNQUNHQTtNQUNEWCxJQUFBQyxTQUFBQSxDQUFRLEVBQUEsR0FBQSxDQUFHTSxNQUFILENBQUEsR0FBVUksMkJBQWxCVjtNQUNDVTtNQUNEQSxPQUFBQztJQUpGRCxDQUFBQSxHQUFBQTs7QUFPQUUsSUFBQUEsK0JBQUFBLGFBQ0UsaUJBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSx1Q0FBQUEsZ0RBQTRCRixLQUE1QkU7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFqQixvQkFBZ0JrQixhQUFBQSxDQUFVSCxLQUFWRztJQURsQkQsQ0FBQUEsR0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSx5QkFBU0MsR0FBRCxFQUFNQyxJQUFOLEVBQWtCQyxJQUExQkgsR0FBQUEsTUFBQUEsSUFBQUEsd0NBQUFBO0FBQUFBLE1BQUFBOzs7TUFBYyx5QkFBTztNQUFLLHlCQUFPO01BQy9CLElBQUEsTUFBbUJDLEdBQW5CLEVBQTBCRCxNQUExQixDQUFBO1FBQUEsT0FBT2hCLElBQUFOLFVBQUFBLENBQUFBO01BQVA7TUFFQXNCLE9BQUFaLE9BQVFZLE1BQUFBLENBQU1DLEdBQWQsRUFBbUJqQixJQUFuQixFQUF5QmtCLElBQXpCLEVBQStCQyxJQUF2QkgsRUFIVkE7UUFBQUE7UUFBQUE7TUFBQUE7SUFBQUEsQ0FBQUEsSUFBQUE7SUFNQTFCLE9BQUFVLElBQUFvQixhQUFBQSxDQUFZLFVBQVosRUFBdUIsaUJBQXZCQTtFQTNDRjlCLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE4Q0ErQjtFQUFBQTs7O0lBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUE7TUFDRUEsT0FBQWxCLE9BQVFDLE9BQUFBLENBQU9pQiwrQ0FBUGpCO0lBRFZpQixDQUFBQSxHQUFBQTtFQURGRCxHQUFPLElBQVBBO0VBTUFoQyxPQUFBLDRDQUFtQmtDLGNBQVNDLEtBQUFBO0FBRTVCbkM7QUFDQUE7QUFDQUE7QUFDQUEsRUFMbUIsRUFNakIsRUFOaUIsRUFNYlcsSUFOYSxFQU1QLENBQUNYLFFBQUQsRUFBV29DLENBQVgsQ0FOZ0JELENBQTVCO0FBcERBbkM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzNDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Vuc3VwcG9ydGVkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiV4e1xuICB2YXIgd2FybmluZ3MgPSB7fTtcblxuICBmdW5jdGlvbiBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShtZXNzYWdlKSB7XG4gICAgc3dpdGNoIChPcGFsLmNvbmZpZy51bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eSkge1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyA6OlN0cmluZ1xuICBgdmFyIEVSUk9SID0gXCJTdHJpbmcjJXMgbm90IHN1cHBvcnRlZC4gTXV0YWJsZSBTdHJpbmcgbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBPcGFsLlwiYFxuXG4gICVpW1xuICAgIDw8IGNhcGl0YWxpemUhIGNob21wISBjaG9wISBkb3duY2FzZSEgZ3N1YiEgbHN0cmlwISBuZXh0ISByZXZlcnNlIVxuICAgIHNsaWNlISBzcXVlZXplISBzdHJpcCEgc3ViISBzdWNjISBzd2FwY2FzZSEgdHIhIHRyX3MhIHVwY2FzZSEgcHJlcGVuZFxuICAgIFtdPSBjbGVhciBlbmNvZGUhIHVuaWNvZGVfbm9ybWFsaXplIVxuICBdLmVhY2ggZG8gfG1ldGhvZF9uYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kX25hbWUgZG8gfCp8XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSBtZXRob2RfbmFtZVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgOjpLZXJuZWxcbiAgYHZhciBFUlJPUiA9IFwiT2JqZWN0IHRhaW50aW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgT3BhbFwiYFxuXG4gIGRlZiB0YWludFxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdW50YWludFxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdGFpbnRlZD9cbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6TW9kdWxlXG4gIGRlZiBwdWJsaWMoKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtZXRob2RzLmxlbmd0aCA9PT0gMSkgPyBtZXRob2RzWzBdIDogbWV0aG9kcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqbWV0aG9kcylcbiAgICBgcmV0dXJuIChtZXRob2RzLmxlbmd0aCA9PT0gMSkgPyBtZXRob2RzWzBdIDogbWV0aG9kc2BcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcHJpdmF0ZV9jb25zdGFudCgqKVxuICBlbmRcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuICBhbGlhcyBwcm90ZWN0ZWQgcHVibGljXG4gIGFsaWFzIHByb3RlY3RlZF9tZXRob2RfZGVmaW5lZD8gcHJpdmF0ZV9tZXRob2RfZGVmaW5lZD9cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kcyBpbnN0YW5jZV9tZXRob2RzXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBwcml2YXRlX21ldGhvZHMoKm1ldGhvZHMpXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG4gIGFsaWFzIHByaXZhdGVfaW5zdGFuY2VfbWV0aG9kcyBwcml2YXRlX21ldGhvZHNcbiAgYWxpYXMgcHJvdGVjdGVkX2luc3RhbmNlX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBldmFsKCopXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BhbC9vcGFsL2Jsb2IvI3tSVUJZX0VOR0lORV9WRVJTSU9OfS9kb2NzL29wYWxfcGFyc2VyLm1kIGZvciBkZXRhaWxzLlwiXG4gIGVuZFxuZW5kXG5cbmRlZiBzZWxmLnB1YmxpYygqbWV0aG9kcylcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqbWV0aG9kcylcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiS2VybmVsIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwic2VsZiIsIndhcm4iLCI8Y2xhc3M6U3RyaW5nPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6U3RyaW5nPiIsIm1ldGhvZF9uYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6U3RyaW5nPiIsImRlZmluZV9tZXRob2QiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpTdHJpbmc+IiwiJSIsIjxtb2R1bGU6S2VybmVsPiIsInRhaW50IiwidW50YWludCIsInRhaW50ZWQ/IiwiPGNsYXNzOk1vZHVsZT4iLCJwdWJsaWMiLCJwcml2YXRlX2NsYXNzX21ldGhvZCIsInByaXZhdGVfbWV0aG9kX2RlZmluZWQ/IiwicHJpdmF0ZV9jb25zdGFudCIsInByaXZhdGVfbWV0aG9kcyIsImV2YWwiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOzs7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLE1BQVFDLE9B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Q0EsYUFBTSwwQkFBTixFQUErQixpQkFBL0I7SUFDQVQsT0FBQSxhQUFNLDRCQUFOLEVBQWlDLGlCQUFqQztFQVBGQSxHQUFPLElBQVBBO0VBVUFBO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQVUsb0JBQUFBLHdCQXRHRixFQXNHRUE7QUFBQUEsTUFBQUE7OztNQXRHRjtNQXNHVztNQUNQQSxPQUFBdkIsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQWYsRUFBc0NxQiw0REFBQSxHQUFBLENBQ0NBLHdDQUFELEdBQUEsQ0FBeUNDLHlCQUF6QyxDQUFBLEdBQTZERCxtQ0FEN0QsQ0FBOUJ0QjtJQURWc0IsQ0FBQUEsSUFBQUE7RUFERlYsR0FBTyxJQUFQQTtFQU9BSyxNQUFJZixJQUFKZSxhQUFBQSxtQkE1R0EsRUE0R0FBO0FBQUFBLElBQUFBOzs7SUE1R0E7SUE0R2dCO0lBQ2JBLG9EQUFEQTtFQURGQSxDQUFBQSxJQUFBQTtFQUlBbkIsT0FBQTBCLE1BQUl0QixJQUFKc0IsY0FBQUEsb0JBaEhBLEVBZ0hBQTtBQUFBQSxJQUFBQTs7O0lBaEhBO0lBZ0hpQjtJQUNkQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7QUFoSEExQjsifX0seyJvZmZzZXQiOnsibGluZSI6MzUxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XG5cbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlcidcblxuY2xhc3MgOjpSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBzZWxmLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoISR0cnV0aHkoY291bnQpKSBjb3VudCA9IDE2O1xuICAgICAgaWYgKHR5cGVvZiBjb3VudCAhPT0gXCJudW1iZXJcIikgY291bnQgPSAje2Bjb3VudGAudG9faW50fTtcbiAgICAgIGlmIChjb3VudCA8IDApICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgc3RyaW5nIHNpemUgKG9yIHNpemUgdG9vIGJpZyknfTtcbiAgICAgIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzZWVkID0gOjpSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IDo6T3BhbC5jb2VyY2VfdG8hKHNlZWQsIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICBAc3RhdGUgPSBzZWVkXG4gICAgcmVzZWVkKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiByZXNlZWQoc2VlZClcbiAgICBAc2VlZCA9IHNlZWRcbiAgICBgc2VsZi4kcm5nID0gT3BhbC4kJHJhbmQucmVzZWVkKHNlZWQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5uZXdfc2VlZFxuICAgIGBPcGFsLiQkcmFuZC5uZXdfc2VlZCgpYFxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgIHNlbGY6OkRFRkFVTFQucmFuZChsaW1pdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuc3JhbmQobiA9IDo6UmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICBwcmV2aW91c19zZWVkID0gc2VsZjo6REVGQVVMVC5zZWVkXG4gICAgc2VsZjo6REVGQVVMVC5yZXNlZWQobilcbiAgICBwcmV2aW91c19zZWVkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnVyYW5kb20oc2l6ZSlcbiAgICA6OlNlY3VyZVJhbmRvbS5ieXRlcyhzaXplKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyA6OlJhbmRvbSA9PT0gb3RoZXJcblxuICAgIHNlZWQgPT0gb3RoZXIuc2VlZCAmJiBzdGF0ZSA9PSBvdGhlci5zdGF0ZVxuICBlbmRcblxuICBkZWYgYnl0ZXMobGVuZ3RoKVxuICAgIGxlbmd0aCA9IDo6UmFuZG9tLl92ZXJpZnlfY291bnQobGVuZ3RoKVxuXG4gICAgOjpBcnJheS5uZXcobGVuZ3RoKSB7IHJhbmQoMjU1KS5jaHIgfS5qb2luLmVuY29kZSgnQVNDSUktOEJJVCcpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmJ5dGVzKGxlbmd0aClcbiAgICBzZWxmOjpERUZBVUxULmJ5dGVzKGxlbmd0aClcbiAgZW5kXG5cbiAgZGVmIHJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgcmFuZG9tX251bWJlcihsaW1pdClcbiAgZW5kXG5cbiAgIyBOb3QgcGFydCBvZiB0aGUgUnVieSBpbnRlcmZhY2UgKHVzZSAjcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkpLCBidXRcbiAgIyB1c2VkIGJ5IFJhbmRvbTo6Rm9ybWF0dGVyIGFzIGEgc2hvcnRjdXQsIGFzIGZvciBSYW5kb20gaW50ZXJmYWNlIHRoZSBmbG9hdFxuICAjIFJORyBpcyBwcmltYXJ5LlxuICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgJXh7XG4gICAgICBzZWxmLnN0YXRlKys7XG4gICAgICByZXR1cm4gT3BhbC4kJHJhbmQucmFuZChzZWxmLiRybmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmFuZG9tX2Zsb2F0XG4gICAgc2VsZjo6REVGQVVMVC5yYW5kb21fZmxvYXRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZ2VuZXJhdG9yPShnZW5lcmF0b3IpXG4gICAgYE9wYWwuJCRyYW5kID0gI3tnZW5lcmF0b3J9YFxuXG4gICAgaWYgY29uc3RfZGVmaW5lZD8gOkRFRkFVTFRcbiAgICAgIHNlbGY6OkRFRkFVTFQucmVzZWVkXG4gICAgZWxzZVxuICAgICAgY29uc3Rfc2V0IDpERUZBVUxULCBuZXcobmV3X3NlZWQpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhbmRvbT4iLCJhdHRyX3JlYWRlciIsIl92ZXJpZnlfY291bnQiLCJjb3VudCIsInRvX2ludCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluaXRpYWxpemUiLCJzZWVkIiwiUmFuZG9tIiwibmV3X3NlZWQiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJAc3RhdGUiLCJyZXNlZWQiLCJAc2VlZCIsInJhbmQiLCJsaW1pdCIsInNlbGY6OkRFRkFVTFQiLCJzcmFuZCIsIm4iLCJwcmV2aW91c19zZWVkIiwidXJhbmRvbSIsInNpemUiLCJTZWN1cmVSYW5kb20iLCJieXRlcyIsIj09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJzdGF0ZSIsImxlbmd0aCIsIm5ldyIsIkFycmF5IiwiYmxvY2sgaW4gYnl0ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ5dGVzIiwiMjU1IiwiY2hyIiwiam9pbiIsImVuY29kZSIsInJhbmRvbV9udW1iZXIiLCJyYW5kb21fZmxvYXQiLCJnZW5lcmF0b3I9IiwiZ2VuZXJhdG9yIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9zZXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsMEJBQVJFO0VBRUFDO0VBQUFBOzs7O0lBQ0VGLElBQUFHLGFBQUFBLENBQVksTUFBWixFQUFtQixPQUFuQkE7SUFFQUMsTUFBSUosSUFBSkksb0JBQUFBLHlCQUF1QkMsS0FBdkJEO0FBQUFBOztBQUVGQTtBQUNBQSw2Q0FBK0NBLENBQUNBLEtBQURBLENBQU9FLFFBQUFBLENBQUFBLENBQVFGO0FBQzlEQSxxQkFBdUJHLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDTCx3Q0FBeEJJLENBQWlFSjtBQUNoR0E7QUFDQUE7QUFDQUE7SUFQRUEsQ0FBQUEsR0FBQUE7O0FBVUFNLElBQUFB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QUFBQTtJQU9BQSxNQUFJNUMsSUFBSjRDLG1CQUFBQSx3QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF0QixJQUFBdEIsSUFBQXNCLFlBQWFzQixjQUFBQSxDQUFBQTtJQURmQSxDQUFBQSxHQUFBQTtJQUlBMUMsT0FBQTJDLE1BQUk3QyxJQUFKNkMsaUJBQUFBLGdDQUFvQkMsU0FBcEJEO0FBQUFBLE1BQUFBOzs7TUFDR0EsY0FBZ0JDO01BRWpCLElBQUEsUUFBRzlDLElBQUErQyxtQkFBQUEsQ0FBZSxTQUFmQSxDQUFILENBQUE7UUFDRUYsT0FBQXZCLElBQUF0QixJQUFBc0IsWUFBYUosUUFBQUEsQ0FBQUE7TUFEZjtRQUdFMkIsT0FBQTdDLElBQUFnRCxXQUFBQSxDQUFVLFNBQVYsRUFBb0JoRCxJQUFBbUMsS0FBQUEsQ0FBSW5DLElBQUFhLFVBQUFBLENBQUFBLENBQUpzQixDQUFwQmE7TUFIRjtJQUhGSCxDQUFBQSxHQUFBQTtFQTlFRjNDLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUF5RkFILE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGlDQUFSRTtBQTdGQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2Nlc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6UHJvY2Vzc1xuICBAX19jbG9ja3NfXyA9IFtdXG4gIGRlZiBzZWxmLl9fcmVnaXN0ZXJfY2xvY2tfXyhuYW1lLCBmdW5jKVxuICAgIGNvbnN0X3NldCBuYW1lLCBAX19jbG9ja3NfXy5zaXplXG4gICAgQF9fY2xvY2tzX18gPDwgZnVuY1xuICBlbmRcblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18gOkNMT0NLX1JFQUxUSU1FLCBgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlLm5vdygpIH1gXG5cbiAgbW9ub3RvbmljID0gZmFsc2VcblxuICAleHtcbiAgICBpZiAoT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKE9wYWwuZ2xvYmFsLnByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICAgIC8vIGxldCBub3cgYmUgdGhlIGJhc2UgdG8gZ2V0IHNtYWxsZXIgbnVtYmVyc1xuICAgICAgdmFyIGhydGltZV9iYXNlID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBocnRpbWUgPSBwcm9jZXNzLmhydGltZShocnRpbWVfYmFzZSk7XG4gICAgICAgIHZhciB1cyA9IChocnRpbWVbMV0gLyAxMDAwKSB8IDA7IC8vIGN1dCBiZWxvdyBtaWNyb3NlY3M7XG4gICAgICAgIHJldHVybiAoKGhydGltZVswXSAqIDEwMDApICsgKHVzIC8gMTAwMCkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18oOkNMT0NLX01PTk9UT05JQywgbW9ub3RvbmljKSBpZiBtb25vdG9uaWNcblxuICBkZWYgc2VsZi5waWRcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRpbWVzXG4gICAgdCA9IDo6VGltZS5ub3cudG9fZlxuICAgIDo6QmVuY2htYXJrOjpUbXMubmV3KHQsIHQsIHQsIHQsIHQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsb2NrX2dldHRpbWUoY2xvY2tfaWQsIHVuaXQgPSA6ZmxvYXRfc2Vjb25kKVxuICAgIChjbG9jayA9IEBfX2Nsb2Nrc19fW2Nsb2NrX2lkXSkgfHwgOjpLZXJuZWwucmFpc2UoOjpFcnJubzo6RUlOVkFMLCBcImNsb2NrX2dldHRpbWUoI3tjbG9ja19pZH0pICN7QF9fY2xvY2tzX19bY2xvY2tfaWRdfVwiKVxuICAgICV4e1xuICAgICAgdmFyIG1zID0gY2xvY2soKTtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdmbG9hdF9zZWNvbmQnOiAgICAgIHJldHVybiAgKG1zIC8gMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYSBmbG9hdCAoZGVmYXVsdClcbiAgICAgICAgY2FzZSAnZmxvYXRfbWlsbGlzZWNvbmQnOiByZXR1cm4gIChtcyAvIDEpOyAgICAgICAgICAgIC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdmbG9hdF9taWNyb3NlY29uZCc6IHJldHVybiAgKG1zICogMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgICAgICAgcmV0dXJuICgobXMgLyAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgLyAxKSAgICAgICB8IDApOyAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAqIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzogICAgICAgIHJldHVybiAoKG1zICogMTAwMDAwMCkgfCAwKTsgLy8gbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgZGVmYXVsdDogI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwidW5leHBlY3RlZCB1bml0OiAje3VuaXR9XCJ9XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOlByb2Nlc3M+IiwiQF9fY2xvY2tzX18iLCJfX3JlZ2lzdGVyX2Nsb2NrX18iLCJzZWxmIiwibmFtZSIsImZ1bmMiLCJjb25zdF9zZXQiLCJzaXplIiwiPDwiLCJtb25vdG9uaWMiLCJwaWQiLCIwIiwidGltZXMiLCJ0IiwiVGltZSIsIm5vdyIsInRvX2YiLCJCZW5jaG1hcms6OlRtcyIsIkJlbmNobWFyayIsIm5ldyIsImNsb2NrX2dldHRpbWUiLCJjbG9ja19pZCIsInVuaXQiLCIkcmV0X29yXzEiLCJjbG9jayIsIltdIiwiS2VybmVsIiwicmFpc2UiLCJFcnJubzo6RUlOVkFMIiwiRXJybm8iLCJBcmd1bWVudEVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsa0JBQWM7SUFDZEMsTUFBSUMsSUFBSkQseUJBQUFBLDhCQUE0QkUsSUFBRCxFQUFPQyxJQUFsQ0g7QUFBQUEsTUFBQUE7QUFBQUE7OztNQUNFQyxJQUFBRyxXQUFBQSxDQUFVRixJQUFWLEVBQWdCSCxlQUFXTSxNQUFBQSxDQUFBQSxDQUEzQkQ7TUFDQUosT0FBQUQsZUFBWU8sT0FBQUEsQ0FBR0gsSUFBSEc7SUFGZE4sQ0FBQUEsR0FBQUE7SUFLQUMsSUFBQUQsb0JBQUFBLENBQW1CLGdCQUFuQixFQUFxQ0YsZ0NBQXJDRTtJQUVBTyxZQUFZOztBQUdkVDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFFRSxJQUFBLFFBQW1EUyxTQUFuRCxDQUFBO01BQUFOLElBQUFELG9CQUFBQSxDQUFtQixpQkFBbkIsRUFBcUNPLFNBQXJDUDtJQUFBO0lBRUFRLE1BQUlQLElBQUpPLFVBQUFBLFlBQ0VDLENBREZELENBQUFBLEdBQUFBO0lBSUFFLE1BQUlULElBQUpTLFlBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0VDLElBQUlDLFdBQU1DLEtBQUFBLENBQUFBLENBQUlDLE1BQUFBLENBQUFBO01BQ2RKLE9BQUFLLElBQUFDLGdCQUFBRCxRQUFnQkUsS0FBQUEsQ0FBS04sQ0FBckIsRUFBd0JBLENBQXhCLEVBQTJCQSxDQUEzQixFQUE4QkEsQ0FBOUIsRUFBaUNBLENBQWpCTTtJQUZsQlAsQ0FBQUEsR0FBQUE7SUFLQVosT0FBQW9CLE1BQUlqQixJQUFKaUIsb0JBQUFBLHlCQUF1QkMsUUFBRCxFQUFXQyxJQUFqQ0Y7QUFBQUEsTUFBQUE7QUFBQUE7OztNQUFpQyx5QkFBTztNQUN0QyxJQUFBLFFBQUFHLENBQUFBLFlBQUNDLENBQUFBLFFBQVF2QixlQUFXd0IsT0FBQUEsQ0FBQ0osUUFBREksQ0FBbkJELENBQURELENBQUEsQ0FBQTtRQUFBO01BQUE7UUFBbUNHLE9BQVFDLE9BQUFBLENBQU9DLElBQUFDLFlBQUFELFdBQWYsRUFBaUNSLGdCQUFELEdBQUEsQ0FBaUJDLFFBQWpCLENBQUEsR0FBMEJELElBQTFCLEdBQUEsQ0FBOEJuQixlQUFXd0IsT0FBQUEsQ0FBQ0osUUFBREksQ0FBekMsQ0FBeEJFO01BQTNDOztBQUVKUDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJNLE9BQVFDLE9BQUFBLENBQU9HLG9CQUFmLEVBQWlDVixtQkFBRCxHQUFBLENBQW9CRSxJQUFwQixDQUF4Qks7QUFDM0JQO0FBQ0FBO0lBZEVBLENBQUFBLElBQUFBO0VBeENGcEIsR0FBTyxJQUFQQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzcyNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6U2lnbmFsXG4gIGRlZiBzZWxmLnRyYXAoKilcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpHQ1xuICBkZWYgc2VsZi5zdGFydFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6U2lnbmFsPiIsInRyYXAiLCJzZWxmIiwiPGNsYXNzOkdDPiIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7O0VBQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUMsTUFBSUMsSUFBSkQsV0FBQUEsZ0JBREYsRUFDRUE7QUFBQUEsTUFBQUE7OztNQURGO01BQ2dCO01BRGhCQSxPQUFBO0lBQ0VBLENBQUFBLElBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFLQUQsT0FBQUk7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJRixJQUFKRSxZQUFBQSxZQU5GLEdBTUVBLENBQUFBLEdBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFMQUo7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3NTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxuY2xhc3MgOjpGaWxlIDwgOjpJT1xuICBTZXBhcmF0b3IgPSBTRVBBUkFUT1IgPSAnLydcbiAgQUxUX1NFUEFSQVRPUiA9IG5pbFxuICBQQVRIX1NFUEFSQVRPUiA9ICc6J1xuICAjIEFzc3VtaW5nIGNhc2UgaW5zZW5zdGl2ZSBmaWxlc3lzdGVtXG4gIEZOTV9TWVNDQVNFID0gMFxuICB3aW5kb3dzX3Jvb3RfcnggPSAlcnteW2EtekEtWl06KD86XFxcXHxcXC8pfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxuICAgICAgc2VwID0gU0VQQVJBVE9SXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmV3X3BhcnRzID0gW11cblxuICAgICAgcGF0aCA9IHBhdGgucmVzcG9uZF90bz8oOnRvX3BhdGgpID8gcGF0aC50b19wYXRoIDogcGF0aFxuICAgICAgcGF0aCA9IDo6T3BhbC5jb2VyY2VfdG8hKGBwYXRoYCwgOjpTdHJpbmcsIDp0b19zdHIpXG5cbiAgICAgIGJhc2VkaXIgfHw9IDo6RGlyLnB3ZFxuICAgICAgcGF0aF9hYnMgICAgPSBgcGF0aC5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKWBcbiAgICAgIGJhc2VkaXJfYWJzID0gYGJhc2VkaXIuc3Vic3RyKDAsIHNlcC5sZW5ndGgpID09PSBzZXAgfHwgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcilgXG5cbiAgICAgIGlmIHBhdGhfYWJzXG4gICAgICAgIHBhcnRzICAgICAgID0gcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKSA/ICcnIDogI3twYXRoLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnRzICAgICAgID0gYmFzZWRpci5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKSArIHBhdGguc3BsaXQoL1sje3NlcF9jaGFyc31dLylcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcikgPyAnJyA6ICN7YmFzZWRpci5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIGFicyAgICAgICAgID0gYmFzZWRpcl9hYnNcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIHBhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocGFydCA9PT0gbmlsKSB8fFxuICAgICAgICAgICAgKHBhcnQgPT09ICcnICAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJy4nICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmV3X3BhcnRzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFicyAmJiBwYXJ0c1swXSAhPT0gJy4nKSB7XG4gICAgICAgICAgI3tuZXdfcGFydHMudW5zaGlmdCAnLid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3X3BhdGggPSBuZXdfcGFydHMuam9pbihzZXApXG4gICAgICBuZXdfcGF0aCA9IGxlYWRpbmdfc2VwICsgbmV3X3BhdGggaWYgYWJzXG4gICAgICBuZXdfcGF0aFxuICAgIGVuZFxuXG4gICAgZGVmIGV4cGFuZF9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBpZiBgcGF0aFswXSA9PT0gJ34nIHx8IChiYXNlZGlyICYmIGJhc2VkaXJbMF0gPT09ICd+JylgXG4gICAgICAgIGhvbWUgPSBEaXIuaG9tZVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoaG9tZSkgPyAnJyA6ICN7aG9tZS5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vbi1hYnNvbHV0ZSBob21lJykgdW5sZXNzIGhvbWUuc3RhcnRfd2l0aD8obGVhZGluZ19zZXApXG5cbiAgICAgICAgaG9tZSAgICAgICAgICAgICs9IHNlcFxuICAgICAgICBob21lX3BhdGhfcmVnZXhwID0gL15cXH4oPzoje3NlcH18JCkvXG4gICAgICAgIHBhdGggICAgICAgICAgICAgPSBwYXRoLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKVxuICAgICAgICBiYXNlZGlyICAgICAgICAgID0gYmFzZWRpci5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSkgaWYgYmFzZWRpclxuICAgICAgZW5kXG4gICAgICBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIpXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIC8vIENvZXJjZSBhIGdpdmVuIHBhdGggdG8gYSBwYXRoIHN0cmluZyB1c2luZyAjdG9fcGF0aCBhbmQgI3RvX3N0clxuICAgICAgZnVuY3Rpb24gJGNvZXJjZV90b19wYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCR0cnV0aHkoI3tgcGF0aGAucmVzcG9uZF90bz8oOnRvX3BhdGgpfSkpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aC4kdG9fcGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHBhdGhgLCA6OlN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSBSZWdFeHAgY29tcGF0aWJsZSBjaGFyIGNsYXNzXG4gICAgICBmdW5jdGlvbiAkc2VwX2NoYXJzKCkge1xuICAgICAgICBpZiAoI3tBTFRfU0VQQVJBVE9SfSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1IgKyBBTFRfU0VQQVJBVE9SfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYgZGlybmFtZShwYXRoLCBsZXZlbCA9IDEpXG4gICAgICByZXR1cm4gcGF0aCBpZiBsZXZlbCA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibGV2ZWwgY2FuJ3QgYmUgbmVnYXRpdmVcIiBpZiBsZXZlbCA8IDBcblxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIHBhdGggPSBgJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhYnNvbHV0ZSA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgje1wiXlsje3NlcF9jaGFyc31dXCJ9KSksIG91dDtcblxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3JzXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiW14je3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBiYXNlbmFtZVxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSBmaW5hbCB0cmFpbGluZyBzZXBhcmF0b3JzXG5cbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgb3V0ID0gYWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb3V0ID0gcGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gI3tkaXJuYW1lKGBvdXRgLCBsZXZlbCAtIDEpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZW5hbWUobmFtZSwgc3VmZml4ID0gbmlsKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIG5hbWUgPSBgJGNvZXJjZV90b19wYXRoKG5hbWUpYFxuICAgICAgJXh7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VmZml4ICE9PSBuaWwpIHtcbiAgICAgICAgICBzdWZmaXggPSAjezo6T3BhbC5jb2VyY2VfdG8hKHN1ZmZpeCwgOjpTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiguKVsje3NlcF9jaGFyc31dKiRcIn0pLCAnJDEnKTtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJeKD86LipbI3tzZXBfY2hhcnN9XSk/KFteI3tzZXBfY2hhcnN9XSspJFwifSksICckMScpO1xuXG4gICAgICAgIGlmIChzdWZmaXggPT09IFwiLipcIikge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLlteXFwuXSskLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYoc3VmZml4ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VmZml4ID0gT3BhbC5lc2NhcGVfcmVnZXhwKHN1ZmZpeCk7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIje3N1ZmZpeH0kXCJ9KSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgZXh0bmFtZShwYXRoKVxuICAgICAgYHBhdGggPSAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpXG4gICAgICByZXR1cm4gJycgaWYgZmlsZW5hbWUuZW1wdHk/XG4gICAgICBsYXN0X2RvdF9pZHggPSBmaWxlbmFtZVsxLi4tMV0ucmluZGV4KCcuJylcbiAgICAgICMgZXh0ZW5zaW9uIG5hbWUgbXVzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC4oc29tZXRoaW5nKVxuICAgICAgbGFzdF9kb3RfaWR4Lm5pbD8gfHwgbGFzdF9kb3RfaWR4ICsgMSA9PSBmaWxlbmFtZS5sZW5ndGggLSAxID8gJycgOiBmaWxlbmFtZVsobGFzdF9kb3RfaWR4ICsgMSkuLi0xXVxuICAgIGVuZFxuXG4gICAgZGVmIGV4aXN0PyhwYXRoKVxuICAgICAgYE9wYWwubW9kdWxlc1sje3BhdGh9XSAhPSBudWxsYFxuICAgIGVuZFxuXG4gICAgZGVmIGRpcmVjdG9yeT8ocGF0aClcbiAgICAgIGZpbGVzID0gW11cbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgICAgI3tmaWxlc30ucHVzaChrZXkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoLmdzdWIoLyheLiN7U0VQQVJBVE9SfSt8I3tTRVBBUkFUT1J9KyQpLylcbiAgICAgIGZpbGUgPSBmaWxlcy5maW5kIHsgfGZ8IGYgPX4gL14je3BhdGh9LyB9XG4gICAgICBmaWxlXG4gICAgZW5kXG5cbiAgICBkZWYgam9pbigqcGF0aHMpXG4gICAgICBpZiBwYXRocy5lbXB0eT9cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdCA9ICcnXG4gICAgICBwYXRocyA9IHBhdGhzLmZsYXR0ZW4uZWFjaF93aXRoX2luZGV4Lm1hcCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIGlmIGluZGV4ID09IDAgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzaWYgcGF0aHMubGVuZ3RoID09IGluZGV4ICsgMSAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaXRlbVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcGF0aHMgPSBwYXRocy5yZWplY3QoJjplbXB0eT8pXG4gICAgICBwYXRocy5lYWNoX3dpdGhfaW5kZXggZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBuZXh0X2l0ZW0gPSBwYXRoc1tpbmRleCArIDFdXG4gICAgICAgIGlmIG5leHRfaXRlbS5uaWw/XG4gICAgICAgICAgcmVzdWx0ID0gXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgJiYgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnN1YigvI3tTRVBBUkFUT1J9KyQvLCAnJylcbiAgICAgICAgICBlbmRcbiAgICAgICAgICByZXN1bHQgPSBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpIHx8IG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfSN7U0VQQVJBVE9SfVwiXG4gICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXN1bHRcbiAgICBlbmRcblxuICAgIGRlZiBzcGxpdChwYXRoKVxuICAgICAgcGF0aC5zcGxpdChTRVBBUkFUT1IpXG4gICAgZW5kXG5cbiAgICBhbGlhcyByZWFscGF0aCBleHBhbmRfcGF0aFxuICAgIGFsaWFzIGV4aXN0cz8gZXhpc3Q/XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpGaWxlPiIsIjAiLCJ3aW5kb3dzX3Jvb3RfcngiLCJhYnNvbHV0ZV9wYXRoIiwicGF0aCIsImJhc2VkaXIiLCJzZXAiLCJTRVBBUkFUT1IiLCJzZXBfY2hhcnMiLCJuZXdfcGFydHMiLCJyZXNwb25kX3RvPyIsInRvX3BhdGgiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsIiRyZXRfb3JfMSIsIkRpciIsInB3ZCIsInBhdGhfYWJzIiwiYmFzZWRpcl9hYnMiLCJwYXJ0cyIsInNwbGl0IiwibGVhZGluZ19zZXAiLCJzdWIiLCJhYnMiLCIrIiwidW5zaGlmdCIsIm5ld19wYXRoIiwiam9pbiIsImV4cGFuZF9wYXRoIiwiaG9tZSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInN0YXJ0X3dpdGg/IiwiaG9tZV9wYXRoX3JlZ2V4cCIsInNlbGYiLCJBTFRfU0VQQVJBVE9SIiwiZGlybmFtZSIsImxldmVsIiwiMSIsIjwiLCItIiwiYmFzZW5hbWUiLCJuYW1lIiwic3VmZml4IiwiZXh0bmFtZSIsImZpbGVuYW1lIiwiZW1wdHk/IiwibGFzdF9kb3RfaWR4IiwiW10iLCItMSIsInJpbmRleCIsIm5pbD8iLCJsZW5ndGgiLCJleGlzdD8iLCJkaXJlY3Rvcnk/IiwiZmlsZXMiLCJnc3ViIiwiZmlsZSIsImZpbmQiLCJibG9jayBpbiBkaXJlY3Rvcnk/IiwiZiIsImJsb2NrICgyIGxldmVscykgaW4gZGlyZWN0b3J5PyIsIj1+IiwicGF0aHMiLCJyZXN1bHQiLCJtYXAiLCJmbGF0dGVuIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gam9pbiIsIml0ZW0iLCJpbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gam9pbiIsInJlamVjdCIsInRvX3Byb2MiLCJu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QUFNLElBQU5BLEVBQWU4RSxTQUFmOUU7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Rpci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OkRpclxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGNoZGlyKGRpcilcbiAgICAgIHByZXZfY3dkID0gYE9wYWwuY3VycmVudF9kaXJgXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7ZGlyfWBcbiAgICAgIHlpZWxkXG4gICAgZW5zdXJlXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7cHJldl9jd2R9YFxuICAgIGVuZFxuXG4gICAgZGVmIHB3ZFxuICAgICAgYE9wYWwuY3VycmVudF9kaXIgfHwgJy4nYFxuICAgIGVuZFxuXG4gICAgZGVmIGhvbWVcbiAgICAgIDo6RU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG5cbiAgICBhbGlhcyBnZXR3ZCBwd2RcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkRpcj4iLCJjaGRpciIsImRpciIsInByZXZfY3dkIiwicHdkIiwiaG9tZSIsIiRyZXRfb3JfMSIsIkVOViIsIltdIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLDhCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQTs7OztBQUNFQyxNQUFBQSxxQkFBQUEsaUJBQVVDLEdBQVZEO0FBQUFBLFFBQUFBOztRQUFBQTtRQUNFQSxPQUFBLGNBQUE7O1FBQUFFLFdBQVlGO1FBQ1hBLG1CQUFxQkM7UUFDdEIsT0FBQSxxQkFBQSxFQUFBO1FBRkE7VUFJQ0QsbUJBQXFCRTtRQUp0QixDQUFBO01BREZGLENBQUFBLEdBQUFBOztBQVFBRyxNQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUE7UUFDRUEsT0FBQ0EsdUJBQURBO01BREZBLENBQUFBLEdBQUFBOztBQUlBQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBQUMsQ0FBQUEsWUFBQUMsVUFBS0MsT0FBQUEsQ0FBQ0gsTUFBREcsQ0FBTEYsQ0FBQSxDQUFBO1VBQUFELE9BQUE7UUFBQTtVQUFpQkEsT0FBQUE7UUFBakI7TUFERkEsQ0FBQUEsR0FBQUE7TUFJQSxPQUFBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFqQkYsNEJBQVNJLElBQVQ7RUFERlQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA3NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RydWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgOjpTdHJ1Y3RcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICBkZWYgc2VsZi5uZXcoY29uc3RfbmFtZSwgKmFyZ3MsIGtleXdvcmRfaW5pdDogZmFsc2UsICZibG9jaylcbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBpZiBjb25zdF9uYW1lLmNsYXNzID09IDo6U3RyaW5nICYmIGNvbnN0X25hbWVbMF0udXBjYXNlICE9IGNvbnN0X25hbWVbMF1cbiAgICAgICAgIyBGYXN0IHRyYWNrIHNvIHRoYXQgd2Ugc2tpcCBuZWVkbGVzc2x5IGdvaW5nIHRocnUgZXhjZXB0aW9uc1xuICAgICAgICAjIGluIG1vc3QgY2FzZXMuXG4gICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICBjb25zdF9uYW1lID0gbmlsXG4gICAgICBlbHNlXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgY29uc3RfbmFtZSA9IDo6T3BhbC5jb25zdF9uYW1lIShjb25zdF9uYW1lKVxuICAgICAgICByZXNjdWUgOjpUeXBlRXJyb3IsIDo6TmFtZUVycm9yXG4gICAgICAgICAgYXJncy51bnNoaWZ0KGNvbnN0X25hbWUpXG4gICAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYXJncy5tYXAgZG8gfGFyZ3xcbiAgICAgIDo6T3BhbC5jb2VyY2VfdG8hKGFyZywgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgZW5kXG5cbiAgICBrbGFzcyA9IDo6Q2xhc3MubmV3KHNlbGYpIGRvXG4gICAgICBhcmdzLmVhY2ggeyB8YXJnfCBkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZShhcmcpIH1cblxuICAgICAgY2xhc3MgPDwgc2VsZlxuICAgICAgICBkZWYgbmV3KCphcmdzKVxuICAgICAgICAgIGluc3RhbmNlID0gYWxsb2NhdGVcbiAgICAgICAgICBgI3tpbnN0YW5jZX0uJCRkYXRhID0ge31gXG4gICAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICBlbmRcblxuICAgICAgICBhbGlhc19tZXRob2QgOltdLCA6bmV3XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGtsYXNzLm1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tcbiAgICBga2xhc3MuJCRrZXl3b3JkX2luaXQgPSBrZXl3b3JkX2luaXRgXG5cbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICA6OlN0cnVjdC5jb25zdF9zZXQoY29uc3RfbmFtZSwga2xhc3MpXG4gICAgZW5kXG5cbiAgICBrbGFzc1xuICBlbmRcblxuICBkZWYgc2VsZi5kZWZpbmVfc3RydWN0X2F0dHJpYnV0ZShuYW1lKVxuICAgIGlmIHNlbGYgPT0gOjpTdHJ1Y3RcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3lvdSBjYW5ub3QgZGVmaW5lIGF0dHJpYnV0ZXMgdG8gdGhlIFN0cnVjdCBjbGFzcydcbiAgICBlbmRcblxuICAgIG1lbWJlcnMgPDwgbmFtZVxuXG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gICAgZW5kXG5cbiAgICBkZWZpbmVfbWV0aG9kIFwiI3tuYW1lfT1cIiBkbyB8dmFsdWV8XG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV0gPSB2YWx1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubWVtYmVyc1xuICAgIGlmIHNlbGYgPT0gOjpTdHJ1Y3RcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RoZSBTdHJ1Y3QgY2xhc3MgaGFzIG5vIG1lbWJlcnMnXG4gICAgZW5kXG5cbiAgICBAbWVtYmVycyB8fD0gW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgIG1lbWJlcnMgPSBAbWVtYmVyc1xuXG4gICAga2xhc3MuaW5zdGFuY2VfZXZhbCBkb1xuICAgICAgQG1lbWJlcnMgPSBtZW1iZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIGlmIGAje3NlbGYuY2xhc3N9LiQka2V5d29yZF9pbml0YFxuICAgICAga3dhcmdzID0gYXJncy5sYXN0IHx8IHt9XG5cbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gMSB8fCBgKGFyZ3MubGVuZ3RoID09PSAxICYmICFrd2FyZ3MuJCRpc19oYXNoKWBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICN7YXJncy5sZW5ndGh9LCBleHBlY3RlZCAwKVwiXG4gICAgICBlbmRcblxuICAgICAgZXh0cmEgPSBrd2FyZ3Mua2V5cyAtIHNlbGYuY2xhc3MubWVtYmVyc1xuICAgICAgaWYgZXh0cmEuYW55P1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBrZXl3b3JkczogI3tleHRyYS5qb2luKCcsICcpfVwiXG4gICAgICBlbmRcblxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggZG8gfG5hbWV8XG4gICAgICAgIHNlbGZbbmFtZV0gPSBrd2FyZ3NbbmFtZV1cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdzdHJ1Y3Qgc2l6ZSBkaWZmZXJzJ1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoX3dpdGhfaW5kZXggZG8gfG5hbWUsIGluZGV4fFxuICAgICAgICBzZWxmW25hbWVdID0gYXJnc1tpbmRleF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KGZyb20pXG4gICAgJXh7XG4gICAgICBzZWxmLiQkZGF0YSA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20uJCRkYXRhKSwgaSwgbWF4LCBuYW1lO1xuICAgICAgZm9yIChpID0gMCwgbWF4ID0ga2V5cy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgc2VsZi4kJGRhdGFbbmFtZV0gPSBmcm9tLiQkZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmtleXdvcmRfaW5pdD9cbiAgICBgc2VsZi4kJGtleXdvcmRfaW5pdGBcbiAgZW5kXG5cbiAgZGVmIG1lbWJlcnNcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBIYXNoLm5ldyhgc2VsZi4kJGRhdGFgKS5oYXNoXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gbmFtZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgOjpTdHJpbmcgPT09IG5hbWVcbiAgICAgICV4e1xuICAgICAgICBpZighc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gbmFtZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgOjpTdHJpbmcgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpIHVubGVzcyBzZWxmLmNsYXNzLm1lbWJlcnMuaW5jbHVkZT8obmFtZS50b19zeW0pXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3s6OlN0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3s6OlN0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaFxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgc2VsZltuYW1lXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9wYWlyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3BhaXIpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIFtuYW1lLCBzZWxmW25hbWVdXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5tYXAgeyB8bmFtZXwgc2VsZltuYW1lXSB9XG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gJyM8c3RydWN0ICdcblxuICAgIGlmIGBpbnNwZWN0X3N0YWNrYC5pbmNsdWRlPyBfX2lkX19cbiAgICAgIHJlc3VsdCArICc6Li4uPidcbiAgICBlbHNlXG4gICAgICBgaW5zcGVjdF9zdGFja2AgPDwgX19pZF9fXG4gICAgICBwdXNoZWQgPSB0cnVlXG5cbiAgICAgIGlmIDo6U3RydWN0ID09PSBzZWxmICYmIHNlbGYuY2xhc3MubmFtZVxuICAgICAgICByZXN1bHQgKz0gXCIje3NlbGYuY2xhc3N9IFwiXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0ICs9IGVhY2hfcGFpci5tYXAgZG8gfG5hbWUsIHZhbHVlfFxuICAgICAgICBcIiN7bmFtZX09I3tPcGFsLmluc3BlY3QodmFsdWUpfVwiXG4gICAgICBlbmQuam9pbiAnLCAnXG5cbiAgICAgIHJlc3VsdCArPSAnPidcblxuICAgICAgcmVzdWx0XG4gICAgZW5kXG4gIGVuc3VyZVxuICAgIGBpbnNwZWN0X3N0YWNrLnBvcCgpYCBpZiBwdXNoZWRcbiAgZW5kXG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoX3dpdGhfb2JqZWN0KHt9KSB7IHxuYW1lLCBofCBoW25hbWVdID0gc2VsZltuYW1lXSB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgYXJncyA9IGFyZ3MubWFwIHsgfGFyZ3wgYGFyZy4kJGlzX3JhbmdlID8gI3thcmcudG9fYX0gOiBhcmdgIH0uZmxhdHRlblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFhcmdzW2ldLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7YGFyZ3NbaV1gLmNsYXNzfSBpbnRvIEludGVnZXJcIn1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCgje3NlbGZbYGFyZ3NbaV1gXX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gaWYgYGtleS4kJGlzX3N0cmluZyAmJiBzZWxmLiQkZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpYFxuICAgICAgICAgICAgIGBzZWxmLiQkZGF0YVtrZXldIHx8IG5pbGBcbiAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHZhbHVlcyB0b19hXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6U3RydWN0PiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwibmV3IiwiY29uc3RfbmFtZSIsImNsYXNzIiwiU3RyaW5nIiwiW10iLCIwIiwidXBjYXNlIiwiYXJncyIsInVuc2hpZnQiLCJPcGFsIiwiY29uc3RfbmFtZSEiLCJUeXBlRXJyb3IiLCJOYW1lRXJyb3IiLCJtYXAiLCJibG9jayBpbiBuZXciLCJhcmciLCJibG9jayAoMiBsZXZlbHMpIGluIG5ldyIsImNvZXJjZV90byEiLCJrbGFzcyIsIkNsYXNzIiwiZWFjaCIsImJsb2NrICgzIGxldmVscykgaW4gbmV3IiwiZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJpbnN0YW5jZSIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImFsaWFzX21ldGhvZCIsImJsb2NrIiwibW9kdWxlX2V2YWwiLCJ0b19wcm9jIiwiU3RydWN0IiwiY29uc3Rfc2V0IiwibmFtZSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIm1lbWJlcnMiLCI8PCIsImRlZmluZV9tZXRob2QiLCJibG9jayBpbiBkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZSIsImJsb2NrICgyIGxldmVscykgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJ2YWx1ZSIsIkBtZW1iZXJzIiwiJHJldF9vcl8xIiwiaW5oZXJpdGVkIiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIGluIGluaGVyaXRlZCIsImJsb2NrICgyIGxldmVscykgaW4gaW5oZXJpdGVkIiwia3dhcmdzIiwibGFzdCIsIj4iLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCItIiwia2V5cyIsImFueT8iLCJqb2luIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImJsb2NrICgyIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsIltdPSIsImVhY2hfd2l0aF9pbmRleCIsImluZGV4IiwiaW5pdGlhbGl6ZV9jb3B5IiwiZnJvbSIsImtleXdvcmRfaW5pdD8iLCJoYXNoIiwiSGFzaCIsIkludGVnZXIiLCI8Iiwic2l6ZSIsIi1AIiwiSW5kZXhFcnJvciIsIj49IiwiaW5jbHVkZT8iLCJ0b19zeW0iLCI9PSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiX19pZF9fIiwiPT09IiwiZXFsPyIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfcGFpciIsImJsb2NrIGluIGVhY2hfcGFpciIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9wYWlyIiwidG9fYSIsImJsb2NrIGluIHRvX2EiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiKyIsInB1c2hlZCIsImJsb2NrIGluIGluc3BlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJ0b19oIiwiZWFjaF93aXRoX29iamVjdCIsImJsb2NrIGluIHRvX2giLCJoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19oIiwidmFsdWVzX2F0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJmbGF0dGVuIiwiZGlnIiwia2V5IiwiaXRlbSIsInJlc3BvbmRfdG8/Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFFQUUsTUFBSUwsSUFBSkssVUFBQUEsdUJBQWFDLFVBQUQsRUFMZCxFQUtjLEVBTGQsRUFLRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFMRjtNQUFBO01BQUE7TUFLMkI7O01BQU8sOENBQUEseUNBQWM7TUFDNUMsSUFBQSxRQUFHQyxVQUFILENBQUE7UUFDRSxJQUFHLENBQUEsTUFBQUEsVUFBVUMsT0FBQUEsQ0FBQUEsQ0FBVixFQUFvQkMsYUFBcEIsQ0FBQSxJQUFBLENBQUEsT0FBZ0NGLFVBQVVHLE9BQUFBLENBQUNDLENBQURELENBQUdFLFFBQUFBLENBQUFBLENBQTdDLEVBQXdETCxVQUFVRyxPQUFBQSxDQUFDQyxDQUFERCxDQUFsRSxDQUFBLENBQUEsQ0FBSDs7VUFHRUcsSUFBSUMsU0FBQUEsQ0FBU1AsVUFBVE87VUFDSlAsYUFBYTtRQUpmOztVQU9JO1lBQUFBLGFBQWFRLEtBQU1DLGdCQUFBQSxDQUFhVCxVQUFiUztVQUFuQjtZQUNGLHNCQUFPLENBQUFDLGdCQUFBLEVBQWFDLGdCQUFiLENBQVA7Y0FBQTs7Z0JBQ0VM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QSxHQUFBOztBQUtYQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJLEtBQUEsUUFBT0UsSUFBSUMsZ0JBQUFBLENBQWEsS0FBYkEsQ0FBWCxDQUFBO1FBQ0U3RSxPQUFRQyxPQUFBQSxDQUFPdkIsZ0JBQWYsRUFBNEIsRUFBQSxHQUFBLENBQUdrRyxJQUFJM0csT0FBQUEsQ0FBQUEsQ0FBUCxDQUFBLEdBQWN5Ryw0QkFBbEN6RTtNQURWO01BSUF5RSxPQUFJQSxNQUFKRSxJQUFJRixPQUFBQSxFQUFLLE1BQUNwRCxJQUFELENBQUxvRDtJQWZOQSxDQUFBQSxJQUFBQTtJQWtCQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxNQUFOLEVBQVcsU0FBWDtJQUNBOUcsT0FBQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0VBeFVGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0NTM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogc2xpY2UsIGRlbnlfZnJvemVuX2FjY2Vzc1xuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIDo6VGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxuXG4gICV4e1xuICAgIHZhciBkYXlzX29mX3dlZWsgPSAjeyV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5IFN1bmRheV19LFxuICAgICAgICBzaG9ydF9kYXlzICAgPSAjeyV3W1N1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdF19LFxuICAgICAgICBzaG9ydF9tb250aHMgPSAjeyV3W0phbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXX0sXG4gICAgICAgIGxvbmdfbW9udGhzICA9ICN7JXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl19O1xuICB9XG5cbiAgZGVmIHNlbGYuYXQoc2Vjb25kcywgZnJhYyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgjezo6VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQudGltZXpvbmUgPSBzZWNvbmRzLnRpbWV6b25lO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgc2Vjb25kcyA9ICN7OjpPcGFsLmNvZXJjZV90byEoc2Vjb25kcywgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFjLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGZyYWMgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGZyYWMsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDAgKyAoZnJhYyAvIDEwMDApKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICBpZiAoeWVhci4kJGlzX3N0cmluZykge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHllYXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoID09PSBuaWwpIHtcbiAgICAgICAgbW9udGggPSAxO1xuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7YG1vbnRoYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICBtb250aCA9ICN7YG1vbnRoYC50b19zdHJ9O1xuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ2phbic6IG1vbnRoID0gIDE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZlYic6IG1vbnRoID0gIDI7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Fwcic6IG1vbnRoID0gIDQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21heSc6IG1vbnRoID0gIDU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bCc6IG1vbnRoID0gIDc7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F1Zyc6IG1vbnRoID0gIDg7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29jdCc6IG1vbnRoID0gMTA7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vdic6IG1vbnRoID0gMTE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IG1vbnRoID0gI3tgbW9udGhgLnRvX2l9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb250aCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG1vbnRoYCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxuICAgICAgfVxuICAgICAgbW9udGggPSBtb250aCAtIDE7XG5cbiAgICAgIGlmIChkYXkgPT09IG5pbCkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgZGF5ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiZGF5IG91dCBvZiByYW5nZTogI3tgZGF5YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPT09IG5pbCkge1xuICAgICAgICBob3VyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG91ciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGhvdXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPCAwIHx8IGhvdXIgPiAyNCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJob3VyIG91dCBvZiByYW5nZTogI3tgaG91cmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IG5pbCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA8IDAgfHwgbWluID4gNTkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWluIG91dCBvZiByYW5nZTogI3tgbWluYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA9PT0gbmlsKSB7XG4gICAgICAgIHNlYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHNlYyA9IHBhcnNlSW50KHNlYywgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHNlY2AsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWMgPCAwIHx8IHNlYyA+IDYwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLm5ldyh5ZWFyID0gdW5kZWZpbmVkLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgdXRjX29mZnNldCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQsIHRpbWV6b25lLCB1dGNfZGF0ZTtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIGlmICh1dGNfb2Zmc2V0ID09PSBuaWwpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdGltZXpvbmUgPSAje19wYXJzZV9vZmZzZXQodXRjX29mZnNldCl9O1xuICAgICAgdXRjX2RhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHV0Y19kYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh1dGNfZGF0ZS5nZXRUaW1lKCkgLSB0aW1lem9uZSAqIDM2MDAwMDApO1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGltZXpvbmU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBzZWxmLl9wYXJzZV9vZmZzZXQodXRjX29mZnNldClcbiAgICAleHtcbiAgICAgIHZhciB0aW1lem9uZTtcbiAgICAgIGlmICh1dGNfb2Zmc2V0LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmICh1dGNfb2Zmc2V0ID09ICdVVEMnKSB7XG4gICAgICAgICAgdGltZXpvbmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoL15bKy1dXFxkXFxkOlswLTVdXFxkJC8udGVzdCh1dGNfb2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBzaWduLCBob3VycywgbWludXRlcztcbiAgICAgICAgICBzaWduID0gdXRjX29mZnNldFswXTtcbiAgICAgICAgICBob3VycyA9ICsodXRjX29mZnNldFsxXSArIHV0Y19vZmZzZXRbMl0pO1xuICAgICAgICAgIG1pbnV0ZXMgPSArKHV0Y19vZmZzZXRbNF0gKyB1dGNfb2Zmc2V0WzVdKTtcblxuICAgICAgICAgIHRpbWV6b25lID0gKHNpZ24gPT0gJy0nID8gLTEgOiAxKSAqIChob3VycyArIG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gVW5zdXBwb3J0ZWQ6IFwiQVwiLi5cIklcIixcIktcIi4uXCJaXCJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJSdcIitISDpNTVwiLCBcIi1ISDpNTVwiLCBcIlVUQ1wiIGV4cGVjdGVkIGZvciB1dGNfb2Zmc2V0OiAje3V0Y19vZmZzZXR9J31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXRjX29mZnNldC4kJGlzX251bWJlcikge1xuICAgICAgICB0aW1lem9uZSA9IHV0Y19vZmZzZXQgLyAzNjAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIk9wYWwgZG9lc24ndCBzdXBwb3J0IG90aGVyIHR5cGVzIGZvciBhIHRpbWV6b25lIGFyZ3VtZW50IHRoYW4gSW50ZWdlciBhbmQgU3RyaW5nXCJ9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXpvbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCkpO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnRpbWV6b25lID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5ub3dcbiAgICBuZXdcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd0aW1lICsgdGltZT8nXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlbGYudGltZXpvbmU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxuICAgICAgcmV0dXJuIGAoc2VsZi5nZXRUaW1lKCkgLSBvdGhlci5nZXRUaW1lKCkpIC8gMTAwMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7OjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpIC0gKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gc2VsZi50aW1lem9uZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIDo6VGltZSA9PT0gb3RoZXJcbiAgICAgIHRvX2YgPD0+IG90aGVyLnRvX2ZcbiAgICBlbHNlXG4gICAgICByID0gb3RoZXIgPD0+IHNlbGZcbiAgICAgIGlmIHIubmlsP1xuICAgICAgICBuaWxcbiAgICAgIGVsc2lmIHIgPiAwXG4gICAgICAgIC0xXG4gICAgICBlbHNpZiByIDwgMFxuICAgICAgICAxXG4gICAgICBlbHNlXG4gICAgICAgIDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgOjpUaW1lID09PSBvdGhlciAmJiBgI3t0b19mfSA9PT0gI3tvdGhlci50b19mfWBcbiAgZW5kXG5cbiAgZGVmIGFzY3RpbWVcbiAgICBzdHJmdGltZSAnJWEgJWIgJWUgJUg6JU06JVMgJVknXG4gIGVuZFxuXG4gIFtcbiAgICBbOnllYXIsICdnZXRGdWxsWWVhcicsICdnZXRVVENGdWxsWWVhciddLFxuICAgIFs6bW9uLCAnZ2V0TW9udGgnLCAnZ2V0VVRDTW9udGgnLCAxXSxcbiAgICBbOndkYXksICdnZXREYXknLCAnZ2V0VVRDRGF5J10sXG4gICAgWzpkYXksICdnZXREYXRlJywgJ2dldFVUQ0RhdGUnXSxcbiAgICBbOmhvdXIsICdnZXRIb3VycycsICdnZXRVVENIb3VycyddLFxuICAgIFs6bWluLCAnZ2V0TWludXRlcycsICdnZXRVVENNaW51dGVzJ10sXG4gICAgWzpzZWMsICdnZXRTZWNvbmRzJywgJ2dldFVUQ1NlY29uZHMnXSxcbiAgXS5lYWNoIGRvIHxtZXRob2QsIGdldHRlciwgdXRjZ2V0dGVyLCBkaWZmZXJlbmNlID0gMHxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkb1xuICAgICAgJXh7XG4gICAgICAgIHJldHVybiBkaWZmZXJlbmNlICsgKChzZWxmLnRpbWV6b25lICE9IG51bGwpID9cbiAgICAgICAgICAobmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyBzZWxmLnRpbWV6b25lICogMzYwMDAwMCkpW3V0Y2dldHRlcl0oKSA6XG4gICAgICAgICAgc2VsZltnZXR0ZXJdKCkpXG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB5ZGF5XG4gICAgIyBodHRwOi8vamF2YXNjcmlwdC5hYm91dC5jb20vbGlicmFyeS9ibGRheXllYXIuaHRtXG4gICAgIyBhbHNvIHNlZSBtb21lbnQuanMgaW1wbGVtZW50YXRpb246IGh0dHA6Ly9naXQuaW8vdkNLTkVcblxuICAgIHN0YXJ0X29mX3llYXIgPSBUaW1lLm5ldyh5ZWFyKS50b19pXG4gICAgc3RhcnRfb2ZfZGF5ICA9IFRpbWUubmV3KHllYXIsIG1vbnRoLCBkYXkpLnRvX2lcbiAgICBvbmVfZGF5ICAgICAgID0gODZfNDAwXG5cbiAgICAoKHN0YXJ0X29mX2RheSAtIHN0YXJ0X29mX3llYXIpIC8gb25lX2RheSkucm91bmQgKyAxXG4gIGVuZFxuXG4gIGRlZiBpc2RzdFxuICAgICV4e1xuICAgICAgdmFyIGphbiA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgMCwgMSksXG4gICAgICAgICAganVsID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgICAgIHJldHVybiBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpYFxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgb3RoZXIuaXNfYT8oOjpUaW1lKSAmJiAoc2VsZiA8PT4gb3RoZXIpLnplcm8/XG4gIGVuZFxuXG4gIFtcbiAgICBbOnN1bmRheT8sIDBdLFxuICAgIFs6bW9uZGF5PywgMV0sXG4gICAgWzp0dWVzZGF5PywgMl0sXG4gICAgWzp3ZWRuZXNkYXk/LCAzXSxcbiAgICBbOnRodXJzZGF5PywgNF0sXG4gICAgWzpmcmlkYXk/LCA1XSxcbiAgICBbOnNhdHVyZGF5PywgNl1cbiAgXS5lYWNoIGRvIHxtZXRob2QsIHdlZWtkYXl8XG4gICAgZGVmaW5lX21ldGhvZCBtZXRob2QgZG9cbiAgICAgIGAje3dkYXl9ID09PSB3ZWVrZGF5YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGAnVGltZTonICsgc2VsZi5nZXRUaW1lKClgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaWYgdXRjP1xuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTIFVUQydcbiAgICBlbHNlXG4gICAgICBzdHJmdGltZSAnJVktJW0tJWQgJUg6JU06JVMgJXonXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzdWNjXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlbGYudGltZXpvbmU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVzZWNcbiAgICBgc2VsZi5nZXRNaWxsaXNlY29uZHMoKSAqIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB6b25lXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi50aW1lem9uZSA9PT0gMCkgcmV0dXJuIFwiVVRDXCI7XG4gICAgICBlbHNlIGlmIChzZWxmLnRpbWV6b25lICE9IG51bGwpIHJldHVybiBuaWw7XG5cbiAgICAgIHZhciBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1tBLVpdezMsNH0vKVswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1xcKCguKylcXCkoPzpcXHN8JCkvKVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09IFwiR01UXCIgJiYgLyhHTVRcXFcqXFxkezR9KS8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRnbVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdtdGltZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudGltZXpvbmUgIT09IDApIHtcbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgICAgc2VsZi50aW1lem9uZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnbXQ/XG4gICAgYHNlbGYudGltZXpvbmUgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBnbXRfb2Zmc2V0XG4gICAgYChzZWxmLnRpbWV6b25lICE9IG51bGwpID8gc2VsZi50aW1lem9uZSAqIDYwIDogLXNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwYFxuICBlbmRcblxuICBkZWYgc3RyZnRpbWUoZm9ybWF0KVxuICAgICV4e1xuICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lKFtcXC1fI14wXSo6ezAsMn0pKFxcZCspPyhbRU9dKikoLikvZywgZnVuY3Rpb24oZnVsbCwgZmxhZ3MsIHdpZHRoLCBfLCBjb252KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiLCBqZCwgYywgcyxcbiAgICAgICAgICAgIHplcm8gICA9IGZsYWdzLmluZGV4T2YoJzAnKSAhPT0gLTEsXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxuICAgICAgICAgICAgYmxhbmsgID0gZmxhZ3MuaW5kZXhPZignXycpICE9PSAtMSxcbiAgICAgICAgICAgIHVwY2FzZSA9IGZsYWdzLmluZGV4T2YoJ14nKSAhPT0gLTEsXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxuICAgICAgICAgICAgY29sb25zID0gKGZsYWdzLm1hdGNoKCc6JykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKHplcm8gJiYgYmxhbmspIHtcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XG4gICAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbnYpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3llYXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3llYXJ9ICUgMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bW9ufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICByZXN1bHQgKz0gbG9uZ19tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVyb1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3lkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ICUgMTIgfHwgMTIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcInBtXCIgOiBcImFtXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21pbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3NlY31cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyA5IDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tgc2VsZi5nZXRNaWxsaXNlY29uZHMoKS50b1N0cmluZygpYC5yanVzdCgzLCAnMCcpfTtcbiAgICAgICAgICAgIHJlc3VsdCAgPSAje2ByZXN1bHRgLmxqdXN0KGB3aWR0aGAsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHZhciBvZmZzZXQgID0gKHNlbGYudGltZXpvbmUgPT0gbnVsbCkgPyBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgOiAoLXNlbGYudGltZXpvbmUgKiA2MCksXG4gICAgICAgICAgICAgICAgaG91cnMgICA9IE1hdGguZmxvb3IoTWF0aC5hYnMob2Zmc2V0KSAvIDYwKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5hYnMob2Zmc2V0KSAlIDYwO1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gb2Zmc2V0IDwgMCA/IFwiK1wiIDogXCItXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAxKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjowMFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7em9uZX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGRheXNfb2Zfd2Vla1sje3dkYXl9XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gc2hvcnRfZGF5c1sje3dkYXl9XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7d2RheX0gKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t3ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclswXS50b19zLnJqdXN0KDIsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXVstMi4uLTFdfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t0b19pfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCIlXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVhICViICVlICVUICVZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclbS8lZC8leScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJVktJW0tJWQnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVlLSVeYi0lNFknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVJOiVNOiVTICVwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdSJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU06JVMnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIE5vbi1zdGFuZGFyZDogSklTIFggMDMwMSBkYXRlIGZvcm1hdFxuICAgICAgICAgIGNhc2UgJ0onOlxuICAgICAgICAgICAgamQgPSAje3RvX2RhdGUuamR9O1xuICAgICAgICAgICAgaWYgKGpkIDwgMjQwNTE2MCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJVktJW0tJWQnKX07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDE5NjE0KVxuICAgICAgICAgICAgICBjID0gJ00nLCBzID0gMTg2NztcbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQyNDg3NSlcbiAgICAgICAgICAgICAgYyA9ICdUJywgcyA9IDE5MTE7XG4gICAgICAgICAgICBlbHNlIGlmIChqZCA8IDI0NDc1MzUpXG4gICAgICAgICAgICAgIGMgPSAnUycsIHMgPSAxOTI1O1xuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDU4NjA1KVxuICAgICAgICAgICAgICBjID0gJ0gnLCBzID0gMTk4ODtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYyA9ICdSJywgcyA9IDIwMTg7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2Zvcm1hdCAnJWMlMDJkJywgYGNgLCB5ZWFyIC0gYHNgfTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCctJW0tJWQnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGNhc2UpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW0EtWl0vLCBmdW5jdGlvbihjKSB7IGMudG9Mb3dlckNhc2UoKSB9KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvW2Etel0vLCBmdW5jdGlvbihjKSB7IGMudG9VcHBlckNhc2UoKSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWQgJiYgKHplcm8gfHwgYmxhbmspKSB7XG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5yanVzdChgaXNOYU4od2lkdGgpID8gMiA6IHdpZHRoYCwgYGJsYW5rID8gXCIgXCIgOiBcIjBcImApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgW3NlYywgbWluLCBob3VyLCBkYXksIG1vbnRoLCB5ZWFyLCB3ZGF5LCB5ZGF5LCBpc2RzdCwgem9uZV1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBgc2VsZi5nZXRUaW1lKCkgLyAxMDAwYFxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBwYXJzZUludChzZWxmLmdldFRpbWUoKSAvIDEwMDAsIDEwKWBcbiAgZW5kXG5cbiAgZGVmIGN3ZWVrX2N5ZWFyXG4gICAgamFuMDEgPSA6OlRpbWUubmV3KHllYXIsIDEsIDEpXG4gICAgamFuMDFfd2RheSA9IGphbjAxLndkYXlcbiAgICBmaXJzdF9tb25kYXkgPSAwXG4gICAgeWVhciA9IHNlbGYueWVhclxuICAgIGlmIGphbjAxX3dkYXkgPD0gNCAmJiBqYW4wMV93ZGF5ICE9IDBcbiAgICAgICMgSmFuIDAxIGlzIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gMVxuICAgIGVsc2VcbiAgICAgICMgSmFuIDAxIGlzIGluIHRoZSBsYXN0IHdlZWsgb2YgdGhlIHByZXZpb3VzIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSA3IC0gMVxuICAgICAgb2Zmc2V0ID0gLTEgaWYgb2Zmc2V0ID09IC04ICMgQWRqdXN0IGlmIEphbiAwMSBpcyBhIFN1bmRheVxuICAgIGVuZFxuXG4gICAgd2VlayA9ICgoeWRheSArIG9mZnNldCkgLyA3LjAwKS5jZWlsXG5cbiAgICBpZiB3ZWVrIDw9IDBcbiAgICAgICMgR2V0IHRoZSBsYXN0IHdlZWsgb2YgdGhlIHByZXZpb3VzIHllYXJcbiAgICAgIHJldHVybiA6OlRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gOjpUaW1lLm5ldyhzZWxmLnllYXIsIDEyLCAzMSlcbiAgICAgIGRlYzMxX3dkYXkgPSBkZWMzMS53ZGF5XG4gICAgICBpZiBkZWMzMV93ZGF5IDw9IDMgJiYgZGVjMzFfd2RheSAhPSAwXG4gICAgICAgIHdlZWsgPSAxXG4gICAgICAgIHllYXIgKz0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBbd2VlaywgeWVhcl1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIG1rdGltZSBsb2NhbFxuICAgIGFsaWFzIHV0YyBnbVxuICBlbmRcblxuICBhbGlhcyBjdGltZSBhc2N0aW1lXG4gIGFsaWFzIGRzdD8gaXNkc3RcbiAgYWxpYXMgZ2V0dXRjIGdldGdtXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIG1kYXkgZGF5XG4gIGFsaWFzIG1vbnRoIG1vblxuICBhbGlhcyB0b19zIGluc3BlY3RcbiAgYWxpYXMgdHZfc2VjIHRvX2lcbiAgYWxpYXMgdHZfdXNlYyB1c2VjXG4gIGFsaWFzIHV0YyBnbXRpbWVcbiAgYWxpYXMgdXRjPyBnbXQ/XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlRpbWU+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJhdCIsInNlY29uZHMiLCJmcmFjIiwiVGltZSIsIj09PSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwiQXJndW1lbnRFcnJvciIsIm5ldyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW4iLCJzZWMiLCJ1dGNfb2Zmc2V0IiwiX3BhcnNlX29mZnNldCIsImxvY2FsIiwibWlsbGlzZWNvbmQiLCJfZHVtbXkxIiwiX2R1bW15MiIsIl9kdW1teTMiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsIiRyZXRfb3JfMSIsImFzY3RpbWUiLCJzdHJmdGltZSIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6VGltZT4iLCJtZXRob2QiLCJnZXR0ZXIiLCJ1dGNnZXR0ZXIiLCJkaWZmZXJlbmNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6VGltZT4iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6VGltZT4iLCJ5ZGF5Iiwic3RhcnRfb2ZfeWVhciIsInN0YXJ0X29mX2RheSIsIm9uZV9kYXkiLCI4NjQwMCIsIi8iLCJyb3VuZCIsImlzZHN0IiwiZHVwIiwiY29weSIsImNvcHlfaW5zdGFuY2VfdmFyaWFibGVzIiwiaW5pdGlhbGl6ZV9kdXAiLCJlcWw/IiwiaXNfYT8iLCJ6ZXJvPyIsIjIiLCIzIiwiNCIsIjUiLCI2Iiwid2Vla2RheSIsIndkYXkiLCJoYXNoIiwiaW5zcGVjdCIsInV0Yz8iLCJzdWNjIiwidXNlYyIsInpvbmUiLCJnZXRnbSIsImdtdGltZSIsImdtdD8iLCJnbXRfb2Zmc2V0IiwiZm9ybWF0IiwibW9uIiwicmp1c3QiLCJsanVzdCIsImN3ZWVrX2N5ZWFyIiwiW10iLCJ0b19zIiwiLTIiLCJ0b19kYXRlIiwiamQiLCJ0b19hIiwiamFuMDEiLCJqYW4wMV93ZGF5IiwiZmlyc3RfbW9uZGF5IiwiPD0iLCJvZmZzZXQiLCI3IiwiLTgiLCJ3ZWVrIiwiY2VpbCIsIjEyIiwiMzEiLCI1MyIsImRlYzMxIiwiZGVjMzFfd2RheSJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFB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QUFOLEVBQVksS0FBWjtJQUNBLGFBQU0sTUFBTixFQUFXLFNBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0lBQ0EsYUFBTSxTQUFOLEVBQWMsTUFBZDtJQUNBLGFBQU0sS0FBTixFQUFVLFFBQVY7SUFDQSxhQUFNLE1BQU4sRUFBVyxNQUFYO0lBQ0FFLE9BQUEsYUFBTSxZQUFOLEVBQWlCLFlBQWpCO0VBN3dCRkEsR0FBTSxJQUFOQSxFQUFnQkgsSUFBaEJHO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1Mzk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wYXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XG5cbm1vZHVsZSA6OkNvbXBhcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcbiAgICAgIGlmIChPcGFsLmlzX2Eod2hhdCwgT3BhbC5JbnRlZ2VyKSkgeyByZXR1cm4gd2hhdDsgfVxuXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKCN7YHdoYXRgIDwgMH0pIHsgcmV0dXJuIC0xOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpIHtcbiAgICAgIHZhciBjbGFzc19uYW1lO1xuICAgICAgI3tcbiAgICAgICAgY2FzZSBgcmhzYFxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIDo6SW50ZWdlciwgOjpGbG9hdFxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiRpbnNwZWN0KClgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kJGNsYXNzYFxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY21wX29yX2ZhaWwobGhzLCByaHMpIHtcbiAgICAgIHZhciBjbXAgPSAje2BsaHNgIDw9PiBgcmhzYH07XG4gICAgICBpZiAoISR0cnV0aHkoY21wKSkgZmFpbF9jb21wYXJpc29uKGxocywgcmhzKTtcbiAgICAgIHJldHVybiBub3JtYWxpemUoY21wKTtcbiAgICB9XG4gIH1cblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIHRydWUgaWYgZXF1YWw/KG90aGVyKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZltcIiQ8PT5cIl0gPT0gT3BhbC5LZXJuZWxbXCIkPD0+XCJdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgaWYgKHNlbGYuJCRjb21wYXJhYmxlKSB7XG4gICAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpID4gMGBcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPj0gMGBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDw9IDBgXG4gIGVuZFxuXG4gIGRlZiBiZXR3ZWVuPyhtaW4sIG1heClcbiAgICByZXR1cm4gZmFsc2UgaWYgc2VsZiA8IG1pblxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmID4gbWF4XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgY2xhbXAobWluLCBtYXggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgYywgZXhjbDtcblxuICAgICAgaWYgKG1heCA9PT0gbmlsKSB7XG4gICAgICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYSBuZXcgUnVieSAyLjcgYmVoYXZpb3VyIHRoYXQgd2UgYXJlIGFibGUgdG9cbiAgICAgICAgLy8gcHJvdmlkZSBhIHNpbmdsZSBSYW5nZSBhcmd1bWVudCBpbnN0ZWFkIG9mIDIgQ29tcGFyYWJsZXMuXG5cbiAgICAgICAgaWYgKCFPcGFsLmlzX2EobWluLCBPcGFsLlJhbmdlKSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21pbi5jbGFzc30gKGV4cGVjdGVkIFJhbmdlKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgZXhjbCA9IG1pbi5leGNsO1xuICAgICAgICBtYXggPSBtaW4uZW5kO1xuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbmlsICYmIGV4Y2wpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBjbGFtcCB3aXRoIGFuIGV4Y2x1c2l2ZSByYW5nZSd9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsICYmIG1heCAhPT0gbmlsICYmIGNtcF9vcl9mYWlsKG1pbiwgbWF4KSA+IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtaW4gYXJndW1lbnQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtaW4pO1xuXG4gICAgICAgIGlmIChjID09IDApIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoYyA8IDApIHJldHVybiBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggIT09IG5pbCkge1xuICAgICAgICBjID0gY21wX29yX2ZhaWwoc2VsZiwgbWF4KTtcblxuICAgICAgICBpZiAoYyA+IDApIHJldHVybiBtYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpDb21wYXJhYmxlPiIsIj4iLCIwIiwiPCIsIiRyZXRfb3JfMSIsIkludGVnZXIiLCJGbG9hdCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImNsYXNzIiwiPD0+IiwiPT0iLCJvdGhlciIsInNlbGYiLCJlcXVhbD8iLCJjbXAiLCI+PSIsIjw9IiwiYmV0d2Vlbj8iLCJtaW4iLCJtYXgiLCJjbGFtcCIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7OztBQUVBQTtBQUNBQTs7QUFFQUEsVUFBbUJDLE9BQU5ELElBQU1DLEVBQUVDLENBQUZELENBQUlEO0FBQ3ZCQSxVQUFtQkcsT0FBTkgsSUFBTUcsRUFBRUQsQ0FBRkMsQ0FBSUg7QUFDdkJBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxNQUVRLENBaEJSLENBQUEsUUFnQmEsR0FoQmIsRUFlUUksQ0FBQUEsWUFBTUosR0FBTkksQ0FmUixDQUFBLElBQUEsQ0FBQSxDQUFBLFFBZ0JrQixJQWhCbEIsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsUUFnQndCLEtBaEJ4QixFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQWdCK0JDLGNBaEIvQixFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsUUFnQjBDQyxZQWhCMUMsRUFBQSxTQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQWdCUSxHQUFBLENBQ0dOLDJCQURILElBQUEsQ0FHR0Esd0JBSEgsQ0FBQTtBQU1SQSxNQUFRTyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFpQ1QsZ0JBQUQsR0FBQSxDQUFpQkEsQ0FBQ0EsR0FBREEsQ0FBS1UsT0FBQUEsQ0FBQUEsQ0FBdEIsQ0FBQSxHQUE2QlYsUUFBN0IsR0FBQSxDQUFzQ0EsVUFBdEMsQ0FBQSxHQUFrREEsU0FBMUVRO0FBQ2hCUjs7QUFFQUE7QUFDQUEsZ0JBQWtCQSxDQUFDQSxHQUFEQSxDQUFNVyxRQUFBQSxDQUFLWCxHQUFMVyxDQUFVWDtBQUNsQ0E7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUVZLElBQUFBLGtCQUFBQSw4QkFBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBZUUsSUFBQUMsV0FBQUEsQ0FBT0YsS0FBUEUsQ0FBZixDQUFBO1FBQUEsT0FBTztNQUFQOztBQUdKSDtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSSxLQUFBLFFBQW9CSSxDQUFBQSxNQUFPRixJQUFLSCxRQUFBQSxDQUFJRSxLQUFKRixDQUFaSyxDQUFwQixDQUFBO1FBQUEsT0FBTztNQUFQO01BRUFKLE9BQUNBLG1CQUFEQTtJQWpCRkEsQ0FBQUEsR0FBQUE7O0FBb0JBWCxJQUFBQSxpQkFBQUEsMkJBQU1ZLEtBQU5aO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSw0QkFBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFnQixJQUFBQSxrQkFBQUEsOEJBQU9KLEtBQVBJO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSw2QkFBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFkLElBQUFBLGlCQUFBQSwyQkFBTVUsS0FBTlY7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDRCQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQWUsSUFBQUEsa0JBQUFBLDhCQUFPTCxLQUFQSztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNkJBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsb0NBQWFDLEdBQUQsRUFBTUMsR0FBbEJGO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFxQmhCLE9BQUxXLElBQUtYLEVBQUVpQixHQUFGakIsQ0FBckI7UUFBQSxPQUFPO01BQVA7TUFDQSxJQUFxQkYsT0FBTGEsSUFBS2IsRUFBRW9CLEdBQUZwQixDQUFyQjtRQUFBLE9BQU87TUFBUDtNQUNBa0IsT0FBQTtJQUhGQSxDQUFBQSxHQUFBQTtJQU1BbkIsT0FBQXNCLHFCQUFBQSxpQkFBVUYsR0FBRCxFQUFNQyxHQUFmQztBQUFBQSxNQUFBQTs7O01BQWUsdUJBQU07O0FBRXZCQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlmLE9BQVFDLE9BQUFBLENBQU9lLGdCQUFmLEVBQTZCRCxzQkFBRCxHQUFBLENBQXVCRixHQUFHVixPQUFBQSxDQUFBQSxDQUExQixDQUFBLEdBQWlDWSxtQkFBckRkO0FBQ3BCYzs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlmLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDYSxzQ0FBeEJkO0FBQ3BCYztBQUNBQTs7QUFFQUE7QUFDQUEsUUFBVWYsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NhLGdEQUF4QmQ7QUFDbEJjOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUF2Q0VBLENBQUFBLElBQUFBO0VBeEVGdEIsR0FBTyxJQUFQQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NTUzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xucmVxdWlyZSAnY29yZWxpYi9yYXRpb25hbC9iYXNlJ1xuXG5jbGFzcyA6OlJhdGlvbmFsIDwgOjpOdW1lcmljXG4gIGRlZiBzZWxmLnJlZHVjZShudW0sIGRlbilcbiAgICBudW0gPSBudW0udG9faVxuICAgIGRlbiA9IGRlbi50b19pXG5cbiAgICBpZiBkZW4gPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICBlbHNpZiBkZW4gPCAwXG4gICAgICBudW0gPSAtbnVtXG4gICAgICBkZW4gPSAtZGVuXG4gICAgZWxzaWYgZGVuID09IDFcbiAgICAgIHJldHVybiBuZXcobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBnY2QgPSBudW0uZ2NkKGRlbilcblxuICAgIG5ldyhudW0gLyBnY2QsIGRlbiAvIGdjZClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29udmVydChudW0sIGRlbilcbiAgICBpZiBudW0ubmlsPyB8fCBkZW4ubmlsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjYW5ub3QgY29udmVydCBuaWwgaW50byBSYXRpb25hbCdcbiAgICBlbmRcblxuICAgIGlmIDo6SW50ZWdlciA9PT0gbnVtICYmIDo6SW50ZWdlciA9PT0gZGVuXG4gICAgICByZXR1cm4gcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgaWYgOjpGbG9hdCA9PT0gbnVtIHx8IDo6U3RyaW5nID09PSBudW0gfHwgOjpDb21wbGV4ID09PSBudW1cbiAgICAgIG51bSA9IG51bS50b19yXG4gICAgZW5kXG5cbiAgICBpZiA6OkZsb2F0ID09PSBkZW4gfHwgOjpTdHJpbmcgPT09IGRlbiB8fCA6OkNvbXBsZXggPT09IGRlblxuICAgICAgZGVuID0gZGVuLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIGRlbi5lcXVhbD8oMSkgJiYgISg6OkludGVnZXIgPT09IG51bSlcbiAgICAgIDo6T3BhbC5jb2VyY2VfdG8hKG51bSwgOjpSYXRpb25hbCwgOnRvX3IpXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBudW0gJiYgOjpOdW1lcmljID09PSBkZW5cbiAgICAgIG51bSAvIGRlblxuICAgIGVsc2VcbiAgICAgIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUobnVtLCBkZW4pXG4gICAgQG51bSA9IG51bVxuICAgIEBkZW4gPSBkZW5cbiAgICBmcmVlemVcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIEBudW1cbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQGRlblxuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIFtvdGhlciwgc2VsZl1cblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBbb3RoZXIudG9fciwgc2VsZl1cblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgW290aGVyLCB0b19mXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgQG51bSA9PSBvdGhlci5udW1lcmF0b3IgJiYgQGRlbiA9PSBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIEBudW0gPT0gb3RoZXIgJiYgQGRlbiA9PSAxXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgPT0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yIDw9PiAwXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgQG51bSAtIEBkZW4gKiBvdGhlciA8PT4gMFxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mIDw9PiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOjw9Piwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yICsgQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gKyBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgKyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtIC0gb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mIC0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSAqIG90aGVyLCBAZGVuKVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mICogb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5udW1lcmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICB0b19mIC8gMC4wXG4gICAgICBlbHNlXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0sIEBkZW4gKiBvdGhlcilcbiAgICAgIGVuZFxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mIC8gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIDo6RmxvYXQ6OklORklOSVRZXG4gICAgICBlbHNpZiBvdGhlciA+IDBcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSoqb3RoZXIsIEBkZW4qKm90aGVyKVxuICAgICAgZWxzaWYgb3RoZXIgPCAwXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBkZW4qKi1vdGhlciwgQG51bSoqLW90aGVyKVxuICAgICAgZWxzZVxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbCgxLCAxKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YqKm90aGVyXG5cbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVsc2lmIG90aGVyLmRlbm9taW5hdG9yID09IDFcbiAgICAgICAgaWYgb3RoZXIgPCAwXG4gICAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQGRlbioqb3RoZXIubnVtZXJhdG9yLmFicywgQG51bSoqb3RoZXIubnVtZXJhdG9yLmFicylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0qKm90aGVyLm51bWVyYXRvciwgQGRlbioqb3RoZXIubnVtZXJhdG9yKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICAgIGVsc2VcbiAgICAgICAgdG9fZioqb3RoZXJcbiAgICAgIGVuZFxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bS5hYnMsIEBkZW4uYWJzKVxuICBlbmRcblxuICBkZWYgY2VpbChwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5jZWlsXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmNlaWwsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGZsb29yKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmZsb29yLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJSYXRpb25hbDoje0BudW19OiN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXBzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0gI3tlcHMuYWJzfSxcbiAgICAgICAgICBhID0gI3tzZWxmIC0gYGVgfSxcbiAgICAgICAgICBiID0gI3tzZWxmICsgYGVgfTtcblxuICAgICAgdmFyIHAwID0gMCxcbiAgICAgICAgICBwMSA9IDEsXG4gICAgICAgICAgcTAgPSAxLFxuICAgICAgICAgIHExID0gMCxcbiAgICAgICAgICBwMiwgcTI7XG5cbiAgICAgIHZhciBjLCBrLCB0O1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjID0gI3tgYWAuY2VpbH07XG5cbiAgICAgICAgaWYgKCN7YGNgIDw9IGBiYH0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGsgID0gYyAtIDE7XG4gICAgICAgIHAyID0gayAqIHAxICsgcDA7XG4gICAgICAgIHEyID0gayAqIHExICsgcTA7XG4gICAgICAgIHQgID0gI3sxIC8gKGBiYCAtIGBrYCl9O1xuICAgICAgICBiICA9ICN7MSAvIChgYWAgLSBga2ApfTtcbiAgICAgICAgYSAgPSB0O1xuXG4gICAgICAgIHAwID0gcDE7XG4gICAgICAgIHEwID0gcTE7XG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHExID0gcTI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBjICogcDEgKyBwMGAsIGBjICogcTEgKyBxMGApfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3VuZChwcmVjaXNpb24gPSAwKVxuICAgIHJldHVybiB3aXRoX3ByZWNpc2lvbig6cm91bmQsIHByZWNpc2lvbikgdW5sZXNzIHByZWNpc2lvbiA9PSAwXG4gICAgcmV0dXJuIDAgaWYgQG51bSA9PSAwXG4gICAgcmV0dXJuIEBudW0gaWYgQGRlbiA9PSAxXG5cbiAgICBudW0gPSBAbnVtLmFicyAqIDIgKyBAZGVuXG4gICAgZGVuID0gQGRlbiAqIDJcblxuICAgIGFwcHJveCA9IChudW0gLyBkZW4pLnRydW5jYXRlXG5cbiAgICBpZiBAbnVtIDwgMFxuICAgICAgLWFwcHJveFxuICAgIGVsc2VcbiAgICAgIGFwcHJveFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW0gLyBAZGVuXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BudW19LyN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgQG51bSA8IDAgPyBjZWlsIDogZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6dHJ1bmNhdGUsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHdpdGhfcHJlY2lzaW9uKG1ldGhvZCwgcHJlY2lzaW9uKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIEludGVnZXInIHVubGVzcyA6OkludGVnZXIgPT09IHByZWNpc2lvblxuXG4gICAgcCA9IDEwKipwcmVjaXNpb25cbiAgICBzID0gc2VsZiAqIHBcblxuICAgIGlmIHByZWNpc2lvbiA8IDFcbiAgICAgIChzLnNlbmQobWV0aG9kKSAvIHApLnRvX2lcbiAgICBlbHNlXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChzLnNlbmQobWV0aG9kKSwgcClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHN0cmluZy50cmltTGVmdCgpLFxuICAgICAgICAgIHJlID0gL15bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoMCwgMSl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZGl2aWRlIC9cbiAgYWxpYXMgcXVvIC9cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpSYXRpb25hbD4iLCJyZWR1Y2UiLCJudW0iLCJkZW4iLCJ0b19pIiwiMCIsIktlcm5lbCIsInJhaXNlIiwiWmVyb0RpdmlzaW9uRXJyb3IiLCI8IiwiLUAiLCIxIiwibmV3IiwiZ2NkIiwiLyIsImNvbnZlcnQiLCJuaWw/IiwiVHlwZUVycm9yIiwiSW50ZWdlciIsIkZsb2F0IiwiU3RyaW5nIiwiQ29tcGxleCIsInRvX3IiLCJlcXVhbD8iLCI9PT0iLCJPcGFsIiwiY29lcmNlX3RvISIsIlJhdGlvbmFsIiwiTnVtZXJpYyIsImluaXRpYWxpemUiLCJAbnVtIiwiQGRlbiIsImZyZWV6ZSIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29lcmNlIiwib3RoZXIiLCIkcmV0X29yXzEiLCJ0b19mIiwiPT0iLCIkcmV0X29yXzIiLCI8PT4iLCItIiwiKiIsIl9fY29lcmNlZF9fIiwiKyIsIioqIiwiRmxvYXQ6OklORklOSVRZIiwiPiIsImFicyIsImNlaWwiLCJwcmVjaXNpb24iLCJ3aXRoX3ByZWNpc2lvbiIsImZsb29yIiwiaGFzaCIsImluc3BlY3QiLCJyYXRpb25hbGl6ZSIsImVwcyIsIkFyZ3VtZW50RXJyb3IiLCI8PSIsInJvdW5kIiwiMiIsImFwcHJveCIsInRydW5jYXRlIiwidG9fcyIsIm1ldGhvZCIsInAiLCIxMCIsInMiLCJzZW5kIiwiZnJvbV9zdHJpbmciLCJzdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBQSxtQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxNQUFJSCxJQUFKRyxhQUFBQSxrQkFBZ0JDLEdBQUQsRUFBTUMsR0FBckJGO0FBQUFBLE1BQUFBOzs7TUFDRUMsTUFBTUEsR0FBR0UsTUFBQUEsQ0FBQUE7TUFDVEQsTUFBTUEsR0FBR0MsTUFBQUEsQ0FBQUE7TUFFVCxJQUFBLE1BQUdELEdBQUgsRUFBVUUsQ0FBVixDQUFBO1FBQ0VDLE9BQVFDLE9BQUFBLENBQU9DLHdCQUFmLEVBQW9DUCxjQUE1Qk07TUFEVixPQUVBLElBQUEsUUFBVUUsT0FBSk4sR0FBSU0sRUFBRUosQ0FBRkksQ0FBVixDQUFBOztRQUNFUCxNQUFPQSxHQUFEUSxPQUFBQSxDQUFBQTtRQUNOUCxNQUFPQSxHQUFETyxPQUFBQSxDQUFBQTtNQUZSLE9BR0EsSUFBQSxNQUFNUCxHQUFOLEVBQWFRLENBQWIsQ0FBQTtRQUNFLE9BQU9iLElBQUFjLEtBQUFBLENBQUlWLEdBQUosRUFBU0MsR0FBVFM7TUFEVDtNQUlBQyxNQUFNWCxHQUFHVyxLQUFBQSxDQUFLVixHQUFMVTtNQUVUWixPQUFBSCxJQUFBYyxLQUFBQSxDQUFRRSxXQUFKWixHQUFJWSxFQUFFRCxHQUFGQyxDQUFSLEVBQW1CQSxXQUFKWCxHQUFJVyxFQUFFRCxHQUFGQyxDQUFuQkY7SUFmRlgsQ0FBQUEsR0FBQUE7SUFrQkFjLE1B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MkM7QUFDbkVBO0FBQ0FBLG1CQUFxQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBK0IzRCxDQUF2QmdCLENBQTBCMkM7QUFDdkRBO0FBQ0FBO0FBQ0FBLGlCQUFtQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBK0IzRCxDQUF2QmdCLENBQTBCMkM7QUFDckRBO0FBQ0FBO0FBQ0FBLGVBQWlCaEUsT0FBUXFCLFVBQUFBLENBQVV0QixDQUFsQixFQUFxQk0sQ0FBYmdCLENBQWdCMkM7QUFDekNBO0FBQ0FBO0lBckNFQSxDQUFBQSxHQUFBQTtJQXdDQSxhQUFNLFFBQU4sRUFBYSxHQUFiO0lBQ0F0RSxPQUFBLGFBQU0sS0FBTixFQUFVLEdBQVY7RUFyWUZBLEdBQU0sSUFBTkEsRUFBbUI0QixjQUFuQjVCO0FBSEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1OTc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYXRpb25hbC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgUmF0aW9uYWwobnVtZXJhdG9yLCBkZW5vbWluYXRvciA9IDEpXG4gICAgOjpSYXRpb25hbC5jb252ZXJ0KG51bWVyYXRvciwgZGVub21pbmF0b3IpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6U3RyaW5nXG4gIGRlZiB0b19yXG4gICAgOjpSYXRpb25hbC5mcm9tX3N0cmluZyhzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCJSYXRpb25hbCIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiMSIsImNvbnZlcnQiLCI8Y2xhc3M6U3RyaW5nPiIsInRvX3IiLCJmcm9tX3N0cmluZyIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSx3Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7OztJQUNFQSxPQUFBQyx3QkFBQUEsb0JBQWFDLFNBQUQsRUFBWUMsV0FBeEJGO0FBQUFBOztNQUF3Qix1Q0FBY0c7TUFDcENILE9BQUFBLGVBQVVJLFNBQUFBLENBQVNILFNBQW5CLEVBQThCQyxXQUFwQkU7SUFEWkosQ0FBQUEsSUFBQUE7RUFERkQsR0FBTyxJQUFQQTtFQU1BRCxPQUFBTztFQUFBQTs7O0lBQ0VBLE9BQUFDLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFOLGVBQVVPLGFBQUFBLENBQWFDLElBQWJEO0lBRFpELENBQUFBLEdBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFOQVA7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYwMDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL251bWVyaWMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xuXG5jbGFzcyA6Ok51bWVyaWNcbiAgaW5jbHVkZSA6OkNvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgWzo6S2VybmVsLkZsb2F0KG90aGVyKSwgOjpLZXJuZWwuRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBOdW1lcmljXCJcbiAgICAgIHdoZW4gOj4sIDo+PSwgOjwsIDo8PSwgOjw9PlxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tvdGhlci5jbGFzc30gZmFpbGVkXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIGVxdWFsPyBvdGhlclxuICAgICAgcmV0dXJuIDBcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgK0BcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIDAgLSBzZWxmXG4gIGVuZFxuXG4gIGRlZiAlKG90aGVyKVxuICAgIHNlbGYgLSBvdGhlciAqIGRpdihvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIHNlbGYgPCAwID8gLXNlbGYgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgc2VsZiAqIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgc2VsZiA8IDAgPyA6Ok1hdGg6OlBJIDogMFxuICBlbmRcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIHRvX3IuZGVub21pbmF0b3JcbiAgZW5kXG5cbiAgZGVmIGRpdihvdGhlcilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIDo6S2VybmVsLkNvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBpbnRlZ2VyP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBub256ZXJvP1xuICAgIHplcm8/ID8gbmlsIDogc2VsZlxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgdG9fci5udW1lcmF0b3JcbiAgZW5kXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8hKHNlbGYsIDo6UmF0aW9uYWwsIDp0b19yKSAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiByZWFsXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVhbD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW3NlbGYsIDBdXG4gIGVuZFxuXG4gIGRlZiByb3VuZChkaWdpdHMgPSB1bmRlZmluZWQpXG4gICAgdG9fZi5yb3VuZChkaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBzdGVwKGxpbWl0ID0gdW5kZWZpbmVkLCBzdGVwID0gdW5kZWZpbmVkLCB0bzogdW5kZWZpbmVkLCBieTogdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG8gaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCAhPT0gdW5kZWZpbmVkICYmIGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdzdGVwIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSB0bztcbiAgICAgIH1cblxuICAgICAgaWYgKGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RlcCA9IGJ5O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IG5pbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3N0ZXAgbXVzdCBiZSBudW1lcmljJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICE9IG51bGwgJiYgI3tzdGVwID09IDB9KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsIHx8IHN0ZXAgPT0gbnVsbCkge1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpZ24gPSAje3N0ZXAgPD0+IDB9O1xuXG4gICAgICAgIGlmIChzaWduID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCIwIGNhbid0IGJlIGNvZXJjZWQgaW50byAje3N0ZXAuY2xhc3N9XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgPT09IG5pbCB8fCBsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgbGltaXQgPSBzaWduID4gMCA/ICN7OjpGbG9hdDo6SU5GSU5JVFl9IDogI3stOjpGbG9hdDo6SU5GSU5JVFl9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3s6Ok9wYWwuY29tcGFyZShzZWxmLCBsaW1pdCl9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXBGbG9hdFNpemUoKSB7XG4gICAgICAgIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IEluZmluaXR5IHx8IHN0ZXAgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKHNlbGYpICsgYWJzKGxpbWl0KSArIGFicyhsaW1pdCAtIHNlbGYpKSAvIGFicyhzdGVwKSAqICN7OjpGbG9hdDo6RVBTSUxPTn07XG5cbiAgICAgICAgICBpZiAoZXJyID09PSBJbmZpbml0eSB8fCBlcnIgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmxvb3IoKGxpbWl0IC0gc2VsZikgLyBzdGVwICsgZXJyKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcFNpemUoKSB7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXBGbG9hdFNpemUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLCBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgbGhzID0gYWJzKHNlbGYgLSBsaW1pdCkgKyAxLFxuICAgICAgICAgICAgICByaHMgPSBhYnMoc3RlcCk7XG5cbiAgICAgICAgICByZXR1cm4gY2VpbChsaHMgLyByaHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICBpZiAoIWxpbWl0IHx8IGxpbWl0LmlzX2E/KDo6TnVtZXJpYykpICYmXG4gICAgICAgICAoIXN0ZXAgfHwgc3RlcC5pc19hPyg6Ok51bWVyaWMpKVxuXG4gICAgICAgIHJldHVybiA6OkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZS5uZXcoXG4gICAgICAgICAgW2xpbWl0LCBzdGVwLCAoJ3RvOiAnIGlmIHRvKSwgKCdieTogJyBpZiBieSldLCBzZWxmXG4gICAgICAgIClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBsaW1pdCwgc3RlcCwgJmBzdGVwU2l6ZWApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgIHZhciBpc0Rlc2MgPSAje3N0ZXAubmVnYXRpdmU/fSxcbiAgICAgICAgICBpc0luZiA9ICN7c3RlcCA9PSAwfSB8fFxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSBJbmZpbml0eSAmJiAhaXNEZXNjKSB8fFxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSAtSW5maW5pdHkgJiYgaXNEZXNjKTtcblxuICAgICAgaWYgKHNlbGYuJCRpc19udW1iZXIgJiYgc3RlcC4kJGlzX251bWJlciAmJiBsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VsZiAlIDEgPT09IDAgJiYgKGlzSW5mIHx8IGxpbWl0ICUgMSA9PT0gMCkgJiYgc3RlcCAlIDEgPT09IDApIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmO1xuXG4gICAgICAgICAgaWYgKGlzSW5mKSB7XG4gICAgICAgICAgICBmb3IgKDs7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZXNjKSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPj0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPD0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiZWdpbiA9ICN7dG9fZn0udmFsdWVPZigpO1xuICAgICAgICAgIHN0ZXAgPSAje3N0ZXAudG9fZn0udmFsdWVPZigpO1xuICAgICAgICAgIGxpbWl0ID0gI3tsaW1pdC50b19mfS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICB2YXIgbiA9IHN0ZXBGbG9hdFNpemUoKTtcblxuICAgICAgICAgIGlmICghaXNGaW5pdGUoc3RlcCkpIHtcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSBibG9jayhiZWdpbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBibG9jayhiZWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+PSAwID8gbGltaXQgPCBkIDogbGltaXQgPiBkKSB7XG4gICAgICAgICAgICAgICAgZCA9IGxpbWl0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJsb2NrKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY291bnRlciA9IHNlbGZcblxuICAgIHdoaWxlIGBpc0Rlc2MgPyAje2NvdW50ZXIgPj0gbGltaXR9IDogI3tjb3VudGVyIDw9IGxpbWl0fWBcbiAgICAgIHlpZWxkIGNvdW50ZXJcbiAgICAgIGNvdW50ZXIgKz0gc3RlcFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fY1xuICAgIDo6S2VybmVsLkNvbXBsZXgoc2VsZiwgMClcbiAgZW5kXG5cbiAgZGVmIHRvX2ludFxuICAgIHRvX2lcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YudHJ1bmNhdGUobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHplcm8/XG4gICAgc2VsZiA9PSAwXG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBzZWxmID4gMFxuICBlbmRcblxuICBkZWYgbmVnYXRpdmU/XG4gICAgc2VsZiA8IDBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgbmlsXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG4gIGFsaWFzIG1vZHVsbyAlXG4gIGFsaWFzIHBoYXNlIGFyZ1xuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6TnVtZXJpYz4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsImNvZXJjZSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiY2xhc3MiLCJLZXJuZWwiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwibWV0aG9kIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiPD0+IiwiZXF1YWw/IiwiMCIsIitAIiwiLUAiLCItIiwiJSIsIioiLCJkaXYiLCJhYnMiLCI8IiwiYWJzMiIsImFuZ2xlIiwiTWF0aDo6UEkiLCJNYXRoIiwiY2VpbCIsIm5kaWdpdHMiLCJ0b19mIiwiY29uaiIsImRlbm9taW5hdG9yIiwidG9fciIsIlplcm9EaXZpc2lvbkVycm9yIiwiLyIsImZsb29yIiwiZGl2bW9kIiwiZmRpdiIsImkiLCJDb21wbGV4IiwiaW1hZyIsImludGVnZXI/Iiwibm9uemVybz8iLCJ6ZXJvPyIsIm51bWVyYXRvciIsInBvbGFyIiwiYXJnIiwicXVvIiwiT3BhbCIsImNvZXJjZV90byEiLCJSYXRpb25hbCIsInJlYWwiLCJyZWFsPyIsInJlY3QiLCJyb3VuZCIsImRpZ2l0cyIsInN0ZXAiLCI9PSIsIkZsb2F0OjpJTkZJTklUWSIsImNvbXBhcmUiLCJsaW1pdCIsIkZsb2F0OjpFUFNJTE9OIiwiYmxvY2tfZ2l2ZW4/IiwiaXNfYT8iLCJOdW1lcmljIiwiRW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlIiwiRW51bWVyYXRvciIsIm5ldyIsInRvIiwiYnkiLCJlbnVtX2ZvciIsInRvX3Byb2MiLCJuZWdhdGl2ZT8iLCJjb3VudGVyIiwiPj0iLCI8PSIsIisiLCJ0b19jIiwidG9faW50IiwidG9faSIsInRydW5jYXRlIiwicG9zaXRpdmU/IiwiPiIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOzs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFFQUUsSUFBQUEsc0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFHQyxLQUFLQyxpQkFBQUEsQ0FBY1AsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBbEJELENBQVIsQ0FBQTtRQUNFLE9BQU8sQ0FBQ0QsS0FBRCxFQUFRTixJQUFSO01BRFQ7TUFJQUssT0FBQSxDQUFDSSxPQUFRQyxPQUFBQSxDQUFPSixLQUFQSSxDQUFULEVBQXdCRCxPQUFRQyxPQUFBQSxDQUFPVixJQUFQVSxDQUFoQztJQUxGTCxDQUFBQSxHQUFBQTs7QUFRQU0sSUFBQUEsMkJBQUFBLHVCQUFnQkMsTUFBRCxFQUFTTixLQUF4Qks7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFHTCxLQUFLTyxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFSLENBQUE7O1FBQ0UsS0FBT1AsS0FBS0QsUUFBQUEsQ0FBUUwsSUFBUkssQ0FBWixrQkFBQSxFQUFBUyxDQUFBQSxJQUFBLDZCQUFBQSxDQUFBLEVBQUdDLENBQUFBLElBQUgsNkJBQUdBLENBQUg7UUFDQUosT0FBQUcsQ0FBQ0UsVUFBQUEsQ0FBVUosTUFBWCxFQUFtQkcsQ0FBbEJDO01BRkg7TUFLRSxRQURLSixNQUNMO1FBQUEsS0FBSyxHQUFMO1FBQUEsS0FBUyxHQUFUO1FBQUEsS0FBYSxHQUFiO1FBQUEsS0FBaUIsR0FBakI7UUFBQSxLQUFxQixHQUFyQjtRQUFBLEtBQXlCLEdBQXpCO1FBQUEsS0FBNkIsR0FBN0I7UUFBQSxLQUFpQyxHQUFqQztRQUFBLEtBQXFDLElBQXJDO1VBQ0VELE9BQUFGLE9BQVFRLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCLEVBQUEsR0FBQSxDQUFHWixLQUFLRSxPQUFBQSxDQUFBQSxDQUFSLENBQUEsR0FBZUcsZ0NBQW5DTTtRQUNWLEtBQUssR0FBTDtRQUFBLEtBQVMsSUFBVDtRQUFBLEtBQWMsR0FBZDtRQUFBLEtBQWtCLElBQWxCO1FBQUEsS0FBdUIsS0FBdkI7VUFDRU4sT0FBQUYsT0FBUVEsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBaUNSLGdCQUFELEdBQUEsQ0FBaUJYLElBQUlRLE9BQUFBLENBQUFBLENBQXJCLENBQUEsR0FBNEJHLFFBQTVCLEdBQUEsQ0FBb0NMLEtBQUtFLE9BQUFBLENBQUFBLENBQXpDLENBQUEsR0FBZ0RHLFNBQXhFTTtRQURWO1VBSEFOLE9BQUE7TUFDQTtJQU5KQSxDQUFBQSxHQUFBQTs7QUFjQVMsSUFBQUEsbUJBQUFBLDhCQUFRZCxLQUFSYztBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFHcEIsSUFBQXFCLFdBQUFBLENBQU9mLEtBQVBlLENBQUgsQ0FBQTtRQUNFLE9BQU9DO01BRFQ7TUFJQUYsT0FBQTtJQUxGQSxDQUFBQSxHQUFBQTs7QUFRQUcsSUFBQUEsa0JBQUFBLFlBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxrQkFBQUEsNEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFFQyxVQUFGSCxDQUFFRyxFQUFFekIsSUFBRnlCO0lBREpELENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxpQkFBQUEsNkJBQU1wQixLQUFOb0I7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUtELFVBQUx6QixJQUFLeUIsRUFBUUUsVUFBTnJCLEtBQU1xQixFQUFFM0IsSUFBQTRCLEtBQUFBLENBQUl0QixLQUFKc0IsQ0FBRkQsQ0FBUkY7SUFEUEMsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFLQyxPQUFMOUIsSUFBSzhCLEVBQUVSLENBQUZRLENBQUw7UUFBV0QsT0FBQzdCLElBQUR3QixPQUFBQSxDQUFBQTtNQUFYO1FBQW1CSyxPQUFBN0I7TUFBbkI7SUFERjZCLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLSixVQUFMM0IsSUFBSzJCLEVBQUUzQixJQUFGMkI7SUFEUEksQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBS0YsT0FBTDlCLElBQUs4QixFQUFFUixDQUFGUSxDQUFMO1FBQVdFLE9BQUFDLElBQUFDLFdBQUFEO01BQVg7UUFBd0JELE9BQUFWO01BQXhCO0lBREZVLENBQUFBLEdBQUFBOztBQUlBRyxJQUFBQSxvQkFBQUEsZ0JBQVNDLE9BQVREO0FBQUFBLE1BQUFBOzs7TUFBUywrQkFBVWI7TUFDakJhLE9BQUFuQyxJQUFBcUMsTUFBQUEsQ0FBQUEsQ0FBSUYsTUFBQUEsQ0FBTUMsT0FBTkQ7SUFETkEsQ0FBQUEsSUFBQUE7O0FBSUFHLElBQUFBLG9CQUFBQSxZQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsMkJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXZDLElBQUF3QyxNQUFBQSxDQUFBQSxDQUFJRCxhQUFBQSxDQUFBQTtJQUROQSxDQUFBQSxHQUFBQTs7QUFJQVgsSUFBQUEsbUJBQUFBLGVBQVF0QixLQUFSc0I7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsTUFBc0R0QixLQUF0RCxFQUErRGdCLENBQS9ELENBQUE7UUFBQWIsT0FBUVEsT0FBQUEsQ0FBT3dCLHdCQUFmLEVBQW9DYixjQUE1Qlg7TUFBUjtNQUVBVyxPQUFNYyxXQUFMMUMsSUFBSzBDLEVBQUVwQyxLQUFGb0MsQ0FBUUMsT0FBQUEsQ0FBQUE7SUFIaEJmLENBQUFBLEdBQUFBOztBQU1BZ0IsSUFBQUEsc0JBQUFBLGtCQUFXdEMsS0FBWHNDO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUM1QyxJQUFBNEIsS0FBQUEsQ0FBSXRCLEtBQUpzQixDQUFELEVBQWE1QixJQUFLMEIsTUFBQUEsQ0FBRXBCLEtBQUZvQixDQUFsQjtJQURGa0IsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBU3ZDLEtBQVR1QztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0gsV0FBTDFDLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFLSyxFQUFFcEMsS0FBRm9DO0lBRFBHLENBQUFBLEdBQUFBOztBQUlBRixJQUFBQSxxQkFBQUEsaUJBQVVQLE9BQVZPO0FBQUFBLE1BQUFBOzs7TUFBVSwrQkFBVXJCO01BQ2xCcUIsT0FBQTNDLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFJTSxPQUFBQSxDQUFPUCxPQUFQTztJQUROQSxDQUFBQSxJQUFBQTs7QUFJQUcsSUFBQUEsaUJBQUFBLGFBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBckMsT0FBUXNDLFNBQUFBLENBQVN6QixDQUFqQixFQUFvQnRCLElBQVorQztJQURWRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsb0JBQUFBLFlBQ0UxQixDQURGMEIsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxZQUNFLEtBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsaUNBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBQWxELElBQUFtRCxVQUFBQSxDQUFBQSxDQUFBLENBQUE7UUFBUUQsT0FBQTtNQUFSO1FBQWNBLE9BQUFsRDtNQUFkO0lBREZrRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEseUJBQUFBLHFCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXBELElBQUF3QyxNQUFBQSxDQUFBQSxDQUFJWSxXQUFBQSxDQUFBQTtJQUROQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDckQsSUFBQTZCLEtBQUFBLENBQUFBLENBQUQsRUFBTTdCLElBQUFzRCxLQUFBQSxDQUFBQSxDQUFOO0lBREZELENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxtQkFBQUEsZUFBUWpELEtBQVJpRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBMkNiLFdBQTNDYyxLQUFNQyxlQUFBQSxDQUFZekQsSUFBbEIsRUFBd0IwRCxlQUF4QixFQUFvQyxNQUE5QkQsQ0FBcUNmLEVBQUVwQyxLQUFGb0M7SUFEN0NhLENBQUFBLEdBQUFBOztBQUlBSSxJQUFBQSxvQkFBQUEsWUFBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxZQUNFLElBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUM3RCxJQUFELEVBQU9zQixDQUFQO0lBREZ1QyxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQUFVQyxNQUFWRDtBQUFBQSxNQUFBQTs7OztNQUNFQSxPQUFBOUQsSUFBQXFDLE1BQUFBLENBQUFBLENBQUl5QixPQUFBQSxDQUFPQyxNQUFQRDtJQUROQSxDQUFBQSxJQUFBQTs7QUFJQUUsSUFBQUEsb0JBQUFBLGdCQXJJRixFQXFJVSxFQXJJVixFQXFJVSxFQXJJVixFQXFJRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFySUY7TUFBQTtNQUFBOztNQXFJVzs7TUFBbUI7O01BQWtCOztNQUFlOztBQUUvREE7QUFDQUEsUUFBVXZELE9BQVFRLE9BQUFBLENBQU9FLG9CQUFmLEVBQWdDNkMsbUJBQXhCL0M7QUFDbEIrQzs7QUFFQUE7QUFDQUEsUUFBVXZELE9BQVFRLE9BQUFBLENBQU9FLG9CQUFmLEVBQWdDNkMscUJBQXhCL0M7QUFDbEIrQzs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsVUFBWXZELE9BQVFRLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCOEMsc0JBQXBCL0M7QUFDcEIrQzs7QUFFQUEsNEJBQThCQSxJQUFLQyxPQUFBQSxDQUFHM0MsQ0FBSDJDLENBQUtEO0FBQ3hDQSxVQUFZdkQsT0FBUVEsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBZ0M2QyxpQkFBeEIvQztBQUNwQitDOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUEsbUJBQXFCQSxJQUFLNUMsUUFBQUEsQ0FBSUUsQ0FBSkYsQ0FBTTRDOztBQUVoQ0E7QUFDQUEsVUFBWXZELE9BQVFRLE9BQUFBLENBQU9FLG9CQUFmLEVBQWlDNkMsMEJBQUQsR0FBQSxDQUEyQkEsSUFBSXhELE9BQUFBLENBQUFBLENBQS9CLENBQXhCUztBQUNwQitDOztBQUVBQTtBQUNBQSw2QkFBK0JFLElBQUF4RCxZQUFBd0QsYUFBa0JGLEdBQU1FLElBQUF4RCxZQUFBd0QsYUFBRDFDLE9BQUFBLENBQUFBLENBQW1Cd0M7QUFDekVBOztBQUVBQSxRQUFVUixLQUFNVyxTQUFBQSxDQUFTbkUsSUFBZixFQUFxQm9FLEtBQWZEO0FBQ2hCSDs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsK0VBQWlGSyxJQUFBM0QsWUFBQTJELFlBQWlCTDs7QUFFbEdBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO01BRUksS0FBT00sZUFBUDtRQUNFLElBQUcsQ0FBQyxDQUFBLEtBQUNGLEtBQUQsQ0FBQSxJQUFBLENBQUEsUUFBVUEsS0FBS0csVUFBQUEsQ0FBT0MsY0FBUEQsQ0FBZixDQUFBLENBQUEsQ0FBRCxJQUFBLENBQ0MsQ0FBQSxLQUFDUCxJQUFELENBQUEsSUFBQSxDQUFBLFFBQVNBLElBQUlPLFVBQUFBLENBQU9DLGNBQVBELENBQWIsQ0FBQSxDQUFBLENBREQsQ0FBQSxDQUFIO1VBR0UsT0FBT0UsSUFBQUMsaUJBQUFELHVCQUFnQ0UsS0FBQUEsQ0FDckMsQ0FBQ1AsS0FBRCxFQUFRSixJQUFSLEVBQWUsQ0FBQSxRQUFVWSxFQUFWLENBQUEsR0FBQSxDQUFBWixNQUFBLElBQUEsR0FBQSxDQUFmLEVBQStCLENBQUEsUUFBVWEsRUFBVixDQUFBLEdBQUEsQ0FBQWIsTUFBQSxJQUFBLEdBQUEsQ0FBL0IsQ0FESyxFQUMwQ2hFLElBRFYyRTtRQUh6QztVQU9FLE9BQU9HLE1BQUE5RSxJQUFBOEUsWUFBQUEsRUFBQUEsQ0FBUyxNQUFULEVBQWdCVixLQUFoQixFQUF1QkosSUFBdkJjLENBQUFBLEVBQThCZCxDQUFDQSxRQUFEQSxDQUFEZSxTQUFBQSxDQUFBQSxDQUE3QkQ7UUFQVDtNQURGOztBQWFKZDs7QUFFQUEsbUJBQXFCQSxJQUFJZ0IsY0FBQUEsQ0FBQUEsQ0FBV2hCO0FBQ3BDQSxrQkFBb0JBLElBQUtDLE9BQUFBLENBQUczQyxDQUFIMkMsQ0FBS0Q7QUFDOUJBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLHNCQUF3QmhFLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFLMkI7QUFDN0JBLGlCQUFtQkEsSUFBSTNCLE1BQUFBLENBQUFBLENBQU0yQjtBQUM3QkEsa0JBQW9CSSxLQUFLL0IsTUFBQUEsQ0FBQUEsQ0FBTTJCOztBQUUvQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJaUIsVUFBVWpGO01BRVYsT0FBQSxRQUFPZ0UsU0FBbUJrQixPQUFSRCxPQUFRQyxFQUFHZCxLQUFIYyxDQUFTbEIsR0FBYW1CLE9BQVJGLE9BQVFFLEVBQUdmLEtBQUhlLENBQWhELENBQUE7O1FBQ0UsbUJBQU1GLE9BQU47UUFDQUEsVUFBUUcsU0FBUkgsT0FBUUcsRUFBR3BCLElBQUhvQjtNQUZWO0lBaEtGcEIsQ0FBQUEsSUFBQUE7O0FBc0tBcUIsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTVFLE9BQVFzQyxTQUFBQSxDQUFTL0MsSUFBakIsRUFBdUJzQixDQUFmeUI7SUFEVnNDLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdEYsSUFBQXVGLE1BQUFBLENBQUFBO0lBREZELENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSx3QkFBQUEsb0JBQWFwRCxPQUFib0Q7QUFBQUEsTUFBQUE7OztNQUFhLCtCQUFVbEU7TUFDckJrRSxPQUFBeEYsSUFBQXFDLE1BQUFBLENBQUFBLENBQUltRCxVQUFBQSxDQUFVcEQsT0FBVm9EO0lBRE5BLENBQUFBLElBQUFBOztBQUlBckMsSUFBQUEscUJBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQW5ELElBQUtpRSxPQUFBQSxDQUFHM0MsQ0FBSDJDO0lBRFBkLENBQUFBLEdBQUFBOztBQUlBc0MsSUFBQUEseUJBQUFBLGtDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0MsT0FBTDFGLElBQUswRixFQUFFcEUsQ0FBRm9FO0lBRFBELENBQUFBLEdBQUFBOztBQUlBVCxJQUFBQSx5QkFBQUEsa0NBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLbEQsT0FBTDlCLElBQUs4QixFQUFFUixDQUFGUTtJQURQa0QsQ0FBQUEsR0FBQUE7O0FBSUFXLElBQUFBLG1CQUFBQSxZQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQXZVRkMsT0F1VUVEO0FBQUFBLE1BQUFBOzs7TUF2VUY7O01BdVVZLGtDQUFBLDZCQUFRO01BQ2hCQSxPQUFBNUY7SUFERjRGLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSx1QkFBQUEsWUFDRSxJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEseUJBQUFBLFlBQ0UsR0FERkEsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLEtBQU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLEtBQWhCO0lBQ0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQTdGLE9BQUEsYUFBTSxhQUFOLEVBQWtCLE1BQWxCO0VBdlZGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2NDQ4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuXG5jbGFzcyA6OkNvbXBsZXggPCA6Ok51bWVyaWNcbiAgZGVmIHNlbGYucmVjdChyZWFsLCBpbWFnID0gMClcbiAgICB1bmxlc3MgOjpOdW1lcmljID09PSByZWFsICYmIHJlYWwucmVhbD8gJiYgOjpOdW1lcmljID09PSBpbWFnICYmIGltYWcucmVhbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGEgcmVhbCdcbiAgICBlbmRcblxuICAgIG5ldyhyZWFsLCBpbWFnKVxuICBlbmRcblxuICBkZWYgc2VsZi5wb2xhcihyLCB0aGV0YSA9IDApXG4gICAgdW5sZXNzIDo6TnVtZXJpYyA9PT0gciAmJiByLnJlYWw/ICYmIDo6TnVtZXJpYyA9PT0gdGhldGEgJiYgdGhldGEucmVhbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGEgcmVhbCdcbiAgICBlbmRcblxuICAgIG5ldyhyICogOjpNYXRoLmNvcyh0aGV0YSksIHIgKiA6Ok1hdGguc2luKHRoZXRhKSlcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJlYWwsIDppbWFnXG5cbiAgZGVmIGluaXRpYWxpemUocmVhbCwgaW1hZyA9IDApXG4gICAgQHJlYWwgPSByZWFsXG4gICAgQGltYWcgPSBpbWFnXG4gICAgZnJlZXplXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgW290aGVyLCBzZWxmXVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIFs6OkNvbXBsZXgubmV3KG90aGVyLCAwKSwgc2VsZl1cbiAgICBlbHNlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICBAcmVhbCA9PSBvdGhlci5yZWFsICYmIEBpbWFnID09IG90aGVyLmltYWdcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBAcmVhbCA9PSBvdGhlciAmJiBAaW1hZyA9PSAwXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLUBcbiAgICA6Oktlcm5lbC5Db21wbGV4KC1AcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsICsgb3RoZXIucmVhbCwgQGltYWcgKyBvdGhlci5pbWFnKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKyBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgLSBvdGhlci5yZWFsLCBAaW1hZyAtIG90aGVyLmltYWcpXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAtIG90aGVyLCBAaW1hZylcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAqIG90aGVyLnJlYWwgLSBAaW1hZyAqIG90aGVyLmltYWcsXG4gICAgICAgIEByZWFsICogb3RoZXIuaW1hZyArIEBpbWFnICogb3RoZXIucmVhbCxcbiAgICAgIClcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsICogb3RoZXIsIEBpbWFnICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIGlmICg6Ok51bWJlciA9PT0gQHJlYWwgJiYgQHJlYWwubmFuPykgfHwgKDo6TnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fFxuICAgICAgICAgKDo6TnVtYmVyID09PSBvdGhlci5yZWFsICYmIG90aGVyLnJlYWwubmFuPykgfHwgKDo6TnVtYmVyID09PSBvdGhlci5pbWFnICYmIG90aGVyLmltYWcubmFuPylcbiAgICAgICAgOjpDb21wbGV4Lm5ldyg6OkZsb2F0OjpOQU4sIDo6RmxvYXQ6Ok5BTilcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZiAqIG90aGVyLmNvbmogLyBvdGhlci5hYnMyXG4gICAgICBlbmRcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsLnF1byhvdGhlciksIEBpbWFnLnF1byhvdGhlcikpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBpZiBvdGhlciA9PSAwXG4gICAgICByZXR1cm4gOjpDb21wbGV4Lm5ldygxLCAwKVxuICAgIGVuZFxuXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuICAgICAgb3JlICAgICAgPSBvdGhlci5yZWFsXG4gICAgICBvaW0gICAgICA9IG90aGVyLmltYWdcbiAgICAgIG5yICAgICAgID0gOjpNYXRoLmV4cChvcmUgKiA6Ok1hdGgubG9nKHIpIC0gb2ltICogdGhldGEpXG4gICAgICBudGhldGEgICA9IHRoZXRhICogb3JlICsgb2ltICogOjpNYXRoLmxvZyhyKVxuXG4gICAgICA6OkNvbXBsZXgucG9sYXIobnIsIG50aGV0YSlcbiAgICBlbHNpZiA6OkludGVnZXIgPT09IG90aGVyXG4gICAgICBpZiBvdGhlciA+IDBcbiAgICAgICAgeCA9IHNlbGZcbiAgICAgICAgeiA9IHhcbiAgICAgICAgbiA9IG90aGVyIC0gMVxuXG4gICAgICAgIHdoaWxlIG4gIT0gMFxuICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcbiAgICAgICAgICB3aGlsZSBtb2QgPT0gMFxuICAgICAgICAgICAgeCA9IDo6S2VybmVsLkNvbXBsZXgoeC5yZWFsICogeC5yZWFsIC0geC5pbWFnICogeC5pbWFnLCAyICogeC5yZWFsICogeC5pbWFnKVxuICAgICAgICAgICAgbiA9IGRpdlxuICAgICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgeiAqPSB4XG4gICAgICAgICAgbiAtPSAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHpcbiAgICAgIGVsc2VcbiAgICAgICAgKDo6UmF0aW9uYWwubmV3KDEsIDEpIC8gc2VsZikqKi1vdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgOjpGbG9hdCA9PT0gb3RoZXIgfHwgOjpSYXRpb25hbCA9PT0gb3RoZXJcbiAgICAgIHIsIHRoZXRhID0gcG9sYXJcblxuICAgICAgOjpDb21wbGV4LnBvbGFyKHIqKm90aGVyLCB0aGV0YSAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIDo6TWF0aC5oeXBvdChAcmVhbCwgQGltYWcpXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgQHJlYWwgKiBAcmVhbCArIEBpbWFnICogQGltYWdcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgOjpNYXRoLmF0YW4yKEBpbWFnLCBAcmVhbClcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsLCAtQGltYWcpXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEByZWFsLmRlbm9taW5hdG9yLmxjbShAaW1hZy5kZW5vbWluYXRvcilcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgQ29tcGxleCA9PT0gb3RoZXIgJiYgQHJlYWwuY2xhc3MgPT0gQGltYWcuY2xhc3MgJiYgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB1bmxlc3MgOjpOdW1lcmljID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxuICAgIGVuZFxuXG4gICAgc2VsZiAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgQHJlYWwuZmluaXRlPyAmJiBAaW1hZy5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJDb21wbGV4OiN7QHJlYWx9OiN7QGltYWd9XCJcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIEByZWFsLmluZmluaXRlPyB8fCBAaW1hZy5pbmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBkID0gZGVub21pbmF0b3JcblxuICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwubnVtZXJhdG9yICogKGQgLyBAcmVhbC5kZW5vbWluYXRvciksXG4gICAgICBAaW1hZy5udW1lcmF0b3IgKiAoZCAvIEBpbWFnLmRlbm9taW5hdG9yKSxcbiAgICApXG4gIGVuZFxuXG4gIGRlZiBwb2xhclxuICAgIFthYnMsIGFyZ11cbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIEBpbWFnICE9IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICByZWFsLnJhdGlvbmFsaXplKGVwcylcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlY3RcbiAgICBbQHJlYWwsIEBpbWFnXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gRmxvYXRcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9fZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19pXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoOjpOdW1iZXIgPT09IEBpbWFnICYmIEBpbWFnLm5hbj8pIHx8IEBpbWFnLnBvc2l0aXZlPyB8fCBAaW1hZy56ZXJvP1xuICAgICAgICAnKydcbiAgICAgIGVsc2VcbiAgICAgICAgJy0nXG4gICAgICBlbmRcblxuICAgIHJlc3VsdCArPSBAaW1hZy5hYnMuaW5zcGVjdFxuXG4gICAgaWYgOjpOdW1iZXIgPT09IEBpbWFnICYmIChAaW1hZy5uYW4/IHx8IEBpbWFnLmluZmluaXRlPylcbiAgICAgIHJlc3VsdCArPSAnKidcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICdpJ1xuICBlbmRcblxuICBJID0gbmV3KDAsIDEpXG5cbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyKVxuICAgICV4e1xuICAgICAgdmFyIHJlID0gL1srLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8oZVxcZCspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIHJlYWwsIGltYWcsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZXMgYm90aCBmbG9hdHMgYW5kIHJhdGlvbmFsc1xuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xuICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXG4gICAgICAgICAgICAgIHN0ciA9ICcvJyArIHN0cjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxvYXQgcmVhbCBwYXJ0LCBubyBkZW5vbWluYXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVhbCA9IGN1dE51bWJlcigpO1xuXG4gICAgICBpZiAoIXJlYWwpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gaSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy0nICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIC0xKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gK2kgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFueXRoaW5nID0+IENvbXBsZXgoMCwgMClcbiAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAwKX07XG4gICAgICB9XG5cbiAgICAgIGltYWcgPSBjdXROdW1iZXIoKTtcbiAgICAgIGlmICghaW1hZykge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAzaSA9PiBDb21wbGV4KDAsIDMpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCBgcmVhbGApfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAzID0+IENvbXBsZXgoMywgMClcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KGByZWFsYCwgMCl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcbiAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleChgcmVhbGAsIGBpbWFnYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG4gIGFsaWFzIGRpdmlkZSAvXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcbiAgYWxpYXMgcGhhc2UgYXJnXG4gIGFsaWFzIHF1byAvXG4gIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcblxuICB1bmRlZiBuZWdhdGl2ZT9cbiAgdW5kZWYgcG9zaXRpdmU/XG4gIHVuZGVmIHN0ZXBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDb21wbGV4PiIsInJlY3QiLCJyZWFsIiwiaW1hZyIsIjAiLCJOdW1lcmljIiwicmVhbD8iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5ldyIsInBvbGFyIiwiciIsInRoZXRhIiwiKiIsIk1hdGgiLCJjb3MiLCJzaW4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVhbCIsIkBpbWFnIiwiZnJlZXplIiwiY29lcmNlIiwib3RoZXIiLCJDb21wbGV4IiwiY2xhc3MiLCI9PSIsIiRyZXRfb3JfMSIsIi1AIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIi8iLCJOdW1iZXIiLCJuYW4/IiwiRmxvYXQ6Ok5BTiIsIkZsb2F0IiwiY29uaiIsImFiczIiLCJxdW8iLCIqKiIsIjEiLCJvcmUiLCJvaW0iLCJuciIsImV4cCIsImxvZyIsIm50aGV0YSIsIkludGVnZXIiLCI+IiwieCIsInoiLCJuIiwiZGl2bW9kIiwiMiIsImRpdiIsIm1vZCIsIlJhdGlvbmFsIiwiYWJzIiwiaHlwb3QiLCJhbmdsZSIsImF0YW4yIiwiZGVub21pbmF0b3IiLCJsY20iLCJlcWw/IiwiJHJldF9vcl8yIiwiPT09IiwiZmRpdiIsImZpbml0ZT8iLCJoYXNoIiwiaW5maW5pdGU/IiwiaW5zcGVjdCIsIm51bWVyYXRvciIsImQiLCJhcmciLCJyYXRpb25hbGl6ZSIsImVwcyIsIkFyZ3VtZW50RXJyb3IiLCJSYW5nZUVycm9yIiwidG9fZiIsInRvX2kiLCJ0b19yIiwidG9fcyIsInJlc3VsdCIsInBvc2l0aXZlPyIsInplcm8/IiwiZnJvbV9zdHJpbmciLCJzdHIiLCItMSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsc0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLFdBQUFBLGdCQUFjQyxJQUFELEVBQU9DLElBQXBCRjtBQUFBQSxNQUFBQTs7O01BQW9CLHlCQUFPRztNQUN6QixLQUFPLENBQUEsQ0FBQSxDQUFBLFFBQUFDLGNBQUEsRUFBY0gsSUFBZCxDQUFBLElBQUEsQ0FBQSxRQUFzQkEsSUFBSUksVUFBQUEsQ0FBQUEsQ0FBMUIsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQW9DRCxjQUFwQyxFQUFrREYsSUFBbEQsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQTBEQSxJQUFJRyxVQUFBQSxDQUFBQSxDQUE5RCxDQUFBLENBQUEsQ0FBUDtRQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QlIsWUFBcEJPO01BRFY7TUFJQVAsT0FBQUgsSUFBQVksS0FBQUEsQ0FBSVIsSUFBSixFQUFVQyxJQUFWTztJQUxGVCxDQUFBQSxJQUFBQTtJQVFBVSxNQUFJYixJQUFKYSxZQUFBQSxpQkFBZUMsQ0FBRCxFQUFJQyxLQUFsQkY7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QTtBQUNBQTtJQTNFRUEsQ0FBQUEsR0FBQUE7SUE4RUE7O01BQ0UsT0FBQSxhQUFNLGFBQU4sRUFBa0IsTUFBbEI7SUFERiw0QkFBU3pGLElBQVQ7SUFJQSxhQUFNLEtBQU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sV0FBTixFQUFnQixLQUFoQjtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLEtBQU4sRUFBVSxHQUFWO0lBQ0EsYUFBTSxhQUFOLEVBQWtCLE1BQWxCOztJQUVBLHNCQUFNLFdBQU47O0lBQ0Esc0JBQU0sV0FBTjs7O0lBQ0Esc0JBQU0sTUFBTjtJQTNXRkUsT0FBQTtFQUdBQSxHQUFNLElBQU5BLEVBQWtCSyxjQUFsQkw7QUFIQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY4OTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpLZXJuZWxcbiAgZGVmIENvbXBsZXgocmVhbCwgaW1hZyA9IG5pbClcbiAgICBpZiBpbWFnXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCBpbWFnKVxuICAgIGVsc2VcbiAgICAgIENvbXBsZXgubmV3KHJlYWwsIDApXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6U3RyaW5nXG4gIGRlZiB0b19jXG4gICAgQ29tcGxleC5mcm9tX3N0cmluZyhzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCJDb21wbGV4IiwicmVhbCIsImltYWciLCJuZXciLCIwIiwiPGNsYXNzOlN0cmluZz4iLCJ0b19jIiwiZnJvbV9zdHJpbmciLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFZQyxJQUFELEVBQU9DLElBQWxCRjtBQUFBQTs7TUFBa0IseUJBQU87TUFDdkIsSUFBQSxRQUFHRSxJQUFILENBQUE7UUFDRUYsT0FBQUEsYUFBT0csS0FBQUEsQ0FBS0YsSUFBWixFQUFrQkMsSUFBWEM7TUFEVDtRQUdFSCxPQUFBQSxhQUFPRyxLQUFBQSxDQUFLRixJQUFaLEVBQWtCRyxDQUFYRDtNQUhUO0lBREZILENBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFVQUQsT0FBQU87RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBTixhQUFPTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURURCxDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBVkFQOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2OTI4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuXG5tb2R1bGUgOjpNYXRoXG4gIHNlbGY6OkUgID0gYE1hdGguRWBcbiAgc2VsZjo6UEkgPSBgTWF0aC5QSWBcblxuICBzZWxmOjpEb21haW5FcnJvciA9IDo6Q2xhc3MubmV3KDo6U3RhbmRhcmRFcnJvcilcblxuICBkZWYgc2VsZi5jaGVja2VkKG1ldGhvZCwgKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBNYXRoW21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsIFwiTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcXFwiI3ttZXRob2R9XFxcIlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZsb2F0ISh2YWx1ZSlcbiAgICA6Oktlcm5lbC5GbG9hdCh2YWx1ZSlcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3s6OkZsb2F0fSlgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIDo6S2VybmVsLkludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSA6OkFyZ3VtZW50RXJyb3JcbiAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7OjpJbnRlZ2VyfSlgXG4gIGVuZFxuXG4gIG1vZHVsZV9mdW5jdGlvblxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZgKVxuICAgICV4e1xuICAgICAgT3BhbC5wcm9wKE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmY2ApXG4gICAgJXh7XG4gICAgICBPcGFsLnByb3AoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICAjIFNpbmdsZSBhcmd1bWVudCBlcXVpdmFsZW50IGZ1bmN0aW9uc1xuICAlaVtcbiAgICBhY29zIGFjb3NoIGFzaW4gYXNpbmggYXRhbiBhdGFuaCBjYnJ0XG4gICAgY29zIGNvc2ggZXJmIGVyZmMgZXhwIHNpbiBzaW5oIHNxcnQgdGFuaFxuICBdLmVhY2ggZG8gfG1ldGhvZHxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkbyB8eHxcbiAgICAgIDo6TWF0aC5jaGVja2VkIG1ldGhvZCwgOjpNYXRoLmZsb2F0ISh4KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYXRhbjIoeSwgeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXRhbjIsIDo6TWF0aC5mbG9hdCEoeSksIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmh5cG90LCA6Ok1hdGguZmxvYXQhKHgpLCA6Ok1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBmcmV4cCh4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggICA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoeCkpIC8gTWF0aC5sb2coMikpICsgMSxcbiAgICAgICAgICBmcmFjID0geCAvIE1hdGgucG93KDIsIGV4KTtcblxuICAgICAgcmV0dXJuIFtmcmFjLCBleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2FtbWEobilcbiAgICBuID0gTWF0aC5mbG9hdCEobilcblxuICAgICV4e1xuICAgICAgdmFyIGksIHQsIHgsIHZhbHVlLCByZXN1bHQsIHR3b04sIHRocmVlTiwgZm91ck4sIGZpdmVOO1xuXG4gICAgICB2YXIgRyA9IDQuNzQyMTg3NTtcblxuICAgICAgdmFyIFAgPSBbXG4gICAgICAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLFxuICAgICAgICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgICAgICAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgICAgICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgICAgICAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCxcbiAgICAgICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgICAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAgICAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAgICAgIDAuMTU4MDg4NzAzMjI0OTEyNDg4ODRlLTMsXG4gICAgICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgICAgICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyMGUtMyxcbiAgICAgICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgICAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAgICAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAgICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbiAgICAgIF07XG5cblxuICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gLTEgfHwgbiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiZ2FtbWFcIid9O1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tJbnRlZ2VyID09PSBufSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA+IDE3MSkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICA9IG4gLSAyO1xuICAgICAgICByZXN1bHQgPSBuIC0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09IDApIHtcbiAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIG4pICogI3s6Ok1hdGguZ2FtbWEoMSAtIG4pfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID49IDE3MS4zNSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID4gODUuMCkge1xuICAgICAgICB0d29OICAgPSBuICogbjtcbiAgICAgICAgdGhyZWVOID0gdHdvTiAqIG47XG4gICAgICAgIGZvdXJOICA9IHRocmVlTiAqIG47XG4gICAgICAgIGZpdmVOICA9IGZvdXJOICogbjtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJIC8gbikgKiBNYXRoLnBvdygobiAvIE1hdGguRSksIG4pICpcbiAgICAgICAgICAoMSArIDEgLyAoMTIgKiBuKSArIDEgLyAoMjg4ICogdHdvTikgLSAxMzkgLyAoNTE4NDAgKiB0aHJlZU4pIC1cbiAgICAgICAgICA1NzEgLyAoMjQ4ODMyMCAqIGZvdXJOKSArIDE2Mzg3OSAvICgyMDkwMTg4ODAgKiBmaXZlTikgK1xuICAgICAgICAgIDUyNDY4MTkgLyAoNzUyNDY3OTY4MDAgKiBmaXZlTiAqIG4pKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSAxO1xuICAgICAgeCAgPSBQWzBdO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgUC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4ICs9IFBbaV0gLyAobiArIGkpO1xuICAgICAgfVxuXG4gICAgICB0ID0gbiArIEcgKyAwLjU7XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5wb3codCwgbiArIDAuNSkgKiBNYXRoLmV4cCgtdCkgKiB4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudClcbiAgICBtYW50aXNzYSA9IE1hdGguZmxvYXQhKG1hbnRpc3NhKVxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Zsb2F0IE5hTiBvdXQgb2YgcmFuZ2Ugb2YgaW50ZWdlcid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGdhbW1hKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiA9PSAtMSkge1xuICAgICAgICByZXR1cm4gW0luZmluaXR5LCAxXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW01hdGgubG9nKE1hdGguYWJzKCN7OjpNYXRoLmdhbW1hKG4pfSkpLCAjezo6TWF0aC5nYW1tYShuKX0gPCAwID8gLTEgOiAxXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2coeCwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcbiAgICAgIDo6TWF0aC5jaGVja2VkIDpsb2csIDo6TWF0aC5mbG9hdCEoeClcbiAgICBlbHNlXG4gICAgICBpZiA6OlN0cmluZyA9PT0gYmFzZVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoYmFzZSwgI3s6OkZsb2F0fSlgXG4gICAgICBlbmRcblxuICAgICAgOjpNYXRoLmNoZWNrZWQoOmxvZywgOjpNYXRoLmZsb2F0ISh4KSkgLyA6Ok1hdGguY2hlY2tlZCg6bG9nLCA6Ok1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbG9nMTAoeClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOmxvZzEwLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBsb2cyKHgpXG4gICAgaWYgOjpTdHJpbmcgPT09IHhcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih4LCAjezo6RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDpsb2cyLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiB0YW4oeClcbiAgICB4ID0gOjpNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiA6OkZsb2F0OjpOQU5cbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDp0YW4sIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpNYXRoPiIsInNlbGYiLCJDbGFzcyIsIm5ldyIsIlN0YW5kYXJkRXJyb3IiLCJjaGVja2VkIiwibWV0aG9kIiwiS2VybmVsIiwicmFpc2UiLCJEb21haW5FcnJvciIsImZsb2F0ISIsInZhbHVlIiwiRmxvYXQiLCJBcmd1bWVudEVycm9yIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiZWFjaCIsImJsb2NrIGluIDxtb2R1bGU6TWF0aD4iLCJibG9jayAoMiBsZXZlbHMpIGluIDxtb2R1bGU6TWF0aD4iLCJkZWZpbmVfbWV0aG9kIiwieCIsImJsb2NrICgzIGxldmVscykgaW4gPG1vZHVsZTpNYXRoPiIsIk1hdGgiLCJhdGFuMiIsInkiLCJoeXBvdCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJsZGV4cCIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJSYW5nZUVycm9yIiwibGdhbW1hIiwibG9nIiwiYmFzZSIsIlN0cmluZyIsIi8iLCJsb2cxMCIsImxvZzIiLCJ0YW4iLCJpbmZpbml0ZT8iLCJGbG9hdDo6TkFOIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxXQUFBQyxJQUFBLE9BQVlELE1BQVo7SUFDQSxXQUFBQyxJQUFBLFFBQVlELE9BQVo7SUFFQSxXQUFBQyxJQUFBLGlCQUFvQkMsTUFBT0MsS0FBQUEsQ0FBS0Msb0JBQUxELENBQTNCO0lBRUFFLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFpQkMsTUFBRCxFQVJsQixFQVFFRDtBQUFBQSxNQUFBQTs7O01BUkY7TUFRMkI7O0FBRTNCQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFFBQVVFLE9BQVFDLE9BQUFBLENBQU9DLGlCQUFmLEVBQTZCSiwwQ0FBRCxHQUFBLENBQTJDQyxNQUEzQyxDQUFBLEdBQWtERCxJQUF0RUcsQ0FBMEVIO0FBQzVGQTs7QUFFQUE7QUFDQUE7SUFiRUEsQ0FBQUEsSUFBQUE7SUFnQkFLLE1BQUlULElBQUpTLGFBQUFBLDRCQUFnQkMsS0FBaEJEO0FBQUFBO01BQ0U7UUFBQUEsT0FBQUgsT0FBUUssT0FBQUEsQ0FBT0QsS0FBUEM7TUFBUjtRQUNGLHNCQUFPLENBQUFDLG9CQUFBLENBQVA7VUFBQTtZQUNFSCxPQUFBSCxPQUFRQyxPQUFBQSxD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bkM7TUFEVjtNQUlBbUMsT0FBQXBCLFdBQU1sQixTQUFBQSxDQUFTLE1BQWYsRUFBc0JrQixXQUFNYixXQUFBQSxDQUFRVyxDQUFSWCxDQUF0Qkw7SUFMUnNDLENBQUFBLEdBQUFBO0lBUUEzQyxPQUFBNEMsbUJBQUFBLGVBQVF2QixDQUFSdUI7QUFBQUE7O01BQ0V2QixJQUFJRSxXQUFNYixXQUFBQSxDQUFRVyxDQUFSWDtNQUVWLElBQUEsUUFBR1csQ0FBQ3dCLGNBQUFBLENBQUFBLENBQUosQ0FBQTtRQUNFLE9BQU9DLElBQUFsQyxZQUFBa0M7TUFEVDtNQUlBRixPQUFBckIsV0FBTWxCLFNBQUFBLENBQVMsS0FBZixFQUFxQmtCLFdBQU1iLFdBQUFBLENBQVFXLENBQVJYLENBQXJCTDtJQVBSdUMsQ0FBQUEsR0FBQUE7RUFwUkY1QyxHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo3MjQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIDo6RW5jb2RpbmdcbiAgZGVmIHNlbGYucmVnaXN0ZXIobmFtZSwgb3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgbmFtZXMgPSBbbmFtZV0gKyAob3B0aW9uc1s6YWxpYXNlc10gfHwgW10pXG4gICAgYXNjaWkgPSBvcHRpb25zWzphc2NpaV0gfHwgZmFsc2VcbiAgICBkdW1teSA9IG9wdGlvbnNbOmR1bW15XSB8fCBmYWxzZVxuXG4gICAgaWYgb3B0aW9uc1s6aW5oZXJpdHNdXG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnNbOmluaGVyaXRzXS5jbG9uZVxuICAgICAgZW5jb2RpbmcuaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVsc2VcbiAgICAgIGVuY29kaW5nID0gbmV3KG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgZW5kXG4gICAgZW5jb2RpbmcuaW5zdGFuY2VfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgcmVnaXN0ZXIgPSBgT3BhbC5lbmNvZGluZ3NgXG4gICAgbmFtZXMuZWFjaCBkbyB8ZW5jb2RpbmdfbmFtZXxcbiAgICAgIGNvbnN0X3NldCBlbmNvZGluZ19uYW1lLnRyKCctJywgJ18nKSwgZW5jb2RpbmdcbiAgICAgIHJlZ2lzdGVyLkpTW2VuY29kaW5nX25hbWVdID0gZW5jb2RpbmdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmluZChuYW1lKVxuICAgIHJldHVybiBkZWZhdWx0X2V4dGVybmFsIGlmIG5hbWUgPT0gOmRlZmF1bHRfZXh0ZXJuYWxcbiAgICBgcmV0dXJuIE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKWBcbiAgZW5kXG5cbiAgc2luZ2xldG9uX2NsYXNzLmF0dHJfYWNjZXNzb3IgOmRlZmF1bHRfZXh0ZXJuYWxcblxuICBhdHRyX3JlYWRlciA6bmFtZSwgOm5hbWVzXG5cbiAgZGVmIGluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBAbmFtZSAgPSBuYW1lXG4gICAgQG5hbWVzID0gbmFtZXNcbiAgICBAYXNjaWkgPSBhc2NpaVxuICAgIEBkdW1teSA9IGR1bW15XG4gIGVuZFxuXG4gIGRlZiBhc2NpaV9jb21wYXRpYmxlP1xuICAgIEBhc2NpaVxuICBlbmRcblxuICBkZWYgZHVtbXk/XG4gICAgQGR1bW15XG4gIGVuZFxuXG4gIGRlZiBiaW5hcnk/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBAbmFtZVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxFbmNvZGluZzoje0BuYW1lfSN7JyAoZHVtbXkpJyBpZiBAZHVtbXl9PlwiXG4gIGVuZFxuXG4gICMgbWV0aG9kcyB0byBpbXBsZW1lbnQgcGVyIGVuY29kaW5nXG4gIGRlZiBjaGFyc2l6ZShzdHJpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICghKGNoYXJjb2RlID49IDB4RDgwMCAmJiBjaGFyY29kZSA8PSAweERCRkYpKSB7XG4gICAgICAgICAgbGVuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGxvd19zdXJyb2dhdGUgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNociA9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA+PSAweERDMDAgJiYgY2hhcmNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgbG93X3N1cnJvZ2F0ZSA9IGNocjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgY2hyID0gbG93X3N1cnJvZ2F0ZSArIGNocjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nLmVuY29kaW5nLm5hbWUgIT0gXCJVVEYtOFwiKSB7XG4gICAgICAgICAgY2hyID0gbmV3IFN0cmluZyhjaHIpO1xuICAgICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgfVxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgY2hyKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoKilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKCopXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIDo6RW5jb2RpbmdFcnJvciA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG4gIGNsYXNzIDo6Q29tcGF0aWJpbGl0eUVycm9yIDwgOjpFbmNvZGluZ0Vycm9yOyBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtOCcsIGFsaWFzZXM6IFsnQ1A2NTAwMSddLCBhc2NpaTogdHJ1ZSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9mNTJkZmZkOWRmMDQ0NWI5M2MwYzkwNjVjMmY4ZjBmNDZiMmM3MjlhL2luZGV4LmpzI0wxOTU0LUwyMDMyXG4gICAgICB2YXIgdW5pdHMgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICAgIC8vIGVuY29kZSB1dGY4XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgfCAweEMwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgfCAweEUwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhaztcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEludmFsaWQgY29kZSBwb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2TEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogMmBcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2QkUnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzE2TEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDRgXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkJFJywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8zMkxFIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknXSwgYXNjaWk6IHRydWUgZG9cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IG5ldyBTdHJpbmcoc3RyaW5nLmNoYXJBdChpKSk7XG4gICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgI3t5aWVsZCBgY2hyYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0lTTy04ODU5LTEnLCBhbGlhc2VzOiBbJ0lTTzg4NTktMSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VTLUFTQ0lJJywgYWxpYXNlczogWydBU0NJSSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcblxuY2xhc3MgOjpTdHJpbmdcbiAgYXR0cl9yZWFkZXIgOmVuY29kaW5nXG4gIGF0dHJfcmVhZGVyIDppbnRlcm5hbF9lbmNvZGluZ1xuICBgT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdieXRlcycsIG5pbClgXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2VuY29kaW5nJywgI3s6OkVuY29kaW5nOjpVVEZfOH0pYFxuICBgT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7OjpFbmNvZGluZzo6VVRGXzh9KWBcblxuICBkZWYgYlxuICAgIGR1cC5mb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplXG4gICAgQGludGVybmFsX2VuY29kaW5nLmJ5dGVzaXplKHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9ieXRlKSB7IGJ5dGVzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGludGVybmFsX2VuY29kaW5nLmVhY2hfYnl0ZShzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBieXRlc1xuICAgICMgUkVNSU5EOiByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIG90aGVyd2lzZSB0aGUgZm9sbG93aW5nIGVycm9yIHdpbGwgYmUgdGhyb3duOlxuICAgICMgQ2Fubm90IGNyZWF0ZSBwcm9wZXJ0eSAnYnl0ZXMnIG9uIHN0cmluZyAnYWJjJ1xuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gI3tgbmV3IFN0cmluZyhzZWxmKWAuZWFjaF9ieXRlLnRvX2F9O1xuICAgICAgfVxuICAgIH1cblxuICAgIEBieXRlcyB8fD0gZWFjaF9ieXRlLnRvX2FcbiAgICBAYnl0ZXMuZHVwXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jaGFyKSB7IGxlbmd0aCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBlbmNvZGluZy5lYWNoX2NoYXIoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hhcnMoJmJsb2NrKVxuICAgIHJldHVybiBlYWNoX2NoYXIudG9fYSB1bmxlc3MgYmxvY2tcblxuICAgIGVhY2hfY2hhcigmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvZGVwb2ludCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2NvZGVwb2ludCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAje3lpZWxkIGBzZWxmLmNvZGVQb2ludEF0KGkpYH07XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvZGVwb2ludHMoJmJsb2NrKVxuICAgICMgSWYgYSBibG9jayBpcyBnaXZlbiwgd2hpY2ggaXMgYSBkZXByZWNhdGVkIGZvcm0sIHdvcmtzIHRoZSBzYW1lIGFzIGVhY2hfY29kZXBvaW50LlxuICAgIHJldHVybiBlYWNoX2NvZGVwb2ludCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICAgIGVhY2hfY29kZXBvaW50LnRvX2FcbiAgZW5kXG5cbiAgZGVmIGVuY29kZShlbmNvZGluZylcbiAgICBgT3BhbC5lbmMoc2VsZiwgZW5jb2RpbmcpYFxuICBlbmRcblxuICBkZWYgZm9yY2VfZW5jb2RpbmcoZW5jb2RpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZjtcblxuICAgICAgaWYgKGVuY29kaW5nID09PSBzdHIuZW5jb2RpbmcpIHsgcmV0dXJuIHN0cjsgfVxuXG4gICAgICBlbmNvZGluZyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIDo6U3RyaW5nLCA6dG9fcyl9O1xuICAgICAgZW5jb2RpbmcgPSAjezo6RW5jb2RpbmcuZmluZChlbmNvZGluZyl9O1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIHN0ciA9IE9wYWwuc2V0X2VuY29kaW5nKHN0ciwgZW5jb2RpbmcpO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGUoaWR4KVxuICAgIHN0cmluZ19ieXRlcyA9IGJ5dGVzXG4gICAgaWR4ID0gOjpPcGFsLmNvZXJjZV90byEoaWR4LCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgcmV0dXJuIGlmIHN0cmluZ19ieXRlcy5sZW5ndGggPCBpZHhcblxuICAgIHN0cmluZ19ieXRlc1tpZHhdXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgJXtcbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBvdGhlci5lbmNvZGluZztcbiAgICAgIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcgPSBvdGhlci5pbnRlcm5hbF9lbmNvZGluZztcbiAgICB9XG4gIGVuZFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLmRlZmF1bHRfZXh0ZXJuYWwgPSBfX0VOQ09ESU5HX19cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW5jb2Rpbmc+IiwicmVnaXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsIm5hbWVzIiwiKyIsIiRyZXRfb3JfMSIsIltdIiwiYXNjaWkiLCJkdW1teSIsImVuY29kaW5nIiwiY2xvbmUiLCJpbml0aWFsaXplIiwibmV3IiwiYmxvY2tfZ2l2ZW4/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImVhY2giLCJibG9jayBpbiByZWdpc3RlciIsImVuY29kaW5nX25hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlZ2lzdGVyIiwiY29uc3Rfc2V0IiwidHIiLCJmaW5kIiwiZGVmYXVsdF9leHRlcm5hbCIsInNpbmdsZXRvbl9jbGFzcyIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIkBuYW1lIiwiQG5hbWVzIiwiQGFzY2lpIiwiQGR1bW15IiwiYXNjaWlfY29tcGF0aWJsZT8iLCJkdW1teT8iLCJiaW5hcnk/IiwidG9fcyIsImluc3BlY3QiLCJjaGFyc2l6ZSIsInN0cmluZyIsImVhY2hfY2hhciIsImVhY2hfYnl0ZSIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImJ5dGVzaXplIiwiPGNsYXNzOkVuY29kaW5nRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpDb21wYXRpYmlsaXR5RXJyb3I+IiwiRW5jb2RpbmdFcnJvciIsIkVuY29kaW5nIiwiYmxvY2sgaW4gPHRvcCAocmVxdWlyZWQpPiIsImJsb2NrICgyIGxldmVscykgaW4gPHRvcCAocmVxdWlyZWQpPiIsImJ5dGVzIiwibGVuZ3RoIiwiRW5jb2Rpbmc6OlVURl8xNkxFIiwiMCIsIkVuY29kaW5nOjpVVEZfMzJMRSIsIkVuY29kaW5nOjpBU0NJSV84QklUIiwiPGNsYXNzOlN0cmluZz4iLCJFbmNvZGluZzo6VVRGXzgiLCJiIiwiZHVwIiwiZm9yY2VfZW5jb2RpbmciLCJAaW50ZXJuYWxfZW5jb2RpbmciLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2hfYnl0ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9ieXRlIiwidG9fYSIsIkBieXRlcyIsImJsb2NrIGluIGVhY2hfY2hhciIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9jaGFyIiwiQGVuY29kaW5nIiwiY2hhcnMiLCJlYWNoX2NvZGVwb2ludCIsImNvZGVwb2ludHMiLCJlbmNvZGUiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsImdldGJ5dGUiLCJpZHgiLCJzdHJpbmdfYnl0ZXMiLCJJbnRlZ2VyIiwiPCIsImluaXRpYWxpemVfY29weSIsIm90aGVyIiwidmFsaWRfZW5jb2Rpbmc/IiwiZGVmYXVsdF9leHRlcm5hbD0iXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBRUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLGVBQUFBLG9CQUFrQkMsSUFBRCxFQUFPQyxPQUF4QkY7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBd0IsK0JBQVUsWUFBQTtNQUNoQ0csUUFBZUMsU0FBUCxDQUFDSCxJQUFELENBQU9HLEVBQUcsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBSCxPQUFPSSxPQUFBQSxDQUFDLFNBQURBLENBQVBELENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXFCLEVBQXJCLENBQUEsQ0FBSEQ7TUFDZkcsUUFBUSxDQUFBLFFBQUFGLENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFDUkcsUUFBUSxDQUFBLFFBQUFILENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFFUixJQUFBLFFBQUdILE9BQU9JLE9BQUFBLENBQUMsVUFBREEsQ0FBVixDQUFBOztRQUNFRyxXQUFXUCxPQUFPSSxPQUFBQSxDQUFDLFVBQURBLENBQVdJLE9BQUFBLENBQUFBO1FBQzdCRCxRQUFRRSxZQUFBQSxDQUFZVixJQUFwQixFQUEwQkUsS0FBMUIsRUFBaUNJLEtBQWpDLEVBQXdDQyxLQUFoQ0c7TUFGVjtRQUlFRixXQUFXWixJQUFBZSxLQUFBQSxDQUFJWCxJQUFKLEVBQVVFLEtB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Q0VBLE9BQUVBLElBQUYsR0FDSkEseUNBREksR0FFSkEsMkRBRkksR0FHSkE7SUFKRUEsQ0FBQUEsR0FBQUE7SUFRQTFCLE9BQUE0QiwrQkFBQUEsWUFDRSxJQURGQSxDQUFBQSxHQUFBQTtFQXZHRjVCLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE0R0E5RCxPQUFVMkYsTUFBQUEsQ0FBb0I1QixJQTNaOUJWLGNBMlo4QlUsVUFBcEI0QixDQUFBQSxFQUFBQSxNQUFWdEMsZUFBVXNDLHFCQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtBQTNaVjNGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo3NzY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwvZm9ybWF0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgZm9ybWF0KGZvcm1hdF9zdHJpbmcsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnc1swXS5yZXNwb25kX3RvPyg6dG9fYXJ5KVxuICAgICAgYXJ5ID0gOjpPcGFsLmNvZXJjZV90bz8oYXJnc1swXSwgOjpBcnJheSwgOnRvX2FyeSlcbiAgICAgIGFyZ3MgPSBhcnkudG9fYSB1bmxlc3MgYXJ5Lm5pbD9cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIC8vdXNlZCBmb3Igc2xpY2luZzpcbiAgICAgICAgICBiZWdpbl9zbGljZSA9IDAsXG4gICAgICAgICAgZW5kX3NsaWNlLFxuICAgICAgICAgIC8vdXNlZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIGZvcm1hdCBzdHJpbmc6XG4gICAgICAgICAgaSxcbiAgICAgICAgICBsZW4gPSBmb3JtYXRfc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgZmllbGQgdmFsdWVzOlxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICBzdHIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICVnIGFuZCAlRyBmaWVsZHM6XG4gICAgICAgICAgZXhwb25lbnQsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIHdpZHRoIGFuZCBwcmVjaXNpb246XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgIC8vdXNlZCBmb3IgaG9sZGluZyB0ZW1wb3JhcnkgdmFsdWVzOlxuICAgICAgICAgIHRtcF9udW0sXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICV7fSBhbmQgJTw+IGZpbGVkczpcbiAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXksXG4gICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlYiwgJUIsICVvLCAleCwgYW5kICVYIGZpZWxkczpcbiAgICAgICAgICBiYXNlX251bWJlcixcbiAgICAgICAgICBiYXNlX3ByZWZpeCxcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICBuZXh0X2FyZyxcbiAgICAgICAgICBzZXFfYXJnX251bSA9IDEsXG4gICAgICAgICAgcG9zX2FyZ19udW0gPSAwLFxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBmbGFnczpcbiAgICAgICAgICBmbGFncyxcbiAgICAgICAgICBGTk9ORSAgPSAwLFxuICAgICAgICAgIEZTSEFSUCA9IDEsXG4gICAgICAgICAgRk1JTlVTID0gMixcbiAgICAgICAgICBGUExVUyAgPSA0LFxuICAgICAgICAgIEZaRVJPICA9IDgsXG4gICAgICAgICAgRlNQQUNFID0gMTYsXG4gICAgICAgICAgRldJRFRIID0gMzIsXG4gICAgICAgICAgRlBSRUMgID0gNjQsXG4gICAgICAgICAgRlBSRUMwID0gMTI4O1xuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfRkxBR1MoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHdpZHRoJ30gfVxuICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnZmxhZyBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9XSURUSCgpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dpZHRoIGdpdmVuIHR3aWNlJ30gfVxuICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd2lkdGggYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTlRIX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKG51bSA+PSBhcmdzLmxlbmd0aCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RvbyBmZXcgYXJndW1lbnRzJ30gfVxuICAgICAgICByZXR1cm4gYXJnc1tudW1dO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTkVYVF9BUkcoKSB7XG4gICAgICAgIHN3aXRjaCAocG9zX2FyZ19udW0pIHtcbiAgICAgICAgY2FzZSAtMTogI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwidW5udW1iZXJlZCgje2BzZXFfYXJnX251bWB9KSBtaXhlZCB3aXRoIG51bWJlcmVkXCJ9IC8vIHJhaXNlXG4gICAgICAgIGNhc2UgLTI6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBuYW1lZFwifSAvLyByYWlzZVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gc2VxX2FyZ19udW0rKztcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKHBvc19hcmdfbnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9QT1NfQVJHKG51bSkge1xuICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibnVtYmVyZWQoI3tgbnVtYH0pIGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0yKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibnVtYmVyZWQoI3tgbnVtYH0pIGFmdGVyIG5hbWVkXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bSA8IDEpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGluZGV4IC0gI3tgbnVtYH0kXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSAtMTtcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKG51bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfQVJHKCkge1xuICAgICAgICByZXR1cm4gKG5leHRfYXJnID09PSB1bmRlZmluZWQgPyBHRVRfTkVYVF9BUkcoKSA6IG5leHRfYXJnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU0obGFiZWwpIHtcbiAgICAgICAgdmFyIG51bSwgc3RyID0gJyc7XG4gICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUqWzAtOV0nfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpIDwgNDggfHwgZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpID4gNTcpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KHN0ciwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAobnVtID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCIje2BsYWJlbGB9IHRvbyBiaWdcIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTV9BRlRFUl9BU1RFUihsYWJlbCkge1xuICAgICAgICB2YXIgYXJnLCBudW0gPSBSRUFEX05VTShsYWJlbCk7XG4gICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBhcmcgPSBHRVRfUE9TX0FSRyhudW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZyA9IEdFVF9ORVhUX0FSRygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BhcmdgLnRvX2ludH07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGZvcm1hdF9zdHJpbmcuaW5kZXhPZignJScpOyBpICE9PSAtMTsgaSA9IGZvcm1hdF9zdHJpbmcuaW5kZXhPZignJScsIGkpKSB7XG4gICAgICAgIHN0ciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmbGFncyA9IEZOT05FO1xuICAgICAgICB3aWR0aCA9IC0xO1xuICAgICAgICBwcmVjaXNpb24gPSAtMTtcbiAgICAgICAgbmV4dF9hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZW5kX3NsaWNlID0gaTtcblxuICAgICAgICBpKys7XG5cbiAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICBiZWdpbl9zbGljZSA9IGk7XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFwwJzpcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXRfc2VxdWVuY2U6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNQQUNFO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTSEFSUDtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGUExVUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlpFUk87XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgIHRtcF9udW0gPSBSRUFEX05VTSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xuICAgICAgICAgICAgICBpZiAoaSArIDIgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHN0ciA9ICclJztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXh0X2FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwidmFsdWUgZ2l2ZW4gdHdpY2UgLSAlI3tgdG1wX251bWB9JFwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5leHRfYXJnID0gR0VUX1BPU19BUkcodG1wX251bSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xuICAgICAgICAgICAgICBmbGFncyB8PSBGV0lEVEg7XG4gICAgICAgICAgICAgIHdpZHRoID0gdG1wX251bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhc2UgJ1xceyc6XG4gICAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIgPSAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICc8JyA/ICc+JyA6ICdcXH0nKTtcbiAgICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSA9ICcnO1xuXG4gICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBuYW1lIC0gdW5tYXRjaGVkIHBhcmVudGhlc2lzJ31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGNsb3NpbmdfYnJhY2VfY2hhcikge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID4gMCkge1xuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJuYW1lZCAje2BoYXNoX3BhcmFtZXRlcl9rZXlgfSBhZnRlciBudW1iZXJlZFwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NfYXJnX251bSA9IC0yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCB8fCAhYXJnc1swXS4kJGlzX2hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnb25lIGhhc2ggcmVxdWlyZWQnfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5leHRfYXJnID0gI3tgYXJnc1swXWAuZmV0Y2goYGhhc2hfcGFyYW1ldGVyX2tleWApfTtcblxuICAgICAgICAgICAgICAgIGlmIChjbG9zaW5nX2JyYWNlX2NoYXIgPT09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSBuZXh0X2FyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSArPSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgd2lkdGggPSBSRUFEX05VTV9BRlRFUl9BU1RFUignd2lkdGgnKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3ByZWNpc2lvbiBnaXZlbiB0d2ljZSd9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGFncyB8PSBGUFJFQ3xGUFJFQzA7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSAwO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnKicpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBwcmVjaXNpb24gPSBSRUFEX05VTV9BRlRFUl9BU1RFUigncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICAgIGlmIChwcmVjaXNpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgJj0gfkZQUkVDO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgYXJnID0gI3s6Oktlcm5lbC5JbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDEpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICAgIGJhc2VfbnVtYmVyID0gMjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMGInO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14xKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnMSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICAgIGJhc2VfbnVtYmVyID0gODtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMCc7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjM/NysvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJzcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgIGJhc2VfbnVtYmVyID0gMTY7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzB4JztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eZisvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJ2YnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZyA9ICN7OjpLZXJuZWwuSW50ZWdlcihgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGFyZy50b1N0cmluZyhiYXNlX251bWJlcik7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApIC0gKChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZyhiYXNlX251bWJlcik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDEgLSAoZmxhZ3MmRlNIQVJQID8gMiA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAoYXJnID4+PiAwKS50b1N0cmluZyhiYXNlX251bWJlcikucmVwbGFjZShiYXNlX25lZ196ZXJvX3JlZ2V4LCBiYXNlX25lZ196ZXJvX2RpZ2l0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbiAtIDIpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICcuLicgKyBzdHI7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMiAtIChmbGFncyZGU0hBUlAgPyBiYXNlX3ByZWZpeC5sZW5ndGggOiAwKSkgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICcuLicgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICcuLicgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgYXJnID0gI3s6Oktlcm5lbC5GbG9hdChgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwIHx8IGlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9GaXhlZChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQoc3RyLnNwbGl0KCdlJylbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBhcmcgIT09IEluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBhcmcgIT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDEpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpLnRvVXBwZXJDYXNlKCkgJiYgYXJnICE9PSBJbmZpbml0eSAmJiBhcmcgIT09IC1JbmZpbml0eSAmJiAhaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oW2VFXVstK10/KShbMC05XSkkLywgJyQxMCQyJyk7XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBiZWNhdXNlIHRoZXJlIGFyZSBubyBzcGVjcyBmb3IgdGhpcyBmaWVsZCB0eXBlLlxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsICdgQWAgYW5kIGBhYCBmb3JtYXQgZmllbGQgdHlwZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCBpbiBPcGFsIHlldCd9XG4gICAgICAgICAgICAvLyByYWlzZVxuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBhcmcgPSBHRVRfQVJHKCk7XG4gICAgICAgICAgICBpZiAoI3tgYXJnYC5yZXNwb25kX3RvPyg6dG9fYXJ5KX0pIHsgYXJnID0gI3tgYXJnYC50b19hcnl9WzBdOyB9XG4gICAgICAgICAgICBpZiAoI3tgYXJnYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICAgICAgc3RyID0gI3tgYXJnYC50b19zdHJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgkY29lcmNlX3RvKGFyZywgI3s6OkludGVnZXJ9LCAndG9faW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICclYyByZXF1aXJlcyBhIGNoYXJhY3Rlcid9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLmluc3BlY3R9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHN0ciA9ICN7YEdFVF9BUkcoKWAudG9fc307XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUje2Bmb3JtYXRfc3RyaW5nLmNoYXJBdChpKWB9XCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UsIGVuZF9zbGljZSkgKyBzdHI7XG4gICAgICAgIGJlZ2luX3NsaWNlID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgjeyRERUJVR30gJiYgcG9zX2FyZ19udW0gPj0gMCAmJiBzZXFfYXJnX251bSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG9vIG1hbnkgYXJndW1lbnRzIGZvciBmb3JtYXQgc3RyaW5nJ31cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3ByaW50ZiBmb3JtYXRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCJmb3JtYXQiLCJmb3JtYXRfc3RyaW5nIiwiYXJncyIsImxlbmd0aCIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCJuaWw/IiwidG9fYSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInRvX2ludCIsImZldGNoIiwiSW50ZWdlciIsIkZsb2F0IiwiTm90SW1wbGVtZW50ZWRFcnJvciIsInRvX2FyeSIsInRvX3N0ciIsImluc3BlY3QiLCJ0b19zIiwiJERFQlVHIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7Ozs7O0FBQ0VDLElBQUFBLHNCQUFBQSxrQkFBV0MsYUFBRCxFQUhaLEVBR0VEO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFIRjtNQUc0QjtNQUN4QixJQUFHLENBQUEsTUFBQUUsSUFBSUMsUUFBQUEsQ0FBQUEsQ0FBSixFQUFlQyxDQUFmLENBQUEsSUFBQSxDQUFBLFFBQW9CRixJQUFJRyxPQUFBQSxDQUFDQyxDQUFERCxDQUFHRSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUEzQixDQUFBLENBQUEsQ0FBSDs7UUFDRUMsTUFBTUMsS0FBTUMsZUFBQUEsQ0FBWVIsSUFBSUcsT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBdEIsRUFBMkJNLFlBQTNCLEVBQW9DLFFBQTlCRDtRQUNaLEtBQUEsUUFBdUJGLEdBQUdJLFNBQUFBLENBQUFBLENBQTFCLENBQUE7VUFBQVYsT0FBT00sR0FBR0ssTUFBQUEsQ0FBQUE7UUFBVjtNQUZGOztBQU1KYjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsNEJB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QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGtCQUFvQmMsT0FBUUssU0FBQUEsQ0FBVW5CLFNBQVZtQixDQUFzQm5CO0FBQ2xEQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CYyxPQUFRTSxPQUFBQSxDQUFRcEIsU0FBUm9CLENBQW9CcEI7QUFDaERBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxZQUFjYyxPQUFRQyxPQUFBQSxDQUFPTSwwQkFBZixFQUFzQ3JCLGdFQUE5QmU7QUFDdEJmOztBQUVBQTtBQUNBQTtBQUNBQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQUtPLGdCQUFBQSxDQUFhLFFBQWJBLENBQXNCUCxVQUFZQSxDQUFDQSxHQUFEQSxDQUFLc0IsUUFBQUEsQ0FBQUEsQ0FBUXRCO0FBQ3RFQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQUtPLGdCQUFBQSxDQUFhLFFBQWJBLENBQXNCUDtBQUM3Q0Esb0JBQXNCQSxDQUFDQSxHQUFEQSxDQUFLdUIsUUFBQUEsQ0FBQUEsQ0FBUXZCO0FBQ25DQTtBQUNBQSx3REFBMERtQixjQUFVbkI7QUFDcEVBO0FBQ0FBO0FBQ0FBLGNBQWdCYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2hCLHlCQUF4QmU7QUFDeEJmO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxrQkFBb0JBLENBQUNBLFNBQURBLENBQVd3QixTQUFBQSxDQUFBQSxDQUFTeEI7QUFDeENBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxrQkFBb0JBLENBQUNBLFNBQURBLENBQVd5QixNQUFBQSxDQUFBQSxDQUFNekI7QUFDckNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxZQUFjYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFpQ2hCLDZCQUFELEdBQUEsQ0FBK0JBLHVCQUEvQixDQUF4QmU7QUFDdEJmO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2hCLDZCQUF4QmU7QUFDcEJmOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUEsVUFBWTBCLFlBQU8xQjtBQUNuQkEsUUFBVWMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NoQixzQ0FBeEJlO0FBQ2xCZjs7QUFFQUE7QUFDQUE7SUE3aEJFQSxDQUFBQSxJQUFBQTtJQWdpQkFELE9BQUEsYUFBTSxTQUFOLEVBQWMsUUFBZDtFQWppQkZBLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjgzMzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL21pbmkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnb3BhbC9iYXNlJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL25pbCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYm9vbGVhbidcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhdG9yJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9hcnJheSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaGFzaCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbnVtYmVyJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yYW5nZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvYydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbWV0aG9kJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3ZhcmlhYmxlcydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaW8nXG46Ok9iamVjdC5yZXF1aXJlICdvcGFsL3JlZ2V4cF9hbmNob3JzJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLE9BQVFDLFNBQUFBLENBQVNGLFdBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGFBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysb0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG9CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixvQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsbUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLFlBQVRFO0VBQ1JGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLHFCQUFURTtBQWpCUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjgzNTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9ydW50aW1lJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9oZWxwZXJzJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2NsYXNzJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9iYXNpY19vYmplY3QnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbWFpbidcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvZXJyb3InXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29uc3RhbnRzJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZUFBVEU7RUFFUkYsT0FBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsbUJBQVRFO0FBVFJGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo4MzczLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9yZWdleHBfYW5jaG9ycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgT3BhbFxuICBzZWxmOjpSRUdFWFBfU1RBUlQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnXicgOiAnXFxBJ1xuICBzZWxmOjpSRUdFWFBfRU5EID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJyQnIDogJ1xceidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDQwICg6Ozw9Pj9AIGNoYXJzKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGJlZ2dpbmluZyBvciBtaWRkbGUgb2YgaXRzIG5hbWVcbiAgc2VsZjo6Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyMCAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UpXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDAzRSAoOjs8PT4gY2hhcnMpXG4gICMgXFx1MDA0MCAgICAgICAgICAoQCBjaGFyKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxuICAjIEluIGZhY3QsIEZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICsgXFx1MDAyMSAoJz8nKSArIFxcdTAwM0YgKCchJylcbiAgc2VsZjo6Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICAgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMi1cXHUwMDJGXFx1MDAzQS1cXHUwMDNFXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIHNlbGY6OklOTElORV9JREVOVElGSUVSX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCJbXiN7c2VsZjo6Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlN9XSpbXiN7c2VsZjo6Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTfV1cIilcblxuICAjIEZvciBjb25zdGFudHMgcnVsZXMgYXJlIHByZXR0eSBtdWNoIHRoZSBzYW1lLCBidXQgJzonIGlzIGFsbG93ZWQgYW5kICc/IScgYXJlIG5vdC5cbiAgIyBQbHVzIGl0IG1heSBzdGFydCB3aXRoIGEgJzo6JyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29uc3RhbnQgY29tZXMgZnJvbSB0b3BsZXZlbC5cbiAgc2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIHNlbGY6OkNPTlNUX05BTUVfUkVHRVhQID0gUmVnZXhwLm5ldyhcIiN7c2VsZjo6UkVHRVhQX1NUQVJUfSg6Oik/W0EtWl1bXiN7c2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlN9XSoje3NlbGY6OlJFR0VYUF9FTkR9XCIpXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsInNlbGYiLCJSZWdleHAiLCJuZXciLCJzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyIsInNlbGY6OkZPUkJJRERFTl9FTkRJTkdfSURFTlRJRklFUl9DSEFSUyIsInNlbGY6OlJFR0VYUF9TVEFSVCIsInNlbGY6OkZPUkJJRERFTl9DT05TVF9OQU1FX0NIQVJTIiwic2VsZjo6UkVHRVhQX0VORCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0UsV0FBQUMsSUFBQSxrQkFBNkNELEdBQTdDO0lBQ0EsV0FBQUMsSUFBQSxnQkFBMkNELEdBQTNDO0lBU0EsV0FBQUMsSUFBQSx5Q0FBNENELHFFQUE1QztJQVlBLFdBQUFDLElBQUEsdUNBQTRDRCwyRkFBNUM7SUFDQSxXQUFBQyxJQUFBLDhCQUFpQ0MsWUFBTUMsS0FBQUEsQ0FBTUgsSUFBRCxHQUFBLENBQUtJLElBQUFILElBQUFHLHdDQUFMLENBQUEsR0FBK0NKLE1BQS9DLEdBQUEsQ0FBcURLLElBQUFKLElBQUFJLHNDQUFyRCxDQUFBLEdBQTZGTCxHQUFsR0csQ0FBdkM7SUFJQSxXQUFBRixJQUFBLGdDQUFtQ0QsMkZBQW5DO0lBQ0FBLE9BQUEsV0FBQUMsSUFBQSx1QkFBMEJDLFlBQU1DLEtBQUFBLENBQUssRUFBQSxHQUFBLENBQUdHLElBQUFMLElBQUFLLGlCQUFILENBQUEsR0FBc0JOLGNBQXRCLEdBQUEsQ0FBb0NPLElBQUFOLElBQUFNLCtCQUFwQyxDQUFBLEdBQXFFUCxJQUFyRSxHQUFBLENBQXlFUSxJQUFBUCxJQUFBTyxlQUF6RSxDQUFMTCxDQUFoQztFQTdCRkgsR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjgzOTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3ZhcmlhYmxlcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHJlZ2V4cCBtYXRjaGVzXG4leHskZ3ZhcnNbJyYnXSA9ICRndmFyc1snfiddID0gJGd2YXJzWydgJ10gPSAkZ3ZhcnNbXCInXCJdID0gbmlsfVxuXG4jIHJlcXVpcmVzXG4kTE9BREVEX0ZFQVRVUkVTID0gJFwiID0gYE9wYWwubG9hZGVkX2ZlYXR1cmVzYFxuJExPQURfUEFUSCAgICAgICA9ICQ6ID0gW11cblxuIyBzcGxpdCBsaW5lc1xuJC8gPSBcIlxcblwiXG4kLCA9IG5pbFxuXG46OkFSR1YgPSBbXVxuOjpBUkdGID0gOjpPYmplY3QubmV3XG46OkVOViAgPSB7fVxuXG4kVkVSQk9TRSA9IGZhbHNlXG4kREVCVUcgICA9IGZhbHNlXG4kU0FGRSAgICA9IDBcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiJExPQURFRF9GRUFUVVJFUyIsIiRcIiIsIiRMT0FEX1BBVEgiLCIkOiIsIiQvIiwiJCwiLCJPYmplY3QiLCJuZXciLCIkVkVSQk9TRSIsIiRERUJVRyIsIiRTQUZFIiwiMCJdLCJtYXBwaW5ncyI6IkFBQUFBLG9DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUNHQTtFQUdIQyx5QkFBbUJDLENBQUFBLGVBQU1GLG9CQUFORTtFQUNuQkMsbUJBQW1CQyxDQUFBQSxjQUFLLEVBQUxBO0VBR25CQyxjQUFLTDtFQUNMTSxjQUFLO0VBRUwsV0FBQSxJQUFBLFVBQVMsRUFBVDtFQUNBLFdBQUEsSUFBQSxVQUFTQyxPQUFRQyxLQUFBQSxDQUFBQSxDQUFqQjtFQUNBLFdBQUEsSUFBQSxTQUFTLFlBQUEsRUFBVDtFQUVBQyxpQkFBVztFQUNYQyxlQUFXO0VBQ1hWLE9BQUFXLENBQUFBLGNBQVdDLENBQVhEO0FBakJBWDsifX0seyJvZmZzZXQiOnsibGluZSI6ODQxMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBUaGlzIGlzIGJhc2VkIG9uIGFuIGFkYXB0YXRpb24gb2YgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSdzIGNvZGVcbiMgZG9uZSBieSBTZWFuIE1jQ3VsbG91Z2ggPGJhbmtzZWFuQGdtYWlsLmNvbT4gYW5kIERhdmUgSGVpdHptYW5cbiMgPGRhdmVoZWl0em1hbkB5YWhvby5jb20+LCBzdWJzZXF1ZW50bHkgcmVhZGFwdGVkIGZyb20gYW4gdXBkYXRlZCB2ZXJzaW9uIG9mXG4jIHJ1YnkncyByYW5kb20uYyAocmV2IGMzOGExODMwMzJhNzgyNmRmMWFkYWJkOGFhMDcyNWM3MTNkNTNlMWMpLlxuI1xuIyBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmcm9tIHJhbmRvbS5jIGZvbGxvd3MuXG4jXG4jICAgVGhpcyBpcyBiYXNlZCBvbiB0cmltbWVkIHZlcnNpb24gb2YgTVQxOTkzNy4gIFRvIGdldCB0aGUgb3JpZ2luYWwgdmVyc2lvbixcbiMgICBjb250YWN0IDxodHRwOi8vd3d3Lm1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwL35tLW1hdC9NVC9lbXQuaHRtbD4uXG4jXG4jICAgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZm9sbG93cy5cbiNcbiMgICAgICBBIEMtcHJvZ3JhbSBmb3IgTVQxOTkzNywgd2l0aCBpbml0aWFsaXphdGlvbiBpbXByb3ZlZCAyMDAyLzIvMTAuXG4jICAgICAgQ29kZWQgYnkgVGFrdWppIE5pc2hpbXVyYSBhbmQgTWFrb3RvIE1hdHN1bW90by5cbiMgICAgICBUaGlzIGlzIGEgZmFzdGVyIHZlcnNpb24gYnkgdGFraW5nIFNoYXduIENva3VzJ3Mgb3B0aW1pemF0aW9uLFxuIyAgICAgIE1hdHRoZSBCZWxsZXcncyBzaW1wbGlmaWNhdGlvbiwgSXNha3UgV2FkYSdzIHJlYWwgdmVyc2lvbi5cbiNcbiMgICAgICBCZWZvcmUgdXNpbmcsIGluaXRpYWxpemUgdGhlIHN0YXRlIGJ5IHVzaW5nIGluaXRfZ2VucmFuZChtdCwgc2VlZClcbiMgICAgICBvciBpbml0X2J5X2FycmF5KG10LCBpbml0X2tleSwga2V5X2xlbmd0aCkuXG4jXG4jICAgICAgQ29weXJpZ2h0IChDKSAxOTk3IC0gMjAwMiwgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSxcbiMgICAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuI1xuIyAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIyAgICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuIyAgICAgIGFyZSBtZXQ6XG4jXG4jICAgICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuIyAgICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuI1xuIyAgICAgICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiMgICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4jXG4jICAgICAgICAzLiBUaGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlXG4jICAgICAgICAgICBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW5cbiMgICAgICAgICAgIHBlcm1pc3Npb24uXG4jXG4jICAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuIyAgICAgIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiMgICAgICBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiMgICAgICBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcbiMgICAgICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiMgICAgICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4jICAgICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4jICAgICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuIyAgICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4jICAgICAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4jICAgICAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4jXG4jXG4jICAgICAgQW55IGZlZWRiYWNrIGlzIHZlcnkgd2VsY29tZS5cbiMgICAgICBodHRwOi8vd3d3Lm1hdGgua2Vpby5hYy5qcC9tYXR1bW90by9lbXQuaHRtbFxuIyAgICAgIGVtYWlsOiBtYXR1bW90b0BtYXRoLmtlaW8uYWMuanBcbm1lcnNlbm5lX3R3aXN0ZXIgPSAleHsoZnVuY3Rpb24oKSB7XG4gIC8qIFBlcmlvZCBwYXJhbWV0ZXJzICovXG4gIHZhciBOID0gNjI0O1xuICB2YXIgTSA9IDM5NztcbiAgdmFyIE1BVFJJWF9BID0gMHg5OTA4YjBkZjsgICAgICAvKiBjb25zdGFudCB2ZWN0b3IgYSAqL1xuICB2YXIgVU1BU0sgPSAweDgwMDAwMDAwOyAgICAgICAgIC8qIG1vc3Qgc2lnbmlmaWNhbnQgdy1yIGJpdHMgKi9cbiAgdmFyIExNQVNLID0gMHg3ZmZmZmZmZjsgICAgICAgICAvKiBsZWFzdCBzaWduaWZpY2FudCByIGJpdHMgKi9cbiAgdmFyIE1JWEJJVFMgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuICggKCh1KSAmIFVNQVNLKSB8ICgodikgJiBMTUFTSykgKTsgfTtcbiAgdmFyIFRXSVNUID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoTUlYQklUUygodSksKHYpKSA+Pj4gMSkgXiAoKHYgJiAweDEpID8gTUFUUklYX0EgOiAweDApOyB9O1xuXG4gIGZ1bmN0aW9uIGluaXQocykge1xuICAgIHZhciBtdCA9IHtsZWZ0OiAwLCBuZXh0OiBOLCBzdGF0ZTogbmV3IEFycmF5KE4pfTtcbiAgICBpbml0X2dlbnJhbmQobXQsIHMpO1xuICAgIHJldHVybiBtdDtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemVzIG10W05dIHdpdGggYSBzZWVkICovXG4gIGZ1bmN0aW9uIGluaXRfZ2VucmFuZChtdCwgcykge1xuICAgIHZhciBqLCBpO1xuICAgIG10LnN0YXRlWzBdID0gcyA+Pj4gMDtcbiAgICBmb3IgKGo9MTsgajxOOyBqKyspIHtcbiAgICAgIG10LnN0YXRlW2pdID0gKDE4MTI0MzMyNTMgKiAoKG10LnN0YXRlW2otMV0gXiAobXQuc3RhdGVbai0xXSA+PiAzMCkgPj4+IDApKSArIGopO1xuICAgICAgLyogU2VlIEtudXRoIFRBT0NQIFZvbDIuIDNyZCBFZC4gUC4xMDYgZm9yIG11bHRpcGxpZXIuICovXG4gICAgICAvKiBJbiB0aGUgcHJldmlvdXMgdmVyc2lvbnMsIE1TQnMgb2YgdGhlIHNlZWQgYWZmZWN0ICAgKi9cbiAgICAgIC8qIG9ubHkgTVNCcyBvZiB0aGUgYXJyYXkgc3RhdGVbXS4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgLyogMjAwMi8wMS8wOSBtb2RpZmllZCBieSBNYWtvdG8gTWF0c3Vtb3RvICAgICAgICAgICAgICovXG4gICAgICBtdC5zdGF0ZVtqXSAmPSAweGZmZmZmZmZmOyAgLyogZm9yID4zMiBiaXQgbWFjaGluZXMgKi9cbiAgICB9XG4gICAgbXQubGVmdCA9IDE7XG4gICAgbXQubmV4dCA9IE47XG4gIH1cblxuICAvKiBnZW5lcmF0ZSBOIHdvcmRzIGF0IG9uZSB0aW1lICovXG4gIGZ1bmN0aW9uIG5leHRfc3RhdGUobXQpIHtcbiAgICB2YXIgcCA9IDAsIF9wID0gbXQuc3RhdGU7XG4gICAgdmFyIGo7XG5cbiAgICBtdC5sZWZ0ID0gTjtcbiAgICBtdC5uZXh0ID0gMDtcblxuICAgIGZvciAoaj1OLU0rMTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIGZvciAoaj1NOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFswXSk7XG4gIH1cblxuICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDB4ZmZmZmZmZmZdLWludGVydmFsICovXG4gIGZ1bmN0aW9uIGdlbnJhbmRfaW50MzIobXQpIHtcbiAgICAvKiBtdCBtdXN0IGJlIGluaXRpYWxpemVkICovXG4gICAgdmFyIHk7XG5cbiAgICBpZiAoLS1tdC5sZWZ0IDw9IDApIG5leHRfc3RhdGUobXQpO1xuICAgIHkgPSBtdC5zdGF0ZVttdC5uZXh0KytdO1xuXG4gICAgLyogVGVtcGVyaW5nICovXG4gICAgeSBePSAoeSA+Pj4gMTEpO1xuICAgIHkgXj0gKHkgPDwgNykgJiAweDlkMmM1NjgwO1xuICAgIHkgXj0gKHkgPDwgMTUpICYgMHhlZmM2MDAwMDtcbiAgICB5IF49ICh5ID4+PiAxOCk7XG5cbiAgICByZXR1cm4geSA+Pj4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpIHtcbiAgICBhID4+Pj0gNTtcbiAgICBiID4+Pj0gNjtcbiAgICByZXR1cm4oYSo2NzEwODg2NC4wK2IpKigxLjAvOTAwNzE5OTI1NDc0MDk5Mi4wKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMSkgd2l0aCA1My1iaXQgcmVzb2x1dGlvblxuICBmdW5jdGlvbiBnZW5yYW5kX3JlYWwobXQpIHtcbiAgICAvKiBtdCBtdXN0IGJlIGluaXRpYWxpemVkICovXG4gICAgdmFyIGEgPSBnZW5yYW5kX2ludDMyKG10KSwgYiA9IGdlbnJhbmRfaW50MzIobXQpO1xuICAgIHJldHVybiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKTtcbiAgfVxuXG4gIHJldHVybiB7IGdlbnJhbmRfcmVhbDogZ2VucmFuZF9yZWFsLCBpbml0OiBpbml0IH07XG59KSgpfVxuXG5jbGFzcyA6OlJhbmRvbVxuICBgdmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxYFxuXG4gIHNlbGY6Ok1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SID0gYHtcbiAgICBuZXdfc2VlZDogZnVuY3Rpb24oKSB7IHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNQVhfSU5UKTsgfSxcbiAgICByZXNlZWQ6IGZ1bmN0aW9uKHNlZWQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuaW5pdChzZWVkKTsgfSxcbiAgICByYW5kOiBmdW5jdGlvbihtdCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5nZW5yYW5kX3JlYWwobXQpOyB9XG4gIH1gXG5cbiAgc2VsZi5nZW5lcmF0b3IgPSBzZWxmOjpNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUlxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIm1lcnNlbm5lX3R3aXN0ZXIiLCI8Y2xhc3M6UmFuZG9tPiIsInNlbGYiLCJnZW5lcmF0b3I9Iiwic2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IiXSwibWFwcGluZ3MiOiJBQUFBQSxrREFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFzREFDLG1CQUFzQkQ7QUFDdEJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7RUFFQUEsT0FBQUU7RUFBQUE7O0lBQUFBOzs7SUFDR0E7SUFFRCxXQUFBQyxJQUFBLGdDQUFvQ0Q7QUFDdENBO0FBQ0FBO0FBQ0FBO0FBQ0FBLEdBSkU7SUFNQUEsT0FBSUUsTUFBQUEsQ0FBYUMsSUFBQUYsSUFBQUUsK0JBQWJELENBQUFBLEVBQUFBLE1BQUpELElBQUlDLGNBQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO0VBVE5GLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUF4SUFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo4NTEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20vZm9ybWF0dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6UmFuZG9tXG4gIG1vZHVsZSBzZWxmOjpGb3JtYXR0ZXJcbiAgICBkZWYgaGV4KGNvdW50ID0gbmlsKVxuICAgICAgY291bnQgPSA6OlJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgOjpCYXNlNjQuc3RyaWN0X2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCkpLmVuY29kZSgnVVMtQVNDSUknKVxuICAgIGVuZFxuXG4gICAgZGVmIHVybHNhZmVfYmFzZTY0KGNvdW50ID0gbmlsLCBwYWRkaW5nID0gZmFsc2UpXG4gICAgICA6OkJhc2U2NC51cmxzYWZlX2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCksIHBhZGRpbmcpLmVuY29kZSgnVVMtQVNDSUknKVxuICAgIGVuZFxuXG4gICAgZGVmIHV1aWRcbiAgICAgIHN0ciA9IGhleCgxNikuc3BsaXQoJycpXG4gICAgICBzdHJbMTJdID0gJzQnXG4gICAgICBzdHJbMTZdID0gYChwYXJzZUludCgje3N0clsxNl19LCAxNikgJiAzIHwgOCkudG9TdHJpbmcoMTYpYFxuICAgICAgc3RyID0gW3N0clswLi4uOF0sIHN0cls4Li4uMTJdLCBzdHJbMTIuLi4xNl0sIHN0clsxNi4uLjIwXSwgc3RyWzIwLi4uMzJdXVxuICAgICAgc3RyID0gc3RyLm1hcCgmOmpvaW4pXG4gICAgICBzdHIuam9pbignLScpXG4gICAgZW5kXG5cbiAgICAjIEltcGxlbWVudGVkIGluIHRlcm1zIG9mIGAjYnl0ZXNgIGZvciBTZWN1cmVSYW5kb20sIGJ1dCBSYW5kb20gb3ZlcnJpZGVzIHRoaXNcbiAgICAjIG1ldGhvZCB0byBpbXBsZW1lbnQgYCNieXRlc2AgaW4gdGVybXMgb2YgYCNyYW5kb21fZmxvYXRgLiBOb3QgcGFydCBvZiBzdGFuZGFyZFxuICAgICMgUnVieSBpbnRlcmZhY2UgLSB1c2UgcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkuXG4gICAgZGVmIHJhbmRvbV9mbG9hdFxuICAgICAgYnMgPSBieXRlcyg0KVxuICAgICAgbnVtID0gMFxuICAgICAgNC50aW1lcyBkbyB8aXxcbiAgICAgICAgbnVtIDw8PSA4XG4gICAgICAgIG51bSB8PSBic1tpXS5vcmRcbiAgICAgIGVuZFxuICAgICAgbnVtLmFicyAvIDB4N2ZmZmZmZmZcbiAgICBlbmRcblxuICAgIGRlZiByYW5kb21fbnVtYmVyKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUZsb2F0KCkge1xuICAgICAgICAgIHJldHVybiAje3JhbmRvbV9mbG9hdH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5kb21JbnQobWF4KSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tRmxvYXQoKSAqIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5kb21SYW5nZSgpIHtcbiAgICAgICAgICB2YXIgbWluID0gbGltaXQuYmVnaW4sXG4gICAgICAgICAgICAgIG1heCA9IGxpbWl0LmVuZDtcblxuICAgICAgICAgIGlmIChtaW4gPT09IG5pbCB8fCBtYXggPT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gbWF4IC0gbWluO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4ICUgMSA9PT0gMCAmJiBtaW4gJSAxID09PSAwICYmICFsaW1pdC5leGNsKSB7XG4gICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxlbmd0aCkgKyBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tUmFuZ2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgOjpBcnJheS5uZXcoY291bnQpIGRvIHxpfFxuICAgICAgICBtYXBbcmFuZG9tX251bWJlcihtYXAubGVuZ3RoKV1cbiAgICAgIGVuZC5qb2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgOjpSYW5kb206OkZvcm1hdHRlclxuICBleHRlbmQgOjpSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSYW5kb20+IiwiPG1vZHVsZTpzZWxmOjpGb3JtYXR0ZXI+IiwiaGV4IiwiY291bnQiLCJSYW5kb20iLCJfdmVyaWZ5X2NvdW50Iiwic2VsZiIsImJ5dGVzIiwiZW5jb2RlIiwicmFuZG9tX2J5dGVzIiwiYmFzZTY0IiwiQmFzZTY0Iiwic3RyaWN0X2VuY29kZTY0IiwidXJsc2FmZV9iYXNlNjQiLCJwYWRkaW5nIiwidXJsc2FmZV9lbmNvZGU2NCIsInV1aWQiLCJzdHIiLCIxNiIsInNwbGl0IiwiW109IiwiMTIiLCJbXSIsIjAiLCI4IiwiMjAiLCIzMiIsIm1hcCIsInRvX3Byb2MiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCJibG9jayBpbiByYW5kb21fZmxvYXQiLCJpIiwiPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIHJhbmRvbV9mbG9hdCIsInwiLCJvcmQiLCIvIiwiYWJzIiwiMjE0NzQ4MzY0NyIsInJhbmRvbV9udW1iZXIiLCJsaW1pdCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImFscGhhbnVtZXJpYyIsImZsYXR0ZW4iLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGFscGhhbnVtZXJpYyIsImJsb2NrICgyIGxldmVscykgaW4gYWxwaGFudW1lcmljIiwibGVuZ3RoIiwiaW5jbHVkZSIsIlJhbmRvbTo6Rm9ybWF0dGVyIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUM7SUFBQUE7O01BQUFBOzs7O0FBQ0VDLE1BQUFBLG1CQUFBQSxlQUFRQyxLQUFSRDtBQUFBQSxRQUFBQTs7O1FBQVEsMkJBQVE7UUFDZEMsUUFBUUMsYUFBUUMsZUFBQUEsQ0FBZUYsS0FBZkU7O0FBRXRCSCxvQkFBc0JJLElBQUFDLE9BQUFBLENBQU1KLEtBQU5JLENBQWFMO0FBQ25DQTtBQUNBQSw0QkFBOEJDLEtBQU1EO0FBQ3BDQTtBQUNBQTtBQUNBQSxlQUFpQkEsQ0FBQ0EsR0FBREEsQ0FBS00sUUFBQUEsQ0FBUU4sVUFBUk0sQ0FBb0JOO0FBQzFDQTtNQVRJQSxDQUFBQSxJQUFBQTs7QUFZQU8sTUFBQUEsNEJBQUFBLHdCQUFpQk4sS0FBakJNO0FBQUFBLFFBQUFBOzs7UUFBaUIsMkJBQVE7UUFDdkJBLE9BQUFILElBQUFDLE9BQUFBLENBQU1KLEtBQU5JO01BREZFLENBQUFBLElBQUFBOztBQUlBQyxNQUFBQSxzQkFBQUEsa0JBQVdQLEtBQVhPO0FBQUFBLFFBQUFBOzs7UUFBVywyQkFBUTtRQUNqQkEsT0FBQUMsYUFBUUMsaUJBQUFBLENBQWlCTixJQUFBRyxjQUFBQSxDQUFhTixLQUFiTSxDQUFqQkcsQ0FBcUNKLFFBQUFBLENBQVFFLFVBQVJGO01BRC9DRSxDQUFBQSxJQUFBQTs7QUFJQUcsTUFBQUEsOEJBQUFBLDBCQUFtQlYsS0FBRCxFQUFjVyxPQUFoQ0Q7QUFBQUEsUUFBQUE7OztRQUFtQiwyQkFBUTtRQUFLLCtCQUFVO1FBQ3hDQSxPQUFBRixhQUFRSSxrQkFBQUEsQ0FBa0JULElBQUFHLGNBQUFBLENBQWFOLEtBQWJNLENBQTFCLEVBQStDSyxPQUF2Q0MsQ0FBK0NQLFFBQUFBLENBQVFLLFVBQVJMO01BRHpESyxDQUFBQSxJQUFBQTs7QUFJQUcsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7O1FBQ0VDLE1BQU1YLElBQUFKLEtBQUFBLENBQUlnQixFQUFKaEIsQ0FBT2lCLE9BQUFBLENBQU9ILEVBQVBHO1FBQ2JGLEdBQUdHLFFBQUFBLENBQUNDLEVBQUosRUFBVUwsR0FBUEk7UUFDSEgsR0FBR0csUUFBQUEsQ0FBQ0YsRUFBSixFQUFXRixVQUFZQyxHQUFHSyxPQUFBQSxDQUFDSixFQUFESSxDQUFLTiwyQkFBNUJJO1FBQ0hILE1BQU0sQ0FBQ0EsR0FBR0ssT0FBQUEsQ0FBQyxPQUFBQyxDQUFBLEVBQUlDLENBQUosT0FBREYsQ0FBSixFQUFhTCxHQUFHSyxPQUFBQSxDQUFDLE9BQUFFLENBQUEsRUFBSUgsRUFBSixPQUFEQyxDQUFoQixFQUEwQkwsR0FBR0ssT0FBQUEsQ0FBQyxPQUFBRCxFQUFBLEVBQUtILEVBQUwsT0FBREksQ0FBN0IsRUFBd0NMLEdBQUdLLE9BQUFBLENBQUMsT0FBQUosRUFBQSxFQUFLTyxFQUFMLE9BQURILENBQTNDLEVBQXNETCxHQUFHSyxPQUFBQSxDQUFDLE9BQUFHLEVBQUEsRUFBS0MsRUFBTCxPQUFESixDQUF6RDtRQUNOTCxNQUFTVSxNQUFIVixHQUFHVSxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLE1BQURDLFNBQUFBLENBQUFBLENBQUxEO1FBQ1RYLE9BQUFDLEdBQUdZLE1BQUFBLENBQU1iLEdBQU5hO01BTkxiLENBQUFBLEdBQUFBOztBQVlBYyxNQUFBQSw0QkFBQUEsd0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRUMsS0FBS3pCLElBQUFDLE9BQUFBLENBQU15QixDQUFOekI7UUFDTDBCLE1BQU1WO1FBQ0xXLE1BQURGLENBQUFBLENBQUFBLENBQUNFLFNBQUFBLEVBQUFBLEVBQUFBLEVBQURDLGFBQVlDLENBQVpEOztVQUFZO1VBQ1ZGLE1BQUFBLEdBQUlJLE9BQUFBLENBQUliLENBQUphO1VBQ0pDLE9BQUFMLENBQUFBLE1BQUFBLEdBQUlNLE1BQUFBLENBQUdSLEVBQUVULE9BQUFBLENBQUNjLENBQURkLENBQUdrQixLQUFBQSxDQUFBQSxDQUFSRCxDQUFKTixFQUZGRSxDQUFBQSxHQUFDRDtRQUlESixPQUFRVyxXQUFSUixHQUFHUyxLQUFBQSxDQUFBQSxDQUFLRCxFQUFFRSxVQUFGRjtNQVBWWCxDQUFBQSxHQUFBQTs7QUFVQWMsTUFBQUEsNkJBQUFBLHlCQUFrQkMsS0FBbEJEO0FBQUFBLFFBQUFBOzs7OztBQUVKQTtBQUNBQSxpQkFBbUJ0QyxJQUFBd0IsY0FBQUEsQ0FBQUEsQ0FBYWM7QUFDaENBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFlBQWNFLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDSixxQkFBRCxHQUFBLENBQXNCQyxLQUF0QixDQUF4QkU7QUFDdEJIOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxrQkFBb0JLLEtBQU1DLGVBQUFBLENBQVlMLEtBQWxCLEVBQXlCTSxjQUF6QixFQUFvQyxRQUE5QkQsQ0FBdUNOOztBQUVqRUE7QUFDQUEsWUFBY0UsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUNKLHFCQUFELEdBQUEsQ0FBc0JDLEtBQXRCLENBQXhCRTtBQUN0Qkg7O0FBRUFBO0FBQ0FBO0FBQ0FBO01BM0RJQSxDQUFBQSxJQUFBQTtNQThEQTNDLE9BQUFtRCw0QkFBQUEsd0JBQWlCakQsS0FBakJpRDtBQUFBQSxRQUFBQTs7O1FBQWlCLDJCQUFRO1FBQ3ZCakQsUUFBUUMsWUFBTUMsZUFBQUEsQ0FBZUYsS0FBZkU7UUFDZHNCLE1BQW9DQSxNQUE5QixDQUFDLE9BQUF5QixHQUFBLEVBQUtBLEdBQUwsUUFBRCxFQUFXLE9BQUFBLEdBQUEsRUFBS0EsR0FBTCxRQUFYLEVBQXFCLE9BQUFBLEdBQUEsRUFBS0EsR0FBTCxRQUFyQixDQUE4QnpCLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sTUFBREMsU0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBWTBCLFNBQUFBLENBQUFBO1FBQ2hERCxPQUFPRSxNQUFQQyxZQUFPRCxPQUFBQSxFQUFBQSxDQUFLbkQsS0FBTG1ELENBQUFBLEVBQVBFLGFBQXVCcEIsQ0FBdkJvQixFQUFBQzs7O1VBQXVCO1VBQ3JCQSxPQUFBOUIsR0FBR0wsT0FBQUEsQ0FBQ2hCLElBQUFzQyxlQUFBQSxDQUFjakIsR0FBRytCLFFBQUFBLENBQUFBLENBQWpCZCxDQUFEdEIsRUFETGtDLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFPRixDQUVKekIsTUFBQUEsQ0FBQUE7TUFMTHVCLENBQUFBLElBQUFBO0lBN0dGbkQsR0FBT0ssSUFBUEw7SUFzSEFLLElBQUFxRCxTQUFBQSxDQUFRQyxJQUFBeEQsYUFBQXdELGNBQVJEO0lBQ0EzRCxPQUFBTSxJQUFBdUQsUUFBQUEsQ0FBT0QsSUFBQXhELGFBQUF3RCxjQUFQQztFQXhIRjdELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjg2ODEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZVxuXG5jbGFzcyA6OlByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfcHJvYycsIHRydWUpYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2xhbWJkYScsIGZhbHNlKWBcblxuICBkZWYgc2VsZi5uZXcoJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrLCAkcmV0ID0gc2VsZi4kJHJldDtcblxuICAgICAgaWYgKCRicmsgfHwgKCRyZXQgJiYgc2VsZi4kJGlzX2xhbWJkYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPcGFsLnlpZWxkWChzZWxmLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgPT09ICRicmspIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNlbGYuJCRpc19sYW1iZGEgJiYgZXJyID09PSAkcmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyLiR2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgb3RoZXIuY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gb3RoZXIuY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBgc2VsZi4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgbmlsXG4gIGVuZFxuXG4gIGRlZiBiaW5kaW5nXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuXG4gICAgaWYgZGVmaW5lZD8gOjpCaW5kaW5nXG4gICAgICA6OkJpbmRpbmcubmV3KG5pbCwgW10sIGBzZWxmLiQkc2AsIHNvdXJjZV9sb2NhdGlvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gI3tbWzpyZXN0XV19O1xuICAgICAgfSBlbHNlIGlmIChzZWxmLiQkcGFyYW1ldGVycykge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkcGFyYW1ldGVycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGksIGxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYuJCRwYXJhbWV0ZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gc2VsZi4kJHBhcmFtZXRlcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJbMF0gPT09ICdyZXEnKSB7XG4gICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGFyZ3VtZW50cyBhbHdheXMgaGF2ZSBuYW1lXG4gICAgICAgICAgICAgIHBhcmFtZXRlciA9IFsnb3B0JywgcGFyYW1ldGVyWzFdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW1ldGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY3VycnkoYXJpdHkgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcml0eSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFyaXR5ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShhcml0eSwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhICYmIGFyaXR5ICE9PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyaXR5YH0gZm9yICN7YHNlbGYubGVuZ3RoYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3VycmllZCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChsZW5ndGggPiBhcml0eSAmJiBzZWxmLiQkaXNfbGFtYmRhICYmICFzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyA9PT0gY2FsbFxuICBhbGlhcyBjbG9uZSBkdXBcbiAgYWxpYXMgeWllbGQgY2FsbFxuICBhbGlhcyBbXSBjYWxsXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlByb2M+IiwibmV3Iiwic2VsZiIsImJsb2NrIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiY2FsbCIsIj4+Iiwib3RoZXIiLCJwcm9jIiwiYmxvY2sgaW4gPj4iLCJibG9jayAoMiBsZXZlbHMpIGluID4+Iiwib3V0IiwiYXJncyIsInRvX3Byb2MiLCI8PCIsImJsb2NrIGluIDw8IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8PCIsImxhbWJkYT8iLCJhcml0eSIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsImJpbmRpbmciLCJCaW5kaW5nIiwicGFyYW1ldGVycyIsImN1cnJ5IiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiZHVwIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7Ozs7SUFDR0E7SUFDQUE7SUFFREMsTUFBSUMsSUFBSkQsVUFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0UsS0FBQSxRQUFPRSxLQUFQLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYs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eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JlZ2V4cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90bywgcHJvcCwgZnJlZXplXG5cbmNsYXNzIDo6UmVnZXhwRXJyb3IgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuXG5jbGFzcyA6OlJlZ2V4cCA8IGBSZWdFeHBgXG4gIHNlbGY6OklHTk9SRUNBU0UgPSAxXG4gIHNlbGY6OkVYVEVOREVEID0gMlxuICBzZWxmOjpNVUxUSUxJTkUgPSA0XG5cbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19yZWdleHAnLCB0cnVlKWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICBhbGxvY2F0ZWQgPSBzdXBlclxuICAgICAgYCN7YWxsb2NhdGVkfS51bmluaXRpYWxpemVkID0gdHJ1ZWBcbiAgICAgIGFsbG9jYXRlZFxuICAgIGVuZFxuXG4gICAgZGVmIGVzY2FwZShzdHJpbmcpXG4gICAgICBgT3BhbC5lc2NhcGVfcmVnZXhwKHN0cmluZylgXG4gICAgZW5kXG5cbiAgICBkZWYgbGFzdF9tYXRjaChuID0gbmlsKVxuICAgICAgaWYgbi5uaWw/XG4gICAgICAgICR+XG4gICAgICBlbHNpZiAkflxuICAgICAgICAkfltuXVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdW5pb24oKnBhcnRzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBpc19maXJzdF9wYXJ0X2FycmF5LCBxdW90ZWRfdmFsaWRhdGVkLCBwYXJ0LCBvcHRpb25zLCBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIC8oPyEpLztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZmFzdCBpZiB0aGVyZSdzIG9ubHkgb25lIGVsZW1lbnRcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAxICYmIHBhcnRzWzBdLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdmVyIHRoZSAyIGFycmF5cyBwYXNzZWQgYXMgYXJndW1lbnRzIGNhc2VcbiAgICAgICAgaXNfZmlyc3RfcGFydF9hcnJheSA9IHBhcnRzWzBdLiQkaXNfYXJyYXk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBBcnJheSBpbnRvIFN0cmluZyd9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVhbCB3aXRoIHNwbGF0IGlzc3VlcyAocmVsYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BhbC9vcGFsL2lzc3Vlcy84NTgpXG4gICAgICAgIGlmIChpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgcGFydHMgPSBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICBxdW90ZWRfdmFsaWRhdGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgIGlmIChwYXJ0LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goI3tlc2NhcGUoYHBhcnRgKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwYXJ0LiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgICBlYWNoX3BhcnRfb3B0aW9ucyA9ICN7YHBhcnRgLm9wdGlvbnN9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMgIT0gZWFjaF9wYXJ0X29wdGlvbnMpIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ0FsbCBleHByZXNzaW9ucyBtdXN0IHVzZSB0aGUgc2FtZSBvcHRpb25zJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgnKCcrcGFydC5zb3VyY2UrJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goI3tlc2NhcGUoYHBhcnRgLnRvX3N0cil9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICMgVGFrZSBhZHZhbnRhZ2Ugb2YgbG9naWMgdGhhdCBjYW4gcGFyc2Ugb3B0aW9ucyBmcm9tIEpTIFJlZ2V4XG4gICAgICBuZXcoYHF1b3RlZF92YWxpZGF0ZWRgLmpvaW4oJ3wnKSwgYG9wdGlvbnNgKVxuICAgIGVuZFxuXG4gICAgZGVmIG5ldyhyZWdleHAsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKHJlZ2V4cC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdleHAgPSAjezo6T3BhbC5jb2VyY2VfdG8hKHJlZ2V4cCwgOjpTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICBpZiAocmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMSkgPT09ICdcXFxcJyAmJiByZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAyKSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJlZ2V4cEVycm9yLCBcInRvbyBzaG9ydCBlc2NhcGUgc2VxdWVuY2U6IC8je3JlZ2V4cH0vXCJ9XG4gICAgICAgIH1cblxuICAgICAgICByZWdleHAgPSByZWdleHAucmVwbGFjZSgnXFxcXEEnLCAnXicpLnJlcGxhY2UoJ1xcXFx6JywgJyQnKVxuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgI3shb3B0aW9uc30pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xuICAgICAgICAgIGlmICgje0lHTk9SRUNBU0V9ICYgb3B0aW9ucykgeyB0ZW1wICs9ICdpJzsgfVxuICAgICAgICAgIGlmICgje01VTFRJTElORX0gICYgb3B0aW9ucykgeyB0ZW1wICs9ICdtJzsgfVxuICAgICAgICAgIG9wdGlvbnMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSAnaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgYWxpYXMgY29tcGlsZSBuZXdcbiAgICBhbGlhcyBxdW90ZSBlc2NhcGVcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKDo6T3BhbC5jb2VyY2VfdG8/KHN0cmluZywgOjpTdHJpbmcsIDp0b19zdHIpKX0gIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmID1+KHN0cmluZylcbiAgICBtYXRjaChzdHJpbmcpICYmICR+LmJlZ2luKDApXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICAjIFNwZWNpYWxpemVkIHZlcnNpb24gb2YgZnJlZXplLCBiZWNhdXNlIHRoZSAkJGdtIGFuZCAkJGcgcHJvcGVydGllcyBuZWVkIHRvIGJlIHNldFxuICAgICMgZXNwZWNpYWxseSBmb3IgUmVnRXhwLlxuXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoJyQkZycpKSB7ICRwcm9wKHNlbGYsICckJGcnLCBudWxsKTsgfVxuICAgICAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCckJGdtJykpIHsgJHByb3Aoc2VsZiwgJyQkZ20nLCBudWxsKTsgfVxuXG4gICAgICByZXR1cm4gJGZyZWV6ZShzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RyaW5nID09PSBuaWwpIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgdmFyIG0gPSBzZWxmLmV4ZWMoJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xuICAgICAgdmFyIG1kLCByZSA9IE9wYWwuZ2xvYmFsX3JlZ2V4cChzZWxmKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XG4gICAgICAgIGlmIChtZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWQuaW5kZXggPj0gcG9zKSB7XG4gICAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nID09PSBuaWwgPyBmYWxzZSA6IHNlbGYudGVzdCgkY29lcmNlX3RvKHN0cmluZywgI3s6OlN0cmluZ30sICd0b19zdHInKSk7XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xuICAgICAgdmFyIG1kLCByZSA9IE9wYWwuZ2xvYmFsX3JlZ2V4cChzZWxmKTtcblxuICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XG4gICAgICBpZiAobWQgPT09IG51bGwgfHwgbWQuaW5kZXggPCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmFtZXNcbiAgICBzb3VyY2Uuc2NhbigvXFwoPzwoXFx3Kyk+Lywgbm9fbWF0Y2hkYXRhOiB0cnVlKS5tYXAoJjpmaXJzdCkudW5pcVxuICBlbmRcblxuICBkZWYgbmFtZWRfY2FwdHVyZXNcbiAgICBzb3VyY2Uuc2NhbigvXFwoPzwoXFx3Kyk+Lywgbm9fbWF0Y2hkYXRhOiB0cnVlKSAjIFNjYW4gZm9yIGNhcHR1cmUgZ3JvdXBzXG4gICAgICAgICAgLm1hcCgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAgICAgICMgR2V0IHRoZSBmaXJzdCByZWdleHAgbWF0Y2ggKFxcdyspXG4gICAgICAgICAgLmVhY2hfd2l0aF9pbmRleCAgICAgICAgICAgICAgICAgICAgICAgICMgQWRkIGluZGV4IHRvIGFuIGl0ZXJhdG9yXG4gICAgICAgICAgLmdyb3VwX2J5KCY6Zmlyc3QpICAgICAgICAgICAgICAgICAgICAgICMgR3JvdXAgYnkgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXNcbiAgICAgICAgICAudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXwgICAgICAgICAgICAgICAgIyBDb252ZXJ0IGhhc2ggdmFsdWVzXG4gICAgICAgICAgICBpLm1hcCB7IHxqfCBqLmxhc3QgKyAxIH0gICAgICAgICAgICAgICMgRHJvcCB0aGUgY2FwdHVyZSBncm91cCBuYW1lczsgaW5jcmVhc2UgaW5kZXhlcyBieSAxXG4gICAgICAgICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgc2VsZiA9fiAkX1xuICBlbmRcblxuICBkZWYgc291cmNlXG4gICAgYHNlbGYuc291cmNlYFxuICBlbmRcblxuICBkZWYgb3B0aW9uc1xuICAgICMgRmxhZ3Mgd291bGQgYmUgbmljZSB0byB1c2Ugd2l0aCB0aGlzLCBidXQgc3RpbGwgZXhwZXJpbWVudGFsIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2ZsYWdzXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyB0b19zIHNvdXJjZVxuZW5kXG5cbmNsYXNzIE1hdGNoRGF0YVxuICBhdHRyX3JlYWRlciA6cG9zdF9tYXRjaCwgOnByZV9tYXRjaCwgOnJlZ2V4cCwgOnN0cmluZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlZ2V4cCwgbWF0Y2hfZ3JvdXBzLCBub19tYXRjaGRhdGE6IGZhbHNlKVxuICAgICR+ICAgICAgICAgID0gc2VsZiB1bmxlc3Mgbm9fbWF0Y2hkYXRhXG4gICAgQHJlZ2V4cCAgICAgPSByZWdleHBcbiAgICBAYmVnaW4gICAgICA9IGBtYXRjaF9ncm91cHMuaW5kZXhgXG4gICAgQHN0cmluZyAgICAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0YFxuICAgIEBwcmVfbWF0Y2ggID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZSgwLCBtYXRjaF9ncm91cHMuaW5kZXgpYFxuICAgIEBwb3N0X21hdGNoID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZShtYXRjaF9ncm91cHMuaW5kZXggKyBtYXRjaF9ncm91cHNbMF0ubGVuZ3RoKWBcbiAgICBAbWF0Y2hlcyAgICA9IFtdXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtYXRjaF9ncm91cHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gbWF0Y2hfZ3JvdXBzW2ldO1xuXG4gICAgICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChuaWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2goZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2goaWR4KVxuICAgIGlmIChtYXRjaCA9IHNlbGZbaWR4XSlcbiAgICAgIG1hdGNoXG4gICAgZWxzaWYgaWR4LmlzX2E/KEludGVnZXIpICYmIGlkeCA+PSBsZW5ndGhcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJpbmRleCAje2lkeH0gb3V0IG9mIG1hdGNoZXNcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWF0Y2hfbGVuZ3RoKGlkeClcbiAgICBtYXRjaChpZHgpJi5sZW5ndGhcbiAgZW5kXG5cbiAgZGVmIFtdKCphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKCN7IXJlZ2V4cC5uYW1lcy5pbmNsdWRlPyhhcmdzWzBdKX0pIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJ1bmRlZmluZWQgZ3JvdXAgbmFtZSByZWZlcmVuY2U6ICN7YXJnc1swXX1cIn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tuYW1lZF9jYXB0dXJlc1thcmdzWzBdXX1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tAbWF0Y2hlc1sqYXJnc119XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgb2Zmc2V0KG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNvZmZzZXQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3NlbGYuYmVnaW4sIHNlbGYuYmVnaW4gKyBzZWxmLm1hdGNoZXNbbl0ubGVuZ3RoXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6TWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBkZWYgYmVnaW4obilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI2JlZ2luIG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYmVnaW47XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW5kKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBuYW1lZF9jYXB0dXJlc1xuICAgIG1hdGNoZXMgPSBjYXB0dXJlc1xuICAgIHJlZ2V4cC5uYW1lZF9jYXB0dXJlcy50cmFuc2Zvcm1fdmFsdWVzIGRvIHxpfFxuICAgICAgbWF0Y2hlc1tpLmxhc3QgLSAxXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbmFtZXNcbiAgICByZWdleHAubmFtZXNcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBcIiM8TWF0Y2hEYXRhIFwiICsgI3tgI3tAbWF0Y2hlc31bMF1gLmluc3BlY3R9O1xuXG4gICAgICBpZiAoI3tyZWdleHAubmFtZXMuZW1wdHk/fSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gI3tAbWF0Y2hlc30ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgXCIgKyBpICsgXCI6XCIgKyAje2Aje0BtYXRjaGVzfVtpXWAuaW5zcGVjdH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAjeyBuYW1lZF9jYXB0dXJlcy5lYWNoIGRvIHxrLCB2fFxuICAgICAgICAgICAgICV4e1xuICAgICAgICAgICAgICAgc3RyICs9IFwiIFwiICsgI3trfSArIFwiOlwiICsgI3t2Lmluc3BlY3R9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICBlbmQgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyICsgXCI+XCI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYCN7QG1hdGNoZXN9Lmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgYXJnc1tpXWAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSAje0BtYXRjaGVzfS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gobmlsKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlcy5wdXNoKCN7QG1hdGNoZXN9W2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlJlZ2V4cEVycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6UmVnZXhwPiIsInNlbGYiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsInN0cmluZyIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJyZWdleHAiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsIlJlZ2V4cEVycm9yIiwiISIsIklHTk9SRUNBU0UiLCJNVUxUSUxJTkUiLCI9PSIsIm90aGVyIiwiPT09IiwibWF0Y2giLCJjb2VyY2VfdG8/IiwiPX4iLCIkcmV0X29yXzEiLCJiZWdpbiIsIjAiLCJmcmVlemUiLCJmcm96ZW4/IiwiaW5zcGVjdCIsInBvcyIsIk1hdGNoRGF0YSIsIkludGVnZXIiLCJtYXRjaD8iLCJuYW1lcyIsIm1hcCIsInNvdXJjZSIsInNjYW4iLCJ0b19wcm9jIiwidW5pcSIsIm5hbWVkX2NhcHR1cmVzIiwidHJhbnNmb3JtX3ZhbHVlcyIsImdyb3VwX2J5IiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gbmFtZWRfY2FwdHVyZXMiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuYW1lZF9jYXB0dXJlcyIsImoiLCJibG9jayAoMyBsZXZlbHMpIGluIG5hbWVkX2NhcHR1cmVzIiwiKyIsImxhc3QiLCJ+IiwiJF8iLCJjYXNlZm9sZD8iLCI8Y2xhc3M6TWF0Y2hEYXRhPiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm1hdGNoX2dyb3VwcyIsIiRrd2FyZ3MiLCJub19tYXRjaGRhdGEiLCJAcmVnZXhwIiwiQGJlZ2luIiwiQHN0cmluZyIsIkBwcmVfbWF0Y2giLCJAcG9zdF9tYXRjaCIsIkBtYXRjaGVzIiwiaWR4IiwiaXNfYT8iLCI+PSIsImxlbmd0aCIsIkluZGV4RXJyb3IiLCJtYXRjaF9sZW5ndGgiLCJpbmNsdWRlPyIsImFyZ3MiLCJvZmZzZXQiLCJBcmd1bWVudEVycm9yIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiZW5kIiwiY2FwdHVyZXMiLCJtYXRjaGVzIiwiLSIsImVtcHR5PyIsImVhY2giLCJibG9jayBpbiBpbnNwZWN0IiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJ0b19hIiwidG9fcyIsInZhbHVlc19hdCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxPQUFNLElBQU5BLEVBQXNCQyxvQkFBdEJEO0VBRUFFO0VBQUFBOztJQUFBQTs7O0lBQ0UsV0FBQUMsSUFBQSxnQkFBbUJDLENBQW5CO0lBQ0EsV0FBQUQsSUFBQSxjQUFpQkUsQ0FBakI7SUFDQSxXQUFBRixJQUFBLGVBQWtCRyxDQUFsQjtJQUVDSjtJQUVEO01BQUE7Ozs7QUFDRUssTUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQ0VDLFlBQVksT0FBQUwsSUFBQSxFQUFBLHNEQUFBLFlBQUEsRUFBQSxFQUFBLEVBQUEsTUFBQTtRQUNUSyxTQUFVRDtRQUNiQSxPQUFBQztNQUhGRCxDQUFBQSxHQUFBQTs7QUFNQUUsTUFBQUEsc0JBQUFBLGtCQUFXQyxNQUFYRDtBQUFBQTtRQUNFQSxPQUFDQSwwQkFBREE7TUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFFLE1BQUFBLDBCQUFBQSxzQkFBZUMsQ0FBZkQ7QUFBQUEsUUFBQUE7OztRQUFlLG1CQUFJO1FBQ2pCLElBQUEsUUFBR0MsQ0FBQ0MsU0FBQUEsQ0FBQUEsQ0FBSixDQUFBO1VBQ0VGLE9BQUFHO1FBREYsT0FFQSxJQUFBLFFBQU1BLFdBQU4sQ0FBQTtVQUNFSCxPQUFBRyxXQUFFQyxPQUFBQSxDQUFDSCxDQUFERztRQURKO1VBekJOSixPQUFBO1FBeUJNO01BSEZBLENBQUFBLElBQUFBOztBQVFBSyxNQUFBQSxxQkFBQUEsaUJBOUJKLEVBOEJJQTtBQUFBQSxRQUFBQTs7O1FBOUJKO1FBOEJjOztBQUVkQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxVQUFZQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QkgsNkNBQXBCRTtBQUNwQkY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0NBQW9DYixJQUFBTSxRQUFBQSxDQUFRTyxJQUFSUCxDQUFlTztBQUNuREE7QUFDQUE7QUFDQUEsZ0NBQWtDQSxDQUFDQSxJQUFEQSxDQUFNSSxTQUFBQSxDQUFBQSxDQUFTSjtBQUNqREE7QUFDQUEsY0FBZ0JDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCSCwyQ0FBcEJFO0FBQ3hCRjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxrQ0FBb0NiLElBQUFNLFFBQUFBLENBQU9PLENBQUNBLElBQURBLENBQU1LLFFBQUFBLENBQUFBLENBQWJaLENBQXNCTztBQUMxREE7QUFDQUE7QUFDQUE7UUFFTUEsT0FBQWIsSUFBQW1CLEtBQUFBLENBQUlOLENBQUNBLGdCQUFEQSxDQUFrQk8sTUFBQUEsQ0FBTVAsR0FBTk8sQ0FBdEIsRUFBbUNQLE9BQW5DTTtNQXhDRk4sQ0FBQUEsSUFBQUE7O0FBMkNBTSxNQUFBQSxtQkFBQUEsZ0JBQVFFLE1BQUQsRUFBU0osT0FBaEJFO0FBQUFBOzs7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQSxpQkFBbUJHLEtBQU1DLGVBQUFBLENBQVlGLE1BQWxCLEVBQTBCRyxhQUExQixFQUFvQyxRQUE5QkQsQ0FBdUNKOztBQUVoRUE7QUFDQUEsVUFBWUwsT0FBUUMsT0FBQUEsQ0FBT1Usa0JBQWYsRUFBK0JOLDhCQUFELEdBQUEsQ0FBK0JFLE1BQS9CLENBQUEsR0FBc0NGLEdBQTVESjtBQUNwQkk7O0FBRUFBOztBQUVBQSxxQ0FBd0NGLE9BQURTLE1BQUFBLENBQUFBLENBQVNQO0FBQ2hEQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsY0FBZ0JRLGdCQUFXUjtBQUMzQkEsY0FBZ0JTLGVBQVVUO0FBQzFCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7TUE3QklBLENBQUFBLElBQUFBO01BZ0NBLGFBQU0sU0FBTixFQUFjLEtBQWQ7TUFDQSxPQUFBLGFBQU0sT0FBTixFQUFZLFFBQVo7SUEvRkYsNEJBQVNuQixJQUFUOztBQWtHQTZCLElBQUFBLGtCQUFBQSwwQkFBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLCtEQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsbUJBQUFBLDZCQUFReEIsTUFBUndCO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHL0IsSUFBQWdDLE9BQUFBLENBQU1WLEtBQU1XLGVBQUFBLENBQVkxQixNQUFsQixFQUEwQmlCLGFBQTFCLEVBQW9DLFFBQTlCUyxDQUFaRCxDQUFvREQ7SUFEekRBLENBQUFBLEdBQUFBOztBQUlBRyxJQUFBQSxrQkFBQUEsNkJBQU8zQixNQUFQMkI7QUFBQUEsTUFBQUE7QUFBQUE7O01BQ0UsSUFBQSxRQUFBQyxDQUFBQSxZQUFBbkMsSUFBQWdDLE9BQUFBLENBQU16QixNQUFOeUIsQ0FBQUcsQ0FBQSxDQUFBO1FBQWlCRCxPQUFBdkIsV0FBRXlCLE9BQUFBLENBQU9DLENBQVBEO01BQW5CO1FBQUFGLE9BQUE7TUFBQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUksSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7O01BSUUsSUFBQSxRQUFldEMsSUFBQXVDLFlBQUFBLENBQUFBLENBQWYsQ0FBQTtRQUFBLE9BQU92QztNQUFQOztBQUdKc0M7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBWEVBLENBQUFBLEdBQUFBOztBQWNBRSxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOzs7QUFJRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFuQ0VBLENBQUFBLEdBQUFBOztBQXNDQVIsSUFBQUEscUJBQUFBLGlCQUFVekIsTUFBRCxFQUFTa0MsR0FBbEJUO0FBQUFBLE1BQUFBO0FBQUFBOztNQUFBQTs7Ozs7QUFFRkE7QUFDQUEsUUFBVWxCLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCZ0Isc0JBQXBCakI7QUFDbEJpQjs7QUFFQUE7QUFDQUEsbUNBQXFDckIsQ0FBQUEsY0FBSyxHQUFMQSxDQUFTcUI7QUFDOUNBLDZDQUErQ1IsYUFBU1E7QUFDeERBO0FBQ0FBLFVBQVlyQixDQUFBQSxjQUFLK0IsZ0JBQVd2QixLQUFBQSxDQUFNYSxJQUFqQixFQUF5QkEsQ0FBZGIsQ0FBaEJSLENBQWtDcUI7QUFDOUNBLGlDQUFtQ3JCLFdBQUdxQixHQUFLLG1CQUFNckIsV0FBTixDQUFTcUI7QUFDcERBO0FBQ0FBLGlCQUFtQnJCLENBQUFBLGNBQUssR0FBTEEsQ0FBU3FCO0FBQzVCQTtBQUNBQTs7QUFFQUEsNEJBQThCVyxjQUFVWDs7QUFFeENBO0FBQ0FBLGVBQWlCckIsQ0FBQUEsY0FBSyxHQUFMQSxDQUFTcUI7QUFDMUJBOztBQUVBQSxrQ0FBb0NSLGFBQVNROztBQUU3Q0E7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CckIsQ0FBQUEsY0FBSyxHQUFMQSxDQUFTcUI7QUFDNUJBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CckIsQ0FBQUEsY0FBSyxHQUFMQSxDQUFTcUI7QUFDNUJBO0FBQ0FBO0FBQ0FBLFVBQVlyQixDQUFBQSxjQUFLK0IsZ0JBQVd2QixLQUFBQSxDQUFNYSxFQUFqQixFQUF1QkEsRUFBWmIsQ0FBaEJSLENBQWlDcUI7QUFDN0NBLGlDQUFtQ3JCLFdBQUdxQixHQUFLLG1CQUFNckIsV0FBTixDQUFTcUI7QUFDcERBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBOUNFQSxDQUFBQSxJQUFBQTs7QUFpREFZLElBQUFBLHNCQUFBQSw4QkFBV3JDLE1BQUQsRUFBU2tDLEdBQW5CRztBQUFBQSxNQUFBQTs7Ozs7QUFFRkE7QUFDQUEsUUFBVTlCLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCNEIsc0JBQXBCN0I7QUFDbEI2Qjs7QUFFQUE7QUFDQUEscUVBQXVFcEIsYUFBU29CO0FBQ2hGQTs7QUFFQUEsNEJBQThCRCxjQUFVQzs7QUFFeENBO0FBQ0FBO0FBQ0FBOztBQUVBQSxrQ0FBb0NwQixhQUFTb0I7O0FBRTdDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBbENFQSxDQUFBQSxJQUFBQTs7QUFxQ0FDLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQTZDQyxNQUE3QzlDLElBQUErQyxRQUFBQSxDQUFBQSxDQUFNQyxNQUFBQSxDQUFNLFlBQVosRUFBMEIsMEJBQUEsZ0JBQWMsSUFBZCxFQUFwQkEsQ0FBdUNGLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sT0FBREcsU0FBQUEsQ0FBQUEsQ0FBTEgsQ0FBYUksTUFBQUEsQ0FBQUE7SUFENURMLENBQUFBLEdBQUFBOztBQUlBTSxJQUFBQSw4QkFBQUEsMEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUlNQyxNQURBQyxNQUZBUCxNQUROOUMsSUFBQStDLFFBQUFBLENBQUFBLENBQU1DLE1BQUFBLENBQU0sWUFBWixFQUEwQiwwQkFBQSxnQkFBYyxJQUFkLEVBQXBCQSxDQUNBRixPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLE9BQURHLFNBQUFBLENBQUFBLENBQUxILENBQ0FRLGlCQUFBQSxDQUFBQSxDQUNBRCxZQUFBQSxFQUFBQSxFQUFBQSxFQUFXLE9BQURKLFNBQUFBLENBQUFBLENBQVZJLENBQ0FELG9CQUFBQSxFQUFBQSxFQUFBQSxFQUpORyxhQUk0QkMsQ0FKNUJEOztRQUk0QjtRQUNwQkUsT0FBQ1gsTUFBRFUsQ0FBQ1YsT0FBQUEsRUFBQUEsRUFBQUEsRUFBRFcsYUFBU0MsQ0FBVEQ7O1VBQVM7VUFBR0UsT0FBT0MsU0FBUEYsQ0FBQ0csTUFBQUEsQ0FBQUEsQ0FBTUQsRUFBRTNELENBQUYyRCxFQUFuQkgsQ0FBQUEsR0FBQ1gsRUFMVFMsQ0FBQUEsR0FJTUg7SUFMUkQsQ0FBQUEsR0FBQUE7O0FBVUFXLElBQUFBLGlCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7QUFBQUE7O01BQ0VBLE9BQUE5RCxJQUFLa0MsT0FBQUEsQ0FBRzZCLFFBQUg3QjtJQURQNEIsQ0FBQUEsR0FBQUE7O0FBSUFmLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLFdBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBOUIsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O0FBR0ZBO0FBQ0FBLFFBQVVILE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCQyxzQkFBcEJGO0FBQ2xCRTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxrQkFBb0JXLGVBQVVYO0FBQzlCQTtBQUNBQTtBQUNBQSxrQkFBb0JVLGdCQUFXVjtBQUMvQkE7QUFDQUE7QUFDQUE7SUFmRUEsQ0FBQUEsR0FBQUE7O0FBa0JBK0MsSUFBQUEseUJBQUFBLGlDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsZUFBREE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBQ0FqRSxPQUFBLGFBQU0sTUFBTixFQUFXLFFBQVg7RUE1U0ZBLEdBQU0sSUFBTkEsRUFBa0JILE1BQWxCRztFQStTQUgsT0FBQXFFO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VqRSxJQUFBa0UsYUFBQUEsQ0FBWSxZQUFaLEVBQXlCLFdBQXpCLEVBQXFDLFFBQXJDLEVBQThDLFFBQTlDQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlOUMsTUFBRCxFQUFTK0MsWUFBVCxFQXRUaEJDLE9Bc1RFRjtBQUFBQSxNQUFBQTs7O01BdFRGOztNQXNUdUMsOENBQUEseUNBQWM7TUFDakQsS0FBQSxRQUEwQkcsWUFBMUIsQ0FBQTtRQUFBM0QsY0FBY1g7TUFBZDtNQUNBdUUsY0FBY2xEO01BQ2RtRCxhQUFlTDtNQUNmTSxjQUFlTjtNQUNmTyxpQkFBZVA7TUFDZlEsa0JBQWVSO01BQ2ZTLGVBQWM7O0FBR2xCVDtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWVMsWUFBU1Q7QUFDckJBO0FBQ0FBO0FBQ0FBLFVBQVlTLFlBQVNUO0FBQ3JCQTtBQUNBQTtBQUNBQTtJQXBCRUEsQ0FBQUEsSUFBQUE7O0FBdUJBbkMsSUFBQUEscUJBQUFBLGlCQUFVNkMsR0FBVjdDO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBSUEsQ0FBQUEsUUFBUWhDLElBQUlZLE9BQUFBLENBQUNpRSxHQUFEakUsQ0FBWm9CLENBQUosQ0FBQTtRQUNFQSxPQUFBQTtNQURGLE9BRUEsSUFBTSxDQUFBLFFBQUE2QyxHQUFHQyxVQUFBQSxDQUFPbkMsYUFBUG1DLENBQUgsQ0FBQSxJQUFBLENBQUEsUUFBMEJDLE9BQUpGLEdBQUlFLEVBQUcvRSxJQUFBZ0YsUUFBQUEsQ0FBQUEsQ0FBSEQsQ0FBMUIsQ0FBQSxDQUFBLENBQU47UUFDRS9DLE9BQUFsQixPQUFRQyxPQUFBQSxDQUFPa0UsaUJBQWYsRUFBOEJqRCxRQUFELEdBQUEsQ0FBUzZDLEdBQVQsQ0FBQSxHQUFhN0MsaUJBQWxDakI7TUFEVjtRQWhWSmlCLE9BQUE7TUFnVkk7SUFIRkEsQ0FBQUEsR0FBQUE7O0FBUUFrRCxJQUFBQSw0QkFBQUEsd0JBQWlCTCxHQUFqQks7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQSxLQUFBbEYsSUFBQWdDLE9BQUFBLENBQU02QyxHQUFON0MsQ0FBQSxxQ0FBQSxFQUFBLFFBQUEsQ0FBQSxDQUFBO0lBREZrRCxDQUFBQSxHQUFBQTs7QUFJQXRFLElBQUFBLGtCQUFBQSwwQkF6VkYsRUF5VkVBO0FBQUFBLE1BQUFBOzs7TUF6VkY7TUF5VlM7O0FBRVRBO0FBQ0FBLFlBQWVaLElBQUFxQixRQUFBQSxDQUFBQSxDQUFNd0IsT0FBQUEsQ0FBQUEsQ0FBTXNDLGFBQUFBLENBQVVDLElBQUl4RSxPQUFBQSxDQUFDeUIsQ0FBRHpCLENBQWR1RSxDQUFiekQsTUFBQUEsQ0FBQUEsQ0FBZ0NkO0FBQzlDQSxVQUFZRSxPQUFRQyxPQUFBQSxDQUFPa0UsaUJBQWYsRUFBOEJyRSxrQ0FBRCxHQUFBLENBQW1Dd0UsSUFBSXhFLE9BQUFBLENBQUN5QixDQUFEekIsQ0FBdkMsQ0FBckJHO0FBQ3BCSDtBQUNBQSxlQUFpQlosSUFBQW1ELGdCQUFBQSxDQUFBQSxDQUFjdkMsT0FBQUEsQ0FBQ3dFLElBQUl4RSxPQUFBQSxDQUFDeUIsQ0FBRHpCLENBQUxBO0FBQy9CQTtBQUNBQTtBQUNBQSxlQUF5QkEsTUFBUmdFLFlBQVFoRSxNQUFBQSxFQUFDLE1BQUN3RSxJQUFELENBQUR4RTtBQUN6QkE7QUFDQUE7SUFYRUEsQ0FBQUEsSUFBQUE7O0FBY0F5RSxJQUFBQSxzQkFBQUEsa0JBQVc1RSxDQUFYNEU7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxRQUFVdkUsT0FBUUMsT0FBQUEsQ0FBT3VFLG9CQUFmLEVBQWdDRCw0Q0FBeEJ0RTtBQUNsQnNFO0FBQ0FBO0FBQ0FBO0lBTkVBLENBQUFBLEdBQUFBOztBQVNBeEQsSUFBQUEsa0JBQUFBLDhCQUFPQyxLQUFQRDtBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxRQUFvQmEsZ0JBQXBCLEVBQW9DWixLQUFwQyxDQUFBO1FBQUEsT0FBTztNQUFQO01BRUEsSUFBQSxRQUFBSyxDQUFBQSxZQUFBLENBQUEsUUFBQW9ELENBQUFBLFlBQUEsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBLENBQUEsUUFBQUMsQ0FBQUEsWUFBQzVELDJCQUFENEQsQ0FBQSxDQUFBLEdBQUEsQ0FDRzVELGlEQURILElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQTJELENBQUEsQ0FBQSxHQUFBLENBRUczRCxpQ0FGSCxJQUFBLENBQUEsU0FBQSxDQUFBLENBQUEwRCxDQUFBLENBQUEsR0FBQSxDQUdHMUQsbUNBSEgsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFBTSxDQUFBLENBQUE7UUFJRU4sT0FBQ0EseUJBQURBO01BSkY7UUFBQUEsT0FBQTtNQUFBO0lBSEZBLENBQUFBLEdBQUFBOztBQVVBTyxJQUFBQSxxQkFBQUEsaUJBQVUzQixDQUFWMkI7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxRQUFVdEIsT0FBUUMsT0FBQUEsQ0FBT3VFLG9CQUFmLEVBQWdDbEQsMkNBQXhCckI7QUFDbEJxQjtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQSxHQUFBQTs7QUFTQXNELElBQUFBLG1CQUFBQSxlQUFRakYsQ0FBUmlGO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsUUFBVTVFLE9BQVFDLE9BQUFBLENBQU91RSxvQkFBZixFQUFnQ0kseUNBQXhCM0U7QUFDbEIyRTtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQSxHQUFBQTs7QUFTQUMsSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR2YsWUFBU2U7SUFEZEEsQ0FBQUEsR0FBQUE7O0FBSUF4QyxJQUFBQSw4QkFBQUEsMEJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRXlDLFVBQVU1RixJQUFBMkYsVUFBQUEsQ0FBQUE7TUFDVnhDLE9BQXFCQyxNQUFyQnBELElBQUFxQixRQUFBQSxDQUFBQSxDQUFNOEIsZ0JBQUFBLENBQUFBLENBQWVDLG9CQUFBQSxFQUFBQSxFQUFBQSxFQUFyQkcsY0FBMkNDLENBQTNDRDs7UUFBMkM7UUFDekNFLE9BQUFtQyxPQUFPaEYsT0FBQUEsQ0FBUWlGLFVBQVByQyxDQUFDSyxNQUFBQSxDQUFBQSxDQUFNZ0MsRUFBRTVGLENBQUY0RixDQUFSakYsRUFEVDJDLENBQUFBLEdBQXFCSDtJQUZ2QkQsQ0FBQUEsR0FBQUE7O0FBT0FOLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE3QyxJQUFBcUIsUUFBQUEsQ0FBQUEsQ0FBTXdCLE9BQUFBLENBQUFBO0lBRFJBLENBQUFBLEdBQUFBOztBQUlBTCxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkEsaUNBQW1DQSxDQUFHb0MsWUFBU3BDLEdBQVpBLENBQWdCQSxTQUFBQSxDQUFBQSxDQUFTQTs7QUFFNURBLFVBQVl4QyxJQUFBcUIsUUFBQUEsQ0FBQUEsQ0FBTXdCLE9BQUFBLENBQUFBLENBQU1pRCxXQUFBQSxDQUFBQSxDQUFRdEQ7QUFDaENBLGlDQUFtQ29DLFlBQVNwQztBQUM1Q0EsaUNBQW1DQSxDQUFHb0MsWUFBU3BDLEdBQVpBLENBQWdCQSxTQUFBQSxDQUFBQSxDQUFTQTtBQUM1REE7QUFDQUE7QUFDQUE7QUFDQUEsUUFBeUJ1RCxNQUFkL0YsSUFBQW1ELGdCQUFBQSxDQUFBQSxDQUFjNEMsUUFBQUEsRUFBQUEsRUFBQUEsRUFBZEMsY0FBd0JDLENBQUQsRUFBSUMsQ0FBM0JGOztRQUF3QjtRQUFHO1FBQ3pCRyxPQUNiQSw0QkFBOEJGLENBQUVFLFNBQVdELENBQUMxRCxTQUFBQSxDQUFBQSxFQUZqQ3dELENBQUFBLEdBQWNEO0FBS3pCdkQ7O0FBRUFBO0FBQ0FBO0lBbEJFQSxDQUFBQSxHQUFBQTs7QUFxQkF3QyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHSixZQUFTSTtJQURkQSxDQUFBQSxHQUFBQTs7QUFJQW9CLElBQUFBLG9CQUFBQSxhQUNFLFNBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHekIsWUFBU3lCO0lBRGRBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEscUJBNWJGLEVBNGJFQTtBQUFBQSxNQUFBQTs7O01BNWJGO01BNGJnQjs7QUFFaEJBOztBQUVBQTs7QUFFQUE7QUFDQUEsY0FBZ0JBLENBQUNBLE9BQURBLENBQVNGLE1BQUFBLENBQUFBLENBQU1FO0FBQy9CQTtBQUNBQTtBQUNBQTs7QUFFQUEsZ0JBQWtCaEYsS0FBTUMsZUFBQUEsQ0FBYStFLE9BQW5CLEVBQTZCM0QsY0FBN0IsRUFBd0MsUUFBbENwQixDQUEyQytFOztBQUVuRUE7QUFDQUEsbUJBQXFCMUIsWUFBUzBCO0FBQzlCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUEsb0JBQXNCMUIsWUFBUzBCO0FBQy9CQTs7QUFFQUE7QUFDQUE7SUExQkVBLENBQUFBLElBQUFBO0lBNkJBLGFBQU0sTUFBTixFQUFXLElBQVg7SUFDQXJDLE9BQUEsYUFBTSxNQUFOLEVBQVcsUUFBWDtFQXZLRkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFuVEFyRTsifX0seyJvZmZzZXQiOnsibGluZSI6OTUxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCB5aWVsZDEsIHlpZWxkWCwgZGVueV9mcm96ZW5fYWNjZXNzXG5cbm1vZHVsZSA6OkVudW1lcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBbbmlsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGFueT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiB0cnVlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBjaHVuaygmYmxvY2spXG4gICAgcmV0dXJuIHRvX2VudW0oOmNodW5rKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbmlsLCBhY2N1bXVsYXRlID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZUFjY3VtdWxhdGUoKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBwcmV2aW91c2AsIGBhY2N1bXVsYXRlYCl9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSAkeWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5pbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzbGljZV93aGVuIHsgfGJlZm9yZSwgYWZ0ZXJ8ICEoeWllbGQgYmVmb3JlLCBhZnRlcikgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0X2NvbmNhdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgbWFwKCZibG9jaykuZmxhdHRlbigxKVxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgIHRvX2EuY29tcGFjdFxuICBlbmRcblxuICBkZWYgY291bnQob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gMFxuXG4gICAgJXh7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIGRvIHwqYXJnc3xcbiAgICAgICAgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9iamVjdFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsP1xuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIHsgdHJ1ZSB9XG4gICAgZW5kXG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGByZXN1bHQrK2AgaWYgYCR5aWVsZFgoYmxvY2ssIGFyZ3MpYFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgcmVzcG9uZF90bz8oOnNpemUpID8gOjpGbG9hdDo6SU5GSU5JVFkgOiBuaWxcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hIG4sIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgICByZXR1cm4gaWYgYG4gPD0gMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGFsbCA9IFtdLCBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgYWxsLnB1c2gocGFyYW0pO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGlmIChhbGwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSBuaWwpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZXRlY3QoaWZub25lID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkZXRlY3QsIGlmbm9uZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIHZhbHVlID0gOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICBpZiB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGlmbm9uZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YoaWZub25lKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpZm5vbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaWZub25lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBkcm9wKG51bWJlcilcbiAgICBudW1iZXIgPSBgJGNvZXJjZV90byhudW1iZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG51bWJlciA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIGRyb3AgbmVnYXRpdmUgc2l6ZSdcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG51bWJlciA8PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50Kys7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKClcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRyb3Bfd2hpbGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICAgPSBbXSxcbiAgICAgICAgICBkcm9wcGluZyA9IHRydWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgaWYgKGRyb3BwaW5nKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgZHJvcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9jb25zKG4sICZibG9jaylcbiAgICBpZiBgYXJndW1lbnRzLmxlbmd0aCAhPSAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMSlcIlxuICAgIGVuZFxuXG4gICAgbiA9IDo6T3BhbC50cnlfY29udmVydCBuLCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGBuIDw9IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNpemUnXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY29ucywgbikgZG9cbiAgICAgICAgZW51bV9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICAgIGlmIGVudW1fc2l6ZS5uaWw/XG4gICAgICAgICAgbmlsXG4gICAgICAgIGVsc2lmIGVudW1fc2l6ZSA9PSAwIHx8IGVudW1fc2l6ZSA8IG5cbiAgICAgICAgICAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtX3NpemUgLSBuICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYnVmZmVyID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgYnVmZmVyLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gbikge1xuICAgICAgICAgIGJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG4pIHtcbiAgICAgICAgICAkeWllbGQxKGJsb2NrLCBidWZmZXIuc2xpY2UoMCwgbikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9lbnRyeSgqZGF0YSwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiB0b19lbnVtKDplYWNoX2VudHJ5LCAqZGF0YSkgeyBlbnVtZXJhdG9yX3NpemUgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgJHlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgZGF0YSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfc2xpY2UobiwgJmJsb2NrKVxuICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBuIDw9IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNsaWNlIHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfc2xpY2UsIG4pIHsgcmVzcG9uZF90bz8oOnNpemUpID8gKHNpemUgLyBuKS5jZWlsIDogbmlsIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgc2xpY2UgPSBbXVxuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAkeWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAvLyBvdXIgXCJsYXN0XCIgZ3JvdXAsIGlmIHNtYWxsZXIgdGhhbiBuIHRoZW4gd29uJ3QgaGF2ZSBiZWVuIHlpZWxkZWRcbiAgICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICR5aWVsZDEoYmxvY2ssIHNsaWNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfd2l0aF9pbmRleCwgKmFyZ3MpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX29iamVjdChvYmplY3QsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfd2l0aF9vYmplY3QsIG9iamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIG9iamVjdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG4gICAgfVxuXG4gICAgb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBlbnRyaWVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaCgjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmlsdGVyX21hcCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpmaWx0ZXJfbWFwKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG1hcCgmYmxvY2spLnNlbGVjdCgmOml0c2VsZilcbiAgZW5kXG5cbiAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbmRfYWxsKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmluZF9pbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmZpbmRfaW5kZXggaWYgYG9iamVjdCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IDBcblxuICAgIGlmIGBvYmplY3QgIT0gbnVsbGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKSA9PSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZmlyc3QobnVtYmVyID0gdW5kZWZpbmVkKVxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfHZhbHVlfFxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBudW1iZXIgPSBgJGNvZXJjZV90byhudW1iZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgaWYgYG51bWJlciA9PSAwYFxuICAgICAgICByZXR1cm4gW11cbiAgICAgIGVuZFxuXG4gICAgICBjdXJyZW50ID0gMFxuXG4gICAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgICAgYHJlc3VsdC5wdXNoKCN7OjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSlgXG5cbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGdyZXAocGF0dGVybiwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IFtdXG5cbiAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICBjbXAgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuICAgICAgbmV4dCB1bmxlc3MgcGF0dGVybi5fX3NlbmRfXyg6PT09LCAqY21wKVxuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXSBpZiB2YWx1ZS5sZW5ndGggPiAxXG4gICAgICAgIHZhbHVlID0geWllbGQoKnZhbHVlKVxuICAgICAgZWxzaWYgdmFsdWUubGVuZ3RoIDw9IDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBncmVwX3YocGF0dGVybiwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IFtdXG5cbiAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICBjbXAgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuICAgICAgbmV4dCBpZiBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyb3VwX2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmdyb3VwX2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGhhc2ggPSB7fVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgI3soaGFzaFtgdmFsdWVgXSB8fD0gW10pIDw8IGBwYXJhbWB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2hcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG9iailcbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGlmIDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKSA9PSBvYmpcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGluamVjdChvYmplY3QgPSB1bmRlZmluZWQsIHN5bSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwgJiYgc3ltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIFtyZXN1bHQsIHZhbHVlXSk7XG5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3ltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoISN7OjpTeW1ib2wgPT09IG9iamVjdH0pIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tvYmplY3QuaW5zcGVjdH0gaXMgbm90IGEgU3ltYm9sXCJ9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN5bSAgICA9IG9iamVjdDtcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAuX19zZW5kX18gc3ltLCBgdmFsdWVgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsYXp5XG4gICAgOjpFbnVtZXJhdG9yOjpMYXp5Lm5ldyhzZWxmLCBlbnVtZXJhdG9yX3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlbnVtZXJhdG9yX3NpemVcbiAgICByZXNwb25kX3RvPyg6c2l6ZSkgPyBzaXplIDogbmlsXG4gIGVuZFxuXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCB8fCBuID09PSBuaWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkWChibG9jaywgW2l0ZW0sIHJlc3VsdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICN7YGl0ZW1gIDw9PiBgcmVzdWx0YH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgfVxuXG4gICAgc29ydCgmYmxvY2spLnJldmVyc2UuZmlyc3QobilcbiAgZW5kXG5cbiAgZGVmIG1heF9ieShuID0gbmlsLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptYXhfYnksIG4pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICByZXR1cm4gc29ydF9ieSgmYmxvY2spLnJldmVyc2UudGFrZSBuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW4obiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICByZXR1cm4gc29ydCB7IHxhLCBifCB5aWVsZCBhLCBiIH0udGFrZSBuXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBzb3J0LnRha2UgblxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gYmxvY2socGFyYW0sIHJlc3VsdCk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgjezo6T3BhbC5jb21wYXJlKGBwYXJhbWAsIGByZXN1bHRgKX0gPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbl9ieShuID0gbmlsLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5fYnksIG4pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICByZXR1cm4gc29ydF9ieSgmYmxvY2spLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPCAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWlubWF4KCZibG9jaylcbiAgICBibG9jayB8fD0gOjpLZXJuZWwucHJvYyB7IHxhLCBifCBhIDw9PiBiIH1cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IG5pbCwgbWF4ID0gbmlsLCBmaXJzdF90aW1lID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBpZiAoZmlyc3RfdGltZSkge1xuICAgICAgICAgIG1pbiA9IG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgZmlyc3RfdGltZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW5fY21wID0gI3tibG9jay5jYWxsKGBtaW5gLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtaW5fY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWluX2NtcCA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1heF9jbXAgPSAje2Jsb2NrLmNhbGwoYG1heGAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1heF9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXhfY21wIDwgMCkge1xuICAgICAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXhfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6bWlubWF4X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluX3Jlc3VsdCA9IG5pbCxcbiAgICAgICAgICBtYXhfcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1pbl9ieSxcbiAgICAgICAgICBtYXhfYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoKG1pbl9ieSA9PT0gdW5kZWZpbmVkKSB8fCAje2B2YWx1ZWAgPD0+IGBtaW5fYnlgfSA8IDApIHtcbiAgICAgICAgICBtaW5fcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgbWluX2J5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXhfYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWF4X2J5YH0gPiAwKSB7XG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1heF9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW21pbl9yZXN1bHQsIG1heF9yZXN1bHRdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5vbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpdGVtID0gOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBpdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIG9uZT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGNvdW50ID0gMFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgICAgICBjb3VudCArPSAxXG4gICAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBuZXh0IHVubGVzcyB5aWVsZCgqdmFsdWUpXG4gICAgICAgIGNvdW50ICs9IDFcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY291bnQgPT0gMVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnBhcnRpdGlvbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciB0cnV0aHkgPSBbXSwgZmFsc3kgPSBbXSwgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgdHJ1dGh5LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZhbHN5LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbdHJ1dGh5LCBmYWxzeV07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaChhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICR5aWVsZFgoYmxvY2ssIHJlc3VsdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2xpY2VfYmVmb3JlKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8ZXxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBbXTtcblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCAje3BhdHRlcm4uZHVwfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX2FmdGVyKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyB7IHxlfCBwYXR0ZXJuID09PSBlIH1cbiAgICBlbmRcblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGU7XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGVuZF9jaHVuayA9ICR5aWVsZDEoYmxvY2ssIGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkdHJ1dGh5KGVuZF9jaHVuaykpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2Vfd2hlbigmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSknIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gbmlsLCBsYXN0X2FmdGVyID0gbmlsO1xuXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucy4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgYmVmb3JlID0gcGFyYW1zWzBdLFxuICAgICAgICAgICAgICBhZnRlciA9IHBhcmFtc1sxXSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSAkeWllbGRYKGJsb2NrLCBbYmVmb3JlLCBhZnRlcl0pO1xuXG4gICAgICAgICAgbGFzdF9hZnRlciA9IGFmdGVyO1xuXG4gICAgICAgICAgaWYgKHNsaWNlID09PSBuaWwpIHtcbiAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCR0cnV0aHkobWF0Y2gpKSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xpY2UucHVzaChiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucygyKTtcblxuICAgICAgICBpZiAoc2xpY2UgIT09IG5pbCkge1xuICAgICAgICAgIHNsaWNlLnB1c2gobGFzdF9hZnRlcik7XG4gICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBzbGljZWApfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgYXJ5ID0gdG9fYVxuICAgIGJsb2NrID0gLT4oYSwgYikgeyBhIDw9PiBiIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIGFyeS5zb3J0KCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHNvcnRfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBkdXAgPSBtYXAgZG9cbiAgICAgIGFyZyA9IDo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYClcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXG4gICAgZW5kXG4gICAgZHVwLnNvcnQhIHsgfGEsIGJ8IGBhWzBdYCA8PT4gYGJbMF1gIH1cbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxuICBlbmRcblxuICAjIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIEthaGFuIHN1bW1hdGlvbiBhbGdvcml0aG0gaWYgaXQgaXMgcG9zc2libGUgdG8gYXBwbHkgb25lLlxuICBkZWYgc3VtKGluaXRpYWwgPSAwKVxuICAgIHJlc3VsdCA9IGluaXRpYWxcbiAgICBjb21wZW5zYXRpb24gPSAwXG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGl0ZW0gPSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgICAgICAgIHlpZWxkKCphcmdzKVxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgIDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiAhWzo6RmxvYXQ6OklORklOSVRZLCAtOjpGbG9hdDo6SU5GSU5JVFldLmluY2x1ZGU/KGl0ZW0pICYmIGl0ZW0ucmVzcG9uZF90bz8oOi0pXG4gICAgICAgIHkgPSBpdGVtIC0gY29tcGVuc2F0aW9uXG4gICAgICAgIHQgPSByZXN1bHQgKyB5XG4gICAgICAgIGNvbXBlbnNhdGlvbiA9ICh0IC0gcmVzdWx0KSAtIHlcbiAgICAgICAgcmVzdWx0ID0gdFxuICAgICAgZWxzZVxuICAgICAgICByZXN1bHQgKz0gaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHRha2UobnVtKVxuICAgIGZpcnN0KG51bSlcbiAgZW5kXG5cbiAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dGFrZV93aGlsZSB1bmxlc3MgYmxvY2tcblxuICAgIHJlc3VsdCA9IFtdXG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIHZhbHVlID0gOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHVubGVzcyB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgZW5kXG5cbiAgICAgIGByZXN1bHQucHVzaCh2YWx1ZSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICBoYXNoID0ge31cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgcHJvZHVjZWQgPSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgICAgICAgICAgICB5aWVsZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB1bmxlc3MgaGFzaC5rZXk/KHByb2R1Y2VkKVxuICAgICAgICBoYXNoW3Byb2R1Y2VkXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGhhc2gudmFsdWVzXG4gIGVuZFxuXG4gIGRlZiB0YWxseShoYXNoID0gdW5kZWZpbmVkKVxuICAgIGBpZiAoaGFzaCAmJiBoYXNoICE9PSBuaWwpIHsgJGRlbnlfZnJvemVuX2FjY2VzcyhoYXNoKTsgfWBcblxuICAgIG91dCA9IGdyb3VwX2J5KCY6aXRzZWxmKS50cmFuc2Zvcm1fdmFsdWVzKCY6Y291bnQpXG4gICAgaWYgaGFzaFxuICAgICAgb3V0LmVhY2ggeyB8aywgdnwgaGFzaFtrXSA9IGhhc2guZmV0Y2goaywgMCkgKyB2IH1cbiAgICAgIGhhc2hcbiAgICBlbHNlXG4gICAgICBvdXRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2goKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX07XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIHZhciBhcnkgPSAjezo6T3BhbC5jb2VyY2VfdG8/KGBwYXJhbWAsIDo6QXJyYXksIDp0b19hcnkpfSwga2V5LCB2YWw7XG4gICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBhcnJheSBsZW5ndGggKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgIHRvX2EuemlwKCpvdGhlcnMpXG4gIGVuZFxuXG4gIGFsaWFzIGZpbmQgZGV0ZWN0XG4gIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuICBhbGlhcyBmbGF0X21hcCBjb2xsZWN0X2NvbmNhdFxuICBhbGlhcyBtYXAgY29sbGVjdFxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcbiAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG4gIGFsaWFzIHRvX2EgZW50cmllc1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6RW51bWVyYWJsZT4iLCJhbGw/IiwicGF0dGVybiIsImVhY2giLCJzZWxmIiwiYmxvY2sgaW4gYWxsPyIsImJsb2NrICgyIGxldmVscykgaW4gYWxsPyIsImNvbXBhcmFibGUiLCJwdWJsaWNfc2VuZCIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiT3BhbCIsImRlc3RydWN0dXJlIiwiYW55PyIsImJsb2NrIGluIGFueT8iLCJibG9jayAoMiBsZXZlbHMpIGluIGFueT8iLCJjaHVuayIsInRvX2VudW0iLCJibG9jayBpbiBjaHVuayIsImJsb2NrICgyIGxldmVscykgaW4gY2h1bmsiLCJlbnVtZXJhdG9yX3NpemUiLCJuZXciLCJFbnVtZXJhdG9yIiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJzbGljZV93aGVuIiwiYmxvY2sgaW4gY2h1bmtfd2hpbGUiLCJiZWZvcmUiLCJhZnRlciIsImJsb2NrICgyIGxldmVscykgaW4gY2h1bmtfd2hpbGUiLCIhIiwiY29sbGVjdCIsImVudW1fZm9yIiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwibWFwIiwiYmxvY2siLCJ0b19wcm9jIiwiZmxhdHRlbiIsIjEiLCJjb21wYWN0IiwidG9fYSIsImNvdW50Iiwib2JqZWN0IiwicmVzdWx0IiwiMCIsIndhcm4iLCJwcm9jIiwiYmxvY2sgaW4gY291bnQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvdW50IiwiYXJncyIsIj09IiwibmlsPyIsImN5Y2xlIiwibiIsImJsb2NrIGluIGN5Y2xlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjeWNsZSIsInJlc3BvbmRfdG8/IiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIj4iLCIqIiwiZGV0ZWN0IiwiaWZub25lIiwiYmxvY2sgaW4gZGV0ZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZXRlY3QiLCJkcm9wIiwibnVtYmVyIiwiZHJvcF93aGlsZSIsImVhY2hfY29ucyIsInRyeV9jb252ZXJ0IiwiYmxvY2sgaW4gZWFjaF9jb25zIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2NvbnMiLCJlbnVtX3NpemUiLCI8IiwiKyIsIi0iLCJlYWNoX2VudHJ5IiwiZGF0YSIsImJsb2NrIGluIGVhY2hfZW50cnkiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfZW50cnkiLCJlYWNoX3NsaWNlIiwiYmxvY2sgaW4gZWFjaF9zbGljZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9zbGljZSIsIi8iLCJzaXplIiwiY2VpbCIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGVhY2hfd2l0aF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX2luZGV4IiwiZWFjaF93aXRoX29iamVjdCIsImJsb2NrIGluIGVhY2hfd2l0aF9vYmplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9vYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyX21hcCIsImJsb2NrIGluIGZpbHRlcl9tYXAiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbHRlcl9tYXAiLCJzZWxlY3QiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImZpbmRfaW5kZXgiLCJpbmRleCIsImJsb2NrIGluIGZpbmRfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfaW5kZXgiLCJmaXJzdCIsImJsb2NrIGluIGZpcnN0IiwiY3VycmVudCIsImJsb2NrICgyIGxldmVscykgaW4gZmlyc3QiLCJncmVwIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJibG9jayBpbiBncmVwX3YiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXBfdiIsImdyb3VwX2J5IiwiYmxvY2sgaW4gZ3JvdXBfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyb3VwX2J5IiwiaGFzaCIsIiRyZXRfb3JfMSIsIltdPSIsIjw8IiwiaW5jbHVkZT8iLCJvYmoiLCJibG9jayBpbiBpbmNsdWRlPyIsImJsb2NrICgyIGxldmVscykgaW4gaW5jbHVkZT8iLCJpbmplY3QiLCJzeW0iLCJTeW1ib2wiLCI9PT0iLCJUeXBlRXJyb3IiLCJpbnNwZWN0IiwibGF6eSIsIkVudW1lcmF0b3I6OkxhenkiLCJibG9jayBpbiBsYXp5IiwiZW51bSQiLCJibG9jayAoMiBsZXZlbHMpIGluIGxhenkiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsImJsb2NrIGluIG1heF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWF4X2J5Iiwic29ydF9ieSIsInRha2UiLCJtaW4iLCJibG9jayBpbiBtaW4iLCJhIiwiYiIsImNvbXBhcmUiLCJtaW5fYnkiLCJibG9jayBpbiBtaW5fYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbl9ieSIsIm1pbm1heCIsImJsb2NrIGluIG1pbm1heCIsImJsb2NrICgyIGxldmVscykgaW4gbWlubWF4IiwiY2FsbCIsIm1pbm1heF9ieSIsImJsb2NrIGluIG1pbm1heF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWlubWF4X2J5Iiwibm9uZT8iLCJibG9jayBpbiBub25lPyIsImJsb2NrICgyIGxldmVscykgaW4gbm9uZT8iLCJpdGVtIiwib25lPyIsImJsb2NrIGluIG9uZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIG9uZT8iLCJwYXJ0aXRpb24iLCJibG9jayBpbiBwYXJ0aXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHBhcnRpdGlvbiIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gcmV2ZXJzZV9lYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXZlcnNlX2VhY2giLCJzbGljZV9iZWZvcmUiLCJibG9jayBpbiBzbGljZV9iZWZvcmUiLCJlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV9iZWZvcmUiLCJkdXAiLCJzbGljZV9hZnRlciIsImJsb2NrIGluIHNsaWNlX2FmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV9hZnRlciIsImJsb2NrIGluIHNsaWNlX3doZW4iLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX3doZW4iLCJhcnkiLCJibG9jayBpbiBzb3J0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0IiwiYmxvY2sgaW4gc29ydF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gc29ydF9ieSIsImFyZyIsInNvcnQhIiwibWFwISIsImkiLCJzdW0iLCJpbml0aWFsIiwiY29tcGVuc2F0aW9uIiwiYmxvY2sgaW4gc3VtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdW0iLCItQCIsInkiLCJ0IiwibnVtIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCJ1bmlxIiwiYmxvY2sgaW4gdW5pcSIsImJsb2NrICgyIGxldmVscykgaW4gdW5pcSIsInByb2R1Y2VkIiwia2V5PyIsInZhbHVlcyIsInRhbGx5Iiwib3V0IiwidHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrIGluIHRhbGx5IiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIHRhbGx5IiwiZmV0Y2giLCJ0b19oIiwiY29lcmNlX3RvPyIsIkFycmF5IiwiY2xhc3MiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiJBQUFBQSxxQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7Ozs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFRUMsSUFBQUEsb0JBQUFBLGdDQUFTQyxPQUFURCxHQUFBQSxNQUFBQSxJQUFBQSw4QkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7O01BQ0UsSUFBQSxRQUFJQSxxQkFBSixDQUFBO1FBQ0VFLE1BQUFDLElBQUFELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFFLGFBbkJOLEVBbUJNQSxFQUFBQzs7O1VBbkJOO1VBbUJlO1VBQ1BDLGFBQWNEO1VBRWQsSUFBQSxRQUEyQkUsTUFBUE4sT0FBT00sZUFBQUEsRUFBUCxDQUFvQixLQUFwQixDQUFBLFFBQTBCLE1BQUNELFVBQUQsQ0FBMUIsQ0FBT0MsQ0FBM0IsQ0FBQTtZQXRCUkYsT0FBQTtVQXNCUTtZQUFBLFNBQUEsUUFBTyxLQUFQO1VBQUEsRUFIRkQsQ0FBQUEsR0FBQUEsNkJBQUFBLENBQUFGO01BREYsT0FNQSxJQUFNTSxlQUFOO1FBQ0VOLE1BQUFDLElBQUFELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFFLGFBekJOLEVBeUJNQSxFQUFBQzs7O1VBekJOO1VBeUJlO1VBQ1AsSUFBQSxRQUFPLG1CQUFNLE1BQUNJ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LENBQU9zSCxnQkFBZixFQUE2QjRGLHFCQUFELEdBQUEsQ0FBc0JBLENBQUNBLEdBQURBLENBQUtHLE9BQUFBLENBQUFBLENBQTNCLENBQUEsR0FBa0NILG1CQUF0RGxOO0FBQ3BCa047QUFDQUE7QUFDQUEsVUFBWW5OLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDaU4sc0NBQUQsR0FBQSxDQUF1Q0EsQ0FBQ0EsR0FBREEsQ0FBS2xILFFBQUFBLENBQUFBLENBQTVDLENBQUEsR0FBb0RrSCxHQUE1RWxOO0FBQ3BCa047QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7SUF4QkVBLENBQUFBLElBQUFBOztBQTJCQUksSUFBQUEsbUJBQUFBLGVBdHZDRixFQXN2Q0VBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BdHZDRjtNQXN2Q1U7TUFDTkEsT0FBSUEsTUFBSjdPLElBQUE0QyxNQUFBQSxDQUFBQSxDQUFJaU0sT0FBQUEsRUFBSyxNQUFDQyxNQUFELENBQUxEO0lBRE5BLENBQUFBLElBQUFBO0lBSUEsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7SUFDQSxhQUFNLFVBQU4sRUFBZSxnQkFBZjtJQUNBLGFBQU0sS0FBTixFQUFVLFNBQVY7SUFDQSxhQUFNLFNBQU4sRUFBYyxVQUFkO0lBQ0EsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7SUFDQWpQLE9BQUEsYUFBTSxNQUFOLEVBQVcsU0FBWDtFQS92Q0ZBLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMjgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oYXNoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogeWllbGQxLCBoYXNoLCBoYXNoX2luaXQsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGRlbnlfZnJvemVuX2FjY2VzcywgZnJlZXplXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuIyAtLS1cbiMgSW50ZXJuYWwgcHJvcGVydGllczpcbiNcbiMgLSAkJG1hcCAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBvcmRpbmFyeSBrZXlzXG4jIC0gJCRzbWFwICAgICAgICBbSlM6Ok9iamVjdDxTdHJpbmcgPT4gaGFzaC1idWNrZXQ+XSB0aGUgaGFzaCB0YWJsZSBmb3Igc3RyaW5nIGtleXNcbiMgLSAkJGtleXMgICAgICAgIFtBcnJheTxoYXNoLWJ1Y2tldD5dIHRoZSBsaXN0IG9mIGFsbCBrZXlzXG4jIC0gJCRwcm9jICAgICAgICBbUHJvYyxudWxsLG5pbF0gdGhlIGRlZmF1bHQgcHJvYyB1c2VkIGZvciBtaXNzaW5nIGtleXNcbiMgLSBoYXNoLWJ1Y2tldCAgIFtKUzo6T2JqZWN0XSBhbiBlbGVtZW50IG9mIGEgbGlua2VkIGxpc3QgdGhhdCBob2xkcyBoYXNoIHZhbHVlcywga2V5cyBhcmUgYHtrZXk6LGtleV9oYXNoOix2YWx1ZTosbmV4dDp9YFxuY2xhc3MgOjpIYXNoXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgIyBNYXJrIGFsbCBoYXNoIGluc3RhbmNlcyBhcyB2YWxpZCBoYXNoZXMgKHVzZWQgdG8gY2hlY2sga2V5d29yZCBhcmdzLCBldGMpXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfaGFzaCA9IHRydWVgXG5cbiAgZGVmIHNlbGYuW10oKmFyZ3YpXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCwgYXJnYyA9IGFyZ3YubGVuZ3RoLCBpO1xuXG4gICAgICBpZiAoYXJnYyA9PT0gMSkge1xuICAgICAgICBoYXNoID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCA6Okhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCA6OkFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmIChhcmd2ID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzICgje2Bhcmd2W2ldLmxlbmd0aGB9IGZvciAxLi4yKVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnYyAlIDIgIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkgKz0gMikge1xuICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldLCBhcmd2W2kgKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuXG4gICAgICAkaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyhvYmosIDo6SGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9ICRoYXNoX2dldChvdGhlciwga2V5LmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3RoZXJfdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdmFsdWVbJyRlcWw/J10ob3RoZXJfdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDw9IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZiA+PSBvdGhlclxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuICAgIG90aGVyID4gc2VsZlxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChrZXkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShrZXksIHZhbHVlKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBpZiAoI3tga2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgc2VsZi4kJHNtYXBba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgje2BrZXkua2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleS5rZXksIGtleS52YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgICRoYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgICRoYXNoX2luaXQoaGFzaCk7XG4gICAgICBPcGFsLmhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3RcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmICgkaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzX3dlcmVfbWFkZSA9IHRydWU7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXNfd2VyZV9tYWRlID8gc2VsZiA6IG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5XG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgaSwgaWksIGtleSwga2V5cyA9IHNlbGYuJCRrZXlzLCBpZGVudGl0eV9oYXNoO1xuXG4gICAgICBpZiAoc2VsZi4kJGJ5X2lkZW50aXR5KSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWRlbnRpdHlfaGFzaCA9ICN7IHt9LmNvbXBhcmVfYnlfaWRlbnRpdHkgfTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFrZXkuJCRpc19zdHJpbmcpIGtleSA9IGtleS5rZXk7XG4gICAgICAgICRoYXNoX3B1dChpZGVudGl0eV9oYXNoLCBrZXksICRoYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgcHJvY2AsIDo6UHJvYywgOnRvX3Byb2MpfTtcblxuICAgICAgICBpZiAoI3tgcHJvY2AubGFtYmRhP30gJiYgI3tgcHJvY2AuYXJpdHkuYWJzfSAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG4gICAgICB2YXIgdmFsdWUgPSAkaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmICgkaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnKGtleSwgKmtleXMpXG4gICAgaXRlbSA9IHNlbGZba2V5XVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLnNsaWNlKCksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICAkeWllbGQxKGJsb2NrLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2tleSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2tleSkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMuc2xpY2UoKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgYmxvY2soa2V5LiQkaXNfc3RyaW5nID8ga2V5IDoga2V5LmtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfdmFsdWUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF92YWx1ZSkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMuc2xpY2UoKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgYmxvY2soa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLiQka2V5cy5sZW5ndGggPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBleGNlcHQoKmtleXMpXG4gICAgZHVwLmV4Y2VwdCEoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBleGNlcHQhKCprZXlzKVxuICAgIGtleXMuZWFjaCB7IHxrZXl8IGRlbGV0ZShrZXkpIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gYmxvY2soa2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIDo6S2VybmVsLnJhaXNlIDo6S2V5RXJyb3IubmV3KFwia2V5IG5vdCBmb3VuZDogI3trZXkuaW5zcGVjdH1cIiwga2V5OiBrZXksIHJlY2VpdmVyOiBzZWxmKVxuICBlbmRcblxuICBkZWYgZmV0Y2hfdmFsdWVzKCprZXlzLCAmYmxvY2spXG4gICAga2V5cy5tYXAgeyB8a2V5fCBmZXRjaChrZXksICZibG9jaykgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbihsZXZlbCA9IDEpXG4gICAgbGV2ZWwgPSA6Ok9wYWwuY29lcmNlX3RvIShsZXZlbCwgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KCN7YHZhbHVlYC5mbGF0dGVuKGBsZXZlbCAtIDJgKX0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZyZWV6ZVxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cblxuICAgIGAkZnJlZXplKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaGFzX2tleT8oa2V5KVxuICAgIGAkaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4ZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGFyZ3NbaV07XG4gICAgICAgIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIH1cblxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIGluc3BlY3RfaWRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zcGVjdF9pZHMuaGFzT3duUHJvcGVydHkoaGFzaF9pZCkpIHtcbiAgICAgICAgICByZXR1cm4gJ3suLi59JztcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3BlY3RfaWRzW2hhc2hfaWRdID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9ICN7T3BhbC5pbnNwZWN0KGBrZXlgKX1cbiAgICAgICAgICB2YWx1ZSA9ICN7T3BhbC5pbnNwZWN0KGB2YWx1ZWApfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5ICsgJz0+JyArIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAneycgKyByZXN1bHQuam9pbignLCAnKSArICd9JztcbiAgICAgIH1cbiAgICAgIG5pbFxuICAgIGVuc3VyZVxuICAgICAgYGlmICh0b3ApIGluc3BlY3RfaWRzID0gdW5kZWZpbmVkYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW52ZXJ0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZXlzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS5rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIG1lcmdlKCpvdGhlcnMsICZibG9jaylcbiAgICBkdXAubWVyZ2UhKCpvdGhlcnMsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuICAgICAgdmFyIGksIGosIG90aGVyLCBvdGhlcl9rZXlzLCBsZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdGhlciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG90aGVyc1tpXWAsIDo6SGFzaCwgOnRvX2hhc2gpfTtcbiAgICAgICAgb3RoZXJfa2V5cyA9IG90aGVyLiQka2V5cywgbGVuZ3RoID0gb3RoZXJfa2V5cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGtleSA9IG90aGVyX2tleXNbal07XG5cbiAgICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tqXTtcblxuICAgICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIGJsb2NrKGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlaGFzaFxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgIE9wYWwuaGFzaF9yZWhhc2goc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAkaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVwbGFjZShvdGhlcilcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtgXG5cbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICAkaGFzaF9pbml0KHNlbGYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgb3RoZXJfa2V5cyA9IG90aGVyLiQka2V5cywgbGVuZ3RoID0gb3RoZXJfa2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIG90aGVyLmRlZmF1bHRfcHJvY1xuICAgICAgc2VsZi5kZWZhdWx0X3Byb2MgPSBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICBlbHNlXG4gICAgICBzZWxmLmRlZmF1bHQgPSBvdGhlci5kZWZhdWx0XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAkaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gbmlsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIGlmICgkaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNoaWZ0XG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCAkaGFzaF9kZWxldGUoc2VsZiwga2V5KV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRkZWZhdWx0KG5pbCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICAgICRoYXNoX2luaXQoaGFzaCk7XG4gICAgICBPcGFsLmhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2hhc2hcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgcHJvYyBkbyB8a2V5ID0gdW5kZWZpbmVkfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8ga2V5IGdpdmVuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmW2tleV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSAkeWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgICRoYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIga2V5cyA9IE9wYWwuc2xpY2UuY2FsbChzZWxmLiQka2V5cyksXG4gICAgICAgICAgaSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG5ld19rZXk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld19rZXkgPSAkeWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICAkaGFzaF9wdXQoc2VsZiwgbmV3X2tleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICRoYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBkdXAgY2xvbmVcbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuICBhbGlhcyBpbmRpY2VzIGluZGV4ZXNcbiAgYWxpYXMga2V5IGluZGV4XG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzdG9yZSBbXT1cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHVwZGF0ZSBtZXJnZSFcbiAgYWxpYXMgdmFsdWU/IGhhc192YWx1ZT9cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpIYXNoPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiW10iLCJPcGFsIiwiY29lcmNlX3RvPyIsImFyZ3YiLCIwIiwiSGFzaCIsImFsbG9jYXRlIiwibWVyZ2UhIiwiQXJyYXkiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCJkZWZhdWx0cyIsIj09Iiwib3RoZXIiLCI+PSIsImNvZXJjZV90byEiLCJyZXN1bHQiLCJlYWNoIiwiYmxvY2sgaW4gPj0iLCJvdGhlcl9rZXkiLCJvdGhlcl92YWwiLCJibG9jayAoMiBsZXZlbHMpIGluID49IiwidmFsIiwiZmV0Y2giLCI+IiwiPCIsIjw9Iiwia2V5IiwiW109IiwidmFsdWUiLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwiUHJvYyIsImxhbWJkYT8iLCJhcml0eSIsImFicyIsIlR5cGVFcnJvciIsImRlbGV0ZSIsImRlbGV0ZV9pZiIsImJsb2NrIiwiZW51bV9mb3IiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImtleXMiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9rZXkiLCJibG9jayBpbiBlYWNoX2tleSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiYmxvY2sgaW4gZWFjaF92YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF92YWx1ZSIsImVtcHR5PyIsImV4Y2VwdCIsImV4Y2VwdCEiLCJkdXAiLCJibG9jayBpbiBleGNlcHQhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBleGNlcHQhIiwiS2V5RXJyb3IiLCJuZXciLCJpbnNwZWN0IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiYmxvY2sgaW4gZmV0Y2hfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmZXRjaF92YWx1ZXMiLCJ0b19wcm9jIiwiZmxhdHRlbiIsImxldmVsIiwiMSIsIkludGVnZXIiLCJmcmVlemUiLCJmcm96ZW4/IiwiaGFzX2tleT8iLCJoYXNfdmFsdWU/IiwiaGFzaCIsImVxbD8iLCJpbmRleCIsImluZGV4ZXMiLCJpbnZlcnQiLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxlbmd0aCIsIm1lcmdlIiwib3RoZXJzIiwicmFzc29jIiwicmVoYXNoIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsInJlcGxhY2UiLCJzZWxlY3QiLCJibG9jayBpbiBzZWxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCIsInNlbGVjdCEiLCJibG9jayBpbiBzZWxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QhIiwic2hpZnQiLCJzbGljZSIsInRvX2EiLCJ0b19oIiwiYmxvY2tfZ2l2ZW4/IiwidG9faGFzaCIsInByb2MiLCJibG9jayBpbiB0b19wcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19wcm9jIiwidHJhbnNmb3JtX2tleXMiLCJibG9jayBpbiB0cmFuc2Zvcm1fa2V5cyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX2tleXMiLCJ0cmFuc2Zvcm1fa2V5cyEiLCJibG9jayBpbiB0cmFuc2Zvcm1fa2V5cyEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV9rZXlzISIsInRyYW5zZm9ybV92YWx1ZXMiLCJibG9jayBpbiB0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fdmFsdWVzIiwidHJhbnNmb3JtX3ZhbHVlcyEiLCJibG9jayBpbiB0cmFuc2Zvcm1fdmFsdWVzISIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX3ZhbHVlcyEiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBVUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDtJQUVERyxNQUFJTCxJQUFKSyxTQUFBQSxvQkFsQkYsRUFrQkVBO0FBQUFBLE1BQUFBOzs7TUFsQkY7TUFrQmM7O0FBRWRBOztBQUVBQTtBQUNBQSxlQUFpQkMsS0FBTUMsZUFBQUEsQ0FBWUMsSUFBSUgsT0FBQUEsQ0FBQ0ksQ0FBREosQ0FBdEIsRUFBMkJLLFdBQTNCLEVBQW1DLFNBQTdCSCxDQUF1Q0Y7QUFDOURBO0FBQ0FBLGlCQUFtQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBUUMsV0FBQUEsQ0FBU1AsSUFB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QSxHQUFBQTs7QUF5QkFHLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQWZFQSxDQUFBQSxHQUFBQTtJQWtCQSxhQUFNLEtBQU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxVQUFOLEVBQWUsVUFBZjtJQUNBLGFBQU0sU0FBTixFQUFjLFNBQWQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxNQUFOLEVBQVcsVUFBWDtJQUNBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUFDQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxPQUFOLEVBQVksS0FBWjtJQUNBLGFBQU0sTUFBTixFQUFXLFNBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBQ0EsYUFBTSxRQUFOLEVBQWEsWUFBYjtJQUNBL0ksT0FBQSxhQUFNLFdBQU4sRUFBZ0IsU0FBaEI7RUFodENGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBWkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjc4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtYmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgOjpOdW1iZXIgPCA6Ok51bWVyaWNcbiAgOjpPcGFsLmJyaWRnZShgTnVtYmVyYCwgc2VsZilcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gWyN7OjpLZXJuZWwuRmxvYXQob3RoZXIpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/KDp0b19mKX0pIHtcbiAgICAgICAgcmV0dXJuIFsjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkZsb2F0LCA6dG9fZil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBbb3RoZXIsIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9faWRfX1xuICAgIGAoc2VsZiAqIDIpICsgMWBcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Lywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPCAwIHx8IHNlbGYgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIChzZWxmICUgb3RoZXIgKyBvdGhlcikgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZiAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiUsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICYgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiYsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIHwgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOnwsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIF4gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOl4sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDwgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjwsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID4gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj4sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Pj0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gICMgQ29tcHV0ZSB0aGUgcmVzdWx0IG9mIHRoZSBzcGFjZXNoaXAgb3BlcmF0b3IgaW5zaWRlIGl0cyBvd24gZnVuY3Rpb24gc28gaXRcbiAgIyBjYW4gYmUgb3B0aW1pemVkIGRlc3BpdGUgYSB0cnkvZmluYWxseSBjb25zdHJ1Y3QuXG4gICV4e1xuICAgIHZhciBzcGFjZXNoaXBfb3BlcmF0b3IgPSBmdW5jdGlvbihzZWxmLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChpc05hTihzZWxmKSB8fCBpc05hTihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYgPiBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYgPCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PT4sIGBvdGhlcmB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgYHNwYWNlc2hpcF9vcGVyYXRvcihzZWxmLCBvdGhlcilgXG4gIHJlc2N1ZSA6OkFyZ3VtZW50RXJyb3JcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIDw8KGNvdW50KVxuICAgIGNvdW50ID0gOjpPcGFsLmNvZXJjZV90byEgY291bnQsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPDwgI3tjb3VudH0gOiBzZWxmID4+IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmID4+KGNvdW50KVxuICAgIGNvdW50ID0gOjpPcGFsLmNvZXJjZV90byEgY291bnQsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPj4gI3tjb3VudH0gOiBzZWxmIDw8IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmIFtdKGJpdClcbiAgICBiaXQgPSA6Ok9wYWwuY29lcmNlX3RvISBiaXQsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3tiaXR9IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmICgje2JpdH0gPj0gMzIpIHtcbiAgICAgICAgcmV0dXJuICN7IHNlbGYgfSA8IDAgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc2VsZiA+PiAje2JpdH0pICYgMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIGArc2VsZmBcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgYC1zZWxmYFxuICBlbmRcblxuICBkZWYgflxuICAgIGB+c2VsZmBcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmICEoOjpJbnRlZ2VyID09PSBzZWxmKSB8fCBvdGhlciA+IDBcbiAgICAgICAgYE1hdGgucG93KHNlbGYsIG90aGVyKWBcbiAgICAgIGVsc2VcbiAgICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSkqKm90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiBzZWxmIDwgMCAmJiAoOjpGbG9hdCA9PT0gb3RoZXIgfHwgOjpSYXRpb25hbCA9PT0gb3RoZXIpXG4gICAgICA6OkNvbXBsZXgubmV3KHNlbGYsIDApKipvdGhlci50b19mXG4gICAgZWxzaWYgYG90aGVyLiQkaXNfbnVtYmVyICE9IG51bGxgXG4gICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzID09PSA9PVxuXG4gIGRlZiBhYnNcbiAgICBgTWF0aC5hYnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgYE1hdGguYWJzKHNlbGYgKiBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFsbGJpdHM/KG1hc2spXG4gICAgbWFzayA9IDo6T3BhbC5jb2VyY2VfdG8hIG1hc2ssIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSA6Ok9wYWwuY29lcmNlX3RvISBtYXNrLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgcmV0dXJuIHNlbGYgaWYgbmFuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIGlmICgxIC8gc2VsZiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZiA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYml0X2xlbmd0aFxuICAgIHVubGVzcyA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBiaXRfbGVuZ3RoYCBmb3IgI3tzZWxmfTpGbG9hdFwiLCAnYml0X2xlbmd0aCcpXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSAwIHx8IHNlbGYgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICB2YWx1ZSAgPSBzZWxmIDwgMCA/IH5zZWxmIDogc2VsZjtcblxuICAgICAgd2hpbGUgKHZhbHVlICE9IDApIHtcbiAgICAgICAgcmVzdWx0ICAgKz0gMTtcbiAgICAgICAgdmFsdWUgID4+Pj0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZWlsKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguY2VpbChmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHIoZW5jb2RpbmcgPSB1bmRlZmluZWQpXG4gICAgYE9wYWwuZW5jKFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZiksIGVuY29kaW5nIHx8IFwiQklOQVJZXCIpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgOjpOdW1lcmljID09PSBzdG9wXG4gICAgICAgIHN0b3AgPiBzZWxmID8gMCA6IHNlbGYgLSBzdG9wICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghc3RvcC4kJGlzX251bWJlcikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyIHx8IGBpc05hTihzZWxmKSAmJiBpc05hTihvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiBldmVuP1xuICAgIGBzZWxmICUgMiA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkKG90aGVyKVxuICAgIHVubGVzcyA6OkludGVnZXIgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkKG90aGVyKSwgbGNtKG90aGVyKV1cbiAgZW5kXG5cbiAgZGVmIGludGVnZXI/XG4gICAgYHNlbGYgJSAxID09PSAwYFxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBsY20ob3RoZXIpXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDAgfHwgb3RoZXIgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZiAqIG90aGVyIC8gI3tnY2Qob3RoZXIpfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgIGBzZWxmICsgMWBcbiAgZW5kXG5cbiAgZGVmIG5vYml0cz8obWFzaylcbiAgICBtYXNrID0gOjpPcGFsLmNvZXJjZV90byEgbWFzaywgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgYHNlbGYgPT0gMCA/IG5pbCA6IHNlbGZgXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvZGQ/XG4gICAgYHNlbGYgJSAyICE9PSAwYFxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG93KGIsIG0gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZioqYn07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISgjezo6SW50ZWdlciA9PT0gYn0pKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhIDFzdCBhcmd1bWVudCBpcyBpbnRlZ2VyJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDFzdCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAybmQgYXJndW1lbnQgc3BlY2lmaWVkJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBtfSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjeyhzZWxmKipiKSAlIG19XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlZFxuICAgIGBzZWxmIC0gMWBcbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2VsZiAvIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIDo6UmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICBlbHNpZiBuYW4/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgYGVwcyA9PSBudWxsYFxuICAgICAgZiwgbiAgPSA6Ok1hdGguZnJleHAgc2VsZlxuICAgICAgZiAgICAgPSA6Ok1hdGgubGRleHAoZiwgOjpGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIG4gICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgOjpSYXRpb25hbC5uZXcoMiAqIGYsIDEgPDwgKDEgLSBuKSkucmF0aW9uYWxpemUoOjpSYXRpb25hbC5uZXcoMSwgMSA8PCAoMSAtIG4pKSlcbiAgICBlbHNlXG4gICAgICB0b19yLnJhdGlvbmFsaXplKGVwcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlbWFpbmRlcih5KVxuICAgIHNlbGYgLSB5ICogKHNlbGYgLyB5KS50cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgcm91bmQobmRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIGlmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgOjpGbG9hdCA9PT0gbmRpZ2l0cyAmJiBuZGlnaXRzLmluZmluaXRlP1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdJbmZpbml0eSdcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gOjpPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDwgOjpJbnRlZ2VyOjpNSU5cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSAtbmRpZ2l0c1xuXG4gICAgICAleHtcbiAgICAgICAgaWYgKDAuNDE1MjQxICogbmRpZ2l0cyAtIDAuMTI1ID4gI3tzaXplfSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoc2VsZikgKyBmIC8gMikgLyBmKSAqIGY7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgPCAwID8gLXggOiB4O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIG5hbj8gJiYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSA6Ok9wYWwuY29lcmNlX3RvIShgbmRpZ2l0cyB8fCAwYCwgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDw9IDBcbiAgICAgICAgaWYgbmFuP1xuICAgICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ05hTidcbiAgICAgICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgbmRpZ2l0cyA9PSAwXG4gICAgICAgIHJldHVybiBgTWF0aC5yb3VuZChzZWxmKWBcbiAgICAgIGVsc2lmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgXywgZXhwID0gOjpNYXRoLmZyZXhwKHNlbGYpXG5cbiAgICAgIGlmIG5kaWdpdHMgPj0gKDo6RmxvYXQ6OkRJRyArIDIpIC0gKGV4cCA+IDAgPyBleHAgLyA0IDogZXhwIC8gMyAtIDEpXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgbmRpZ2l0cyA8IC0oZXhwID4gMCA/IGV4cCAvIDMgKyAxIDogZXhwIC8gNClcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGVuZFxuXG4gICAgICBgTWF0aC5yb3VuZChzZWxmICogTWF0aC5wb3coMTAsIG5kaWdpdHMpKSAvIE1hdGgucG93KDEwLCBuZGlnaXRzKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRpbWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRpbWVzKSB7IHNlbGYgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgc2VsZiA8IDAgPyBNYXRoLmNlaWwoc2VsZikgOiBNYXRoLmZsb29yKHNlbGYpYFxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IDo6TWF0aC5mcmV4cChzZWxmKVxuICAgICAgZiAgICAgPSA6Ok1hdGgubGRleHAoZiwgOjpGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgKGYgKiAoOjpGbG9hdDo6UkFESVgqKmUpKS50b19yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19zKGJhc2UgPSAxMClcbiAgICBiYXNlID0gOjpPcGFsLmNvZXJjZV90byEgYmFzZSwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMiB8fCBiYXNlID4gMzZcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgIyBEb24ndCBsb3NlIHRoZSBuZWdhdGl2ZSB6ZXJvXG4gICAgaWYgc2VsZiA9PSAwICYmIGAxL3NlbGYgPT09IC1JbmZpbml0eWBcbiAgICAgIHJldHVybiAnLTAuMCdcbiAgICBlbmRcblxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZ2l0cyhiYXNlID0gMTApXG4gICAgaWYgc2VsZiA8IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TWF0aDo6RG9tYWluRXJyb3IsICdvdXQgb2YgZG9tYWluJ1xuICAgIGVuZFxuXG4gICAgYmFzZSA9IDo6T3BhbC5jb2VyY2VfdG8hIGJhc2UsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiAhPSBwYXJzZUludChzZWxmKSkgI3s6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IsIFwidW5kZWZpbmVkIG1ldGhvZCBgZGlnaXRzJyBmb3IgI3tpbnNwZWN0fVwifVxuXG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSAlIGJhc2UpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlIC8gYmFzZSwgMTApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBpZiBuYW4/IHx8IG90aGVyLm5hbj9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyA6Ok51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA8IHNlbGYgPyAwIDogc3RvcCAtIHNlbGYgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBudW1iZXJUb1VpbnQ4QXJyYXkobnVtKSB7XG4gICAgICB2YXIgdWludDhhcnJheSA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgbmV3IERhdGFWaWV3KHVpbnQ4YXJyYXkuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIG51bSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdWludDhhcnJheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1aW50OEFycmF5VG9OdW1iZXIoYXJyKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIpLmdldEZsb2F0NjQoMCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5jcmVtZW50TnVtYmVyQml0KG51bSkge1xuICAgICAgdmFyIGFyciA9IG51bWJlclRvVWludDhBcnJheShudW0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gMHhmZikge1xuICAgICAgICAgIGFycltpXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyW2ldKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1aW50OEFycmF5VG9OdW1iZXIoYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNyZW1lbnROdW1iZXJCaXQobnVtKSB7XG4gICAgICB2YXIgYXJyID0gbnVtYmVyVG9VaW50OEFycmF5KG51bSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSAwKSB7XG4gICAgICAgICAgYXJyW2ldID0gMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJbaV0tLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBuZXh0X2Zsb2F0XG4gICAgcmV0dXJuIDo6RmxvYXQ6OklORklOSVRZIGlmIHNlbGYgPT0gOjpGbG9hdDo6SU5GSU5JVFlcbiAgICByZXR1cm4gOjpGbG9hdDo6TkFOIGlmIG5hbj9cblxuICAgIGlmIHNlbGYgPj0gMFxuICAgICAgIyBNYXRoLmFicygpIGlzIG5lZWRlZCB0byBoYW5kbGUgLTAuMFxuICAgICAgYGluY3JlbWVudE51bWJlckJpdChNYXRoLmFicyhzZWxmKSlgXG4gICAgZWxzZVxuICAgICAgYGRlY3JlbWVudE51bWJlckJpdChzZWxmKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByZXZfZmxvYXRcbiAgICByZXR1cm4gLTo6RmxvYXQ6OklORklOSVRZIGlmIHNlbGYgPT0gLTo6RmxvYXQ6OklORklOSVRZXG4gICAgcmV0dXJuIDo6RmxvYXQ6Ok5BTiBpZiBuYW4/XG5cbiAgICBpZiBzZWxmID4gMFxuICAgICAgYGRlY3JlbWVudE51bWJlckJpdChzZWxmKWBcbiAgICBlbHNlXG4gICAgICBgLWluY3JlbWVudE51bWJlckJpdChNYXRoLmFicyhzZWxmKSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGZkaXYgL1xuICBhbGlhcyBpbnNwZWN0IHRvX3NcbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuICBhbGlhcyBtb2R1bG8gJVxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG4gIGFsaWFzIHBoYXNlIGFuZ2xlXG4gIGFsaWFzIHN1Y2MgbmV4dFxuICBhbGlhcyB0b19pbnQgdG9faVxuZW5kXG5cbjo6Rml4bnVtID0gOjpOdW1iZXJcblxuY2xhc3MgOjpJbnRlZ2VyIDwgOjpOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcbiAgYHNlbGYuJCRpc19pbnRlZ2VyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiBzcXJ0KG4pXG4gICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgJXh7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpNYXRoOjpEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJpc3FydFwiJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChNYXRoLnNxcnQobiksIDEwKTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiB0cnlfY29udmVydChvYmplY3QpXG4gICAgICBPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCBzZWxmLCA6dG9faW50KVxuICAgIGVuZFxuICBlbmRcblxuICBzZWxmOjpNQVggPSBgTWF0aC5wb3coMiwgMzApIC0gMWBcbiAgc2VsZjo6TUlOID0gYC1NYXRoLnBvdygyLCAzMClgXG5lbmRcblxuY2xhc3MgOjpGbG9hdCA8IDo6TnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG5cbiAgICBkZWYgPT09KG90aGVyKVxuICAgICAgYCEhb3RoZXIuJCRpc19udW1iZXJgXG4gICAgZW5kXG4gIGVuZFxuXG4gIHNlbGY6OklORklOSVRZID0gYEluZmluaXR5YFxuICBzZWxmOjpNQVggICAgICA9IGBOdW1iZXIuTUFYX1ZBTFVFYFxuICBzZWxmOjpNSU4gICAgICA9IGBOdW1iZXIuTUlOX1ZBTFVFYFxuICBzZWxmOjpOQU4gICAgICA9IGBOYU5gXG5cbiAgc2VsZjo6RElHICAgICAgPSAxNVxuICBzZWxmOjpNQU5UX0RJRyA9IDUzXG4gIHNlbGY6OlJBRElYICAgID0gMlxuXG4gIHNlbGY6OkVQU0lMT04gPSBgTnVtYmVyLkVQU0lMT04gfHwgMi4yMjA0NDYwNDkyNTAzMTMwODA4NDcyNjMzMzYxODE2RS0xNmBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpOdW1iZXI+IiwiT3BhbCIsImJyaWRnZSIsImFsbG9jYXRlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuYW1lIiwiY29lcmNlIiwib3RoZXIiLCJjbGFzcyIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIlplcm9EaXZpc2lvbkVycm9yIiwiJiIsInwiLCJeIiwiPCIsIjw9IiwiPiIsIj49IiwiPD0+IiwiQXJndW1lbnRFcnJvciIsIjw8IiwiY291bnQiLCJJbnRlZ2VyIiwiPj4iLCJbXSIsImJpdCIsIitAIiwiLUAiLCJ+IiwiKioiLCI9PT0iLCIwIiwiUmF0aW9uYWwiLCJuZXciLCIxIiwiQ29tcGxleCIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJOb01ldGhvZEVycm9yIiwiY2VpbCIsIm5kaWdpdHMiLCJjaHIiLCJlbmNvZGluZyIsImRlbm9taW5hdG9yIiwiaW5maW5pdGU/IiwiZG93bnRvIiwic3RvcCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZG93bnRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkb3dudG8iLCJOdW1lcmljIiwiZXF1YWw/IiwiJHJldF9vcl8xIiwiZXZlbj8iLCJmbG9vciIsImdjZCIsImdjZGxjbSIsImxjbSIsImludGVnZXI/IiwiaXNfYT8iLCJrbGFzcyIsImluc3RhbmNlX29mPyIsIm5leHQiLCJub2JpdHM/Iiwibm9uemVybz8iLCJudW1lcmF0b3IiLCJvZGQ/Iiwib3JkIiwicG93IiwiYiIsIm0iLCJwcmVkIiwicXVvIiwicmF0aW9uYWxpemUiLCJlcHMiLCJGbG9hdERvbWFpbkVycm9yIiwiTWF0aCIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsIkZsb2F0OjpNQU5UX0RJRyIsInRvX2kiLCIyIiwidG9fciIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiUmFuZ2VFcnJvciIsIkludGVnZXI6Ok1JTiIsInNpemUiLCJfIiwiZXhwIiwiRmxvYXQ6OkRJRyIsIjQiLCIzIiwidGltZXMiLCJibG9jayIsImJsb2NrIGluIHRpbWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0aW1lcyIsImUiLCJGbG9hdDo6UkFESVgiLCJ0b19zIiwiYmFzZSIsIjEwIiwiMzYiLCJkaWdpdHMiLCJNYXRoOjpEb21haW5FcnJvciIsImluc3BlY3QiLCJkaXZtb2QiLCJ1cHRvIiwiYmxvY2sgaW4gdXB0byIsImJsb2NrICgyIGxldmVscykgaW4gdXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsIm5leHRfZmxvYXQiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdDo6TkFOIiwicHJldl9mbG9hdCIsIk51bWJlciIsIjxjbGFzczpJbnRlZ2VyPiIsInNxcnQiLCJ0cnlfY29udmVydCIsIm9iamVjdCIsImNvZXJjZV90bz8iLCI8Y2xhc3M6RmxvYXQ+IiwiMTUiLCI1MyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsS0FBTUMsUUFBQUEsQ0FBU0YsTUFBZixFQUF3QkYsSUFBbEJJO0lBQ0xGO0lBQ0FBO0lBRUQ7Ozs7QUFDRUcsTUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJILDBCQUFELEdBQUEsQ0FBMkJMLElBQUFTLE1BQUFBLENBQUFBLENBQTNCLENBQXBCRjtNQURWRixDQUFBQSxHQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQVpKLE9BQUE7SUFPRSw0QkFBU0wsSUFBVDs7QUFRQVUsSUFBQUEsc0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxN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LG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJILDBCQUFELEdBQUEsQ0FBMkJMLElBQUFTLE1BQUFBLENBQUFBLENBQTNCLENBQXBCRjtNQURWRixDQUFBQSxHQUFBQTs7TUFJQSxzQkFBTSxLQUFOO01BRUEsT0FBQXNDLG1CQUFBQSxzQkFBUWhDLEtBQVJnQztBQUFBQTtRQUNFQSxPQUFDQSxtQkFBREE7TUFERkEsQ0FBQUEsR0FBQUE7SUFQRiw0QkFBUzNDLElBQVQ7SUFZQSxXQUFBQSxJQUFBLGNBQWtCc0osUUFBbEI7SUFDQSxXQUFBdEosSUFBQSxTQUFrQnNKLGdCQUFsQjtJQUNBLFdBQUF0SixJQUFBLFNBQWtCc0osZ0JBQWxCO0lBQ0EsV0FBQXRKLElBQUEsU0FBa0JzSixHQUFsQjtJQUVBLFdBQUF0SixJQUFBLFNBQWlCdUosRUFBakI7SUFDQSxXQUFBdkosSUFBQSxjQUFpQndKLEVBQWpCO0lBQ0EsV0FBQXhKLElBQUEsV0FBaUJ5RyxDQUFqQjtJQUVBNkMsT0FBQSxXQUFBdEosSUFBQSxhQUFpQnNKLHVEQUFqQjtFQXhCRkEsR0FBTSxJQUFOQSxFQUFnQjlFLGNBQWhCOEU7QUFsNUJBdko7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzOTQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogc2xpY2UsIGNvZXJjZV90bywgZGVueV9mcm96ZW5fYWNjZXNzXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19lbnVtZXJhdG9yID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5mb3Iob2JqZWN0LCBtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSAje2FsbG9jYXRlfTtcblxuICAgICAgb2JqLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIG9iai5zaXplICAgPSBibG9jaztcbiAgICAgIG9iai5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBvYmouYXJncyAgID0gYXJncztcbiAgICAgIG9iai5jdXJzb3IgPSAwO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgQGN1cnNvciA9IDBcbiAgICBpZiBibG9ja1xuICAgICAgQG9iamVjdCA9IEdlbmVyYXRvci5uZXcoJmJsb2NrKVxuICAgICAgQG1ldGhvZCA9IDplYWNoXG4gICAgICBAYXJncyAgID0gW11cbiAgICAgIEBzaXplICAgPSBgYXJndW1lbnRzWzBdIHx8IG5pbGBcblxuICAgICAgaWYgQHNpemUgJiYgIUBzaXplLnJlc3BvbmRfdG8/KDpjYWxsKVxuICAgICAgICBAc2l6ZSA9IGAkY29lcmNlX3RvKCN7QHNpemV9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZS5jYWxsKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgQHNpemUucmVzcG9uZF90bz8oOmNhbGwpID8gQHNpemUuY2FsbCgqQGFyZ3MpIDogQHNpemVcbiAgZW5kXG5cbiAgZGVmIHdpdGhfaW5kZXgob2Zmc2V0ID0gMCwgJmJsb2NrKVxuICAgIG9mZnNldCA9IGlmIG9mZnNldFxuICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOndpdGhfaW5kZXgsIG9mZnNldCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsIGluZGV4ID0gb2Zmc2V0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZWFjaCgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHN1cGVyXG4gICAgQG9iamVjdFxuICBlbmRcblxuICBkZWYgcmV3aW5kXG4gICAgQGN1cnNvciA9IDBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBlZWtfdmFsdWVzXG4gICAgQHZhbHVlcyB8fD0gbWFwIHsgfCppfCBpIH1cbiAgICA6Oktlcm5lbC5yYWlzZSA6OlN0b3BJdGVyYXRpb24sICdpdGVyYXRpb24gcmVhY2hlZCBhbiBlbmQnIGlmIEBjdXJzb3IgPj0gQHZhbHVlcy5sZW5ndGhcbiAgICBAdmFsdWVzW0BjdXJzb3JdXG4gIGVuZFxuXG4gIGRlZiBwZWVrXG4gICAgdmFsdWVzID0gcGVla192YWx1ZXNcbiAgICB2YWx1ZXMubGVuZ3RoIDw9IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIG5leHRfdmFsdWVzXG4gICAgb3V0ID0gcGVla192YWx1ZXNcbiAgICBAY3Vyc29yICs9IDFcbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIG5leHRcbiAgICB2YWx1ZXMgPSBuZXh0X3ZhbHVlc1xuICAgIHZhbHVlcy5sZW5ndGggPD0gMSA/IHZhbHVlc1swXSA6IHZhbHVlc1xuICBlbmRcblxuICBkZWYgZmVlZChhcmcpXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgXCJPcGFsIGRvZXNuJ3Qgc3VwcG9ydCBFbnVtZXJhdG9yI2ZlZWRcIlxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICA6OkVudW1lcmF0b3I6OkNoYWluLm5ldyhzZWxmLCBvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICByZXN1bHQgPSBcIiM8I3tzZWxmLmNsYXNzfTogI3tAb2JqZWN0Lmluc3BlY3R9OiN7QG1ldGhvZH1cIlxuXG4gICAgaWYgQGFyZ3MuYW55P1xuICAgICAgcmVzdWx0ICs9IFwiKCN7QGFyZ3MuaW5zcGVjdFs6OlJhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGFsaWFzIHdpdGhfb2JqZWN0IGVhY2hfd2l0aF9vYmplY3RcblxuICBhdXRvbG9hZCA6QXJpdGhtZXRpY1NlcXVlbmNlLCAnY29yZWxpYi9lbnVtZXJhdG9yL2FyaXRobWV0aWNfc2VxdWVuY2UnXG4gIGF1dG9sb2FkIDpDaGFpbiwgJ2NvcmVsaWIvZW51bWVyYXRvci9jaGFpbidcbiAgYXV0b2xvYWQgOkdlbmVyYXRvciwgJ2NvcmVsaWIvZW51bWVyYXRvci9nZW5lcmF0b3InXG4gIGF1dG9sb2FkIDpMYXp5LCAnY29yZWxpYi9lbnVtZXJhdG9yL2xhenknXG4gIGF1dG9sb2FkIDpZaWVsZGVyLCAnY29yZWxpYi9lbnVtZXJhdG9yL3lpZWxkZXInXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImZvciIsIm9iamVjdCIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsIkBjdXJzb3IiLCIwIiwiYmxvY2siLCJAb2JqZWN0IiwibmV3IiwiR2VuZXJhdG9yIiwidG9fcHJvYyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwicmVzcG9uZF90bz8iLCJJbnRlZ2VyIiwiZWFjaCIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsImNsYXNzIiwiX19zZW5kX18iLCJzaXplIiwiY2FsbCIsIndpdGhfaW5kZXgiLCJvZmZzZXQiLCJlbnVtX2ZvciIsImJsb2NrIGluIHdpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIHdpdGhfaW5kZXgiLCJPcGFsIiwiZGVzdHJ1Y3R1cmUiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9ja19naXZlbj8iLCJibG9jayBpbiBlYWNoX3dpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9pbmRleCIsInJld2luZCIsInBlZWtfdmFsdWVzIiwiQHZhbHVlcyIsIiRyZXRfb3JfMSIsIm1hcCIsImJsb2NrIGluIHBlZWtfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZWVrX3ZhbHVlcyIsImkiLCI+PSIsImxlbmd0aCIsIktlcm5lbCIsInJhaXNlIiwiU3RvcEl0ZXJhdGlvbiIsIltdIiwicGVlayIsInZhbHVlcyIsIjw9IiwiMSIsIm5leHRfdmFsdWVzIiwib3V0IiwibmV4dCIsImZlZWQiLCJhcmciLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwib3RoZXIiLCJFbnVtZXJhdG9yOjpDaGFpbiIsIkVudW1lcmF0b3IiLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIlJhbmdlIiwiLTIiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUNEO0lBRURHLE1BQUlMLElBQUpLLFVBQUFBLDJCQUFhQyxNQUFELEVBVGQsRUFTYyxFQVRkLEVBU0VEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BVEY7O01BU3VCLHVEQUFBLDZCQUFTO01BQU87O0FBRXZDQSxnQkFBa0JMLElBQUFPLFVBQUFBLENBQUFBLENBQVNGOztBQUUzQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBWEVBLENBQUFBLElBQUFBOztBQWNBRyxJQUFBQSwwQkFBQUEsc0JBdkJGLEVBdUJFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXZCRjtNQXVCaUI7TUFDWkE7TUFFREMsY0FBVUM7TUFDVixJQUFBLFFBQUdDLEtBQUgsQ0FBQTs7UUFDRUMsY0FBbUJDLE1BQVRDLGVBQVNELE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1GLEtBQURJLFNBQUFBLENBQUFBLENBQUxGO1FBQ25CRyxjQUFVO1FBQ1ZDLFlBQVU7UUFDVkMsWUFBV1Y7UUFFWCxJQUFHLENBQUEsUUFBQVUsU0FBQSxDQUFBLElBQUEsQ0FBQSxLQUFVQSxTQUFLQyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFmLENBQUEsQ0FBQSxDQUFIO1VBQ0VYLE9BQUFVLENBQUFBLFlBQVNWLFdBQWFVLFNBQU1WLEVBQUlZLGNBQVVaLFdBQTFDVTtRQURGO1VBakNOVixPQUFBO1FBaUNNO01BTkY7O1FBVUVJLGNBQVdKO1FBQ1hRLGNBQVdSO1FBQ1hT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RTtFQTFJRnZFLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFKQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE0MTY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDw8IHNlbGZcbiAgZGVmIHRvX3NcbiAgICAnbWFpbidcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUobW9kKVxuICAgIDo6T2JqZWN0LmluY2x1ZGUgbW9kXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZCgqYXJncylcbiAgICBgT3BhbC5PYmplY3QuJGF1dG9sb2FkLmFwcGx5KE9wYWwuT2JqZWN0LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBDb21waWxlciBvdmVycmlkZXMgdGhpcyBtZXRob2RcbiAgZGVmIHVzaW5nKG1vZClcbiAgICA6Oktlcm5lbC5yYWlzZSAnbWFpbi51c2luZyBpcyBwZXJtaXR0ZWQgb25seSBhdCB0b3BsZXZlbCdcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwidG9fcyIsImluY2x1ZGUiLCJtb2QiLCJPYmplY3QiLCJhdXRvbG9hZCIsInVzaW5nIiwiS2VybmVsIiwicmFpc2UiLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQTs7OztBQUNFQyxJQUFBQSxvQkFBQUEsWUFDRSxNQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFZQyxHQUFaRDtBQUFBQTtNQUNFQSxPQUFBRSxPQUFRRixTQUFBQSxDQUFTQyxHQUFURDtJQURWQSxDQUFBQSxHQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQVRGLEVBU0VBO0FBQUFBLE1BQUFBOzs7TUFURjtNQVNlO01BQ1hBLE9BQUNBLDhDQUFEQTtJQURGQSxDQUFBQSxJQUFBQTtJQUtBLE9BQUFDLHFCQUFBQSxpQkFBVUgsR0FBVkc7QUFBQUE7TUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0YsMENBQVBFO0lBRFZGLENBQUFBLEdBQUFBO0VBZEYsNEJBQVNHLElBQVQ7QUFBQVQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE0MTk4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG8sIGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwLCBwcm9wXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xuXG5jbGFzcyA6OlN0cmluZyA8IGBTdHJpbmdgXG4gIGluY2x1ZGUgOjpDb21wYXJhYmxlXG5cbiAgJXh7XG4gICAgT3BhbC5wcm9wKCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGlzX3N0cmluZycsIHRydWUpO1xuICB9XG5cbiAgZGVmIF9faWRfX1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KHdoYXQpXG4gICAgOjpPcGFsLmNvZXJjZV90bz8od2hhdCwgOjpTdHJpbmcsIDp0b19zdHIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBhcmdzWzBdIHx8IFwiXCI7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3NbYXJncy5sZW5ndGgtMV07XG4gICAgICBzdHIgPSAkY29lcmNlX3RvKHN0ciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuJCRpc19oYXNoKSB7XG4gICAgICAgIGlmIChvcHRzLiQkc21hcC5lbmNvZGluZykgc3RyID0gc3RyLiRmb3JjZV9lbmNvZGluZyhvcHRzLiQkc21hcC5lbmNvZGluZyk7XG4gICAgICB9XG4gICAgICBzdHIgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKHN0cik7XG4gICAgICBpZiAoIXN0ci4kaW5pdGlhbGl6ZS4kJHByaXN0aW5lKSAje2BzdHJgLmluaXRpYWxpemUoKmFyZ3MpfTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICAjIE91ciBpbml0aWFsaXplIG1ldGhvZCBkb2VzIG5vdGhpbmcsIHRoZSBzdHJpbmcgdmFsdWUgc2V0dXAgaXMgYmVpbmdcbiAgIyBkb25lIGJ5IFN0cmluZy5uZXcuIFRoZXJlZm9yZSBub3QgYWxsIGtpbmRzIG9mIHN1YmNsYXNzaW5nIHdpbGwgd29yay5cbiAgIyBBcyBhIHJ1bGUgb2YgdGh1bWIsIHdoZW4gc3ViY2xhc3NpbmcgU3RyaW5nLCBlaXRoZXIgbWFrZSBzdXJlIHRvIG92ZXJyaWRlXG4gICMgLm5ldyBvciBtYWtlIHN1cmUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gYSBjb25zdHJ1Y3RvciBpc1xuICAjIGEgc3RyaW5nIHdlIHdhbnQgb3VyIHN1YmNsYXNzLXN0cmluZyB0byBob2xkLlxuICBkZWYgaW5pdGlhbGl6ZShzdHIgPSB1bmRlZmluZWQsIGVuY29kaW5nOiBuaWwsIGNhcGFjaXR5OiBuaWwpXG4gIGVuZFxuXG4gIGRlZiAlKGRhdGEpXG4gICAgaWYgOjpBcnJheSA9PT0gZGF0YVxuICAgICAgZm9ybWF0KHNlbGYsICpkYXRhKVxuICAgIGVsc2VcbiAgICAgIGZvcm1hdChzZWxmLCBkYXRhKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihjb3VudClcbiAgICAleHtcbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcmd1bWVudCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIEFsbCBjcmVkaXQgZm9yIHRoZSBiaXQtdHdpZGRsaW5nIG1hZ2ljIGNvZGUgYmVsb3cgZ29lcyB0byBNb3ppbGxhXG4gICAgICAvLyBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiBvZiBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCgpIHBvc3RlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8oI3tvdGhlcn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgXG5cbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PSBcIlwiICYmIHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5TdHJpbmcpIHJldHVybiAje3NlbGZ9O1xuICAgICAgaWYgKHNlbGYgPT0gXCJcIiAmJiBvdGhlci4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7b3RoZXJ9O1xuICAgICAgdmFyIG91dCA9IHNlbGYgKyBvdGhlcjtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSBvdXQuZW5jb2RpbmcgJiYgb3RoZXIuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZykgcmV0dXJuIG91dDtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIiB8fCBvdGhlci5lbmNvZGluZy5uYW1lID09PSBcIlVURi04XCIpIHJldHVybiBvdXQ7XG4gICAgICByZXR1cm4gT3BhbC5lbmMob3V0LCBzZWxmLmVuY29kaW5nKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuICAgICAgb3RoZXIgPSBvdGhlci50b19zdHIudG9fc1xuXG4gICAgICBgc2VsZiA+IG90aGVyID8gMSA6IChzZWxmIDwgb3RoZXIgPyAtMSA6IDApYFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICB2YXIgY21wID0gI3tvdGhlciA8PT4gc2VsZn07XG5cbiAgICAgICAgaWYgKGNtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY21wID4gMCA/IC0xIDogKGNtcCA8IDAgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fc3RyJykpIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPX4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3R5cGUgbWlzbWF0Y2g6IFN0cmluZyBnaXZlbid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tvdGhlciA9fiBzZWxmfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHNpemUgPSBzZWxmLmxlbmd0aCwgZXhjbHVkZSwgcmFuZ2U7XG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JhbmdlKSB7XG4gICAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgICByYW5nZSAgID0gaW5kZXg7XG4gICAgICAgIGxlbmd0aCAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpbmRleCAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoaW5kZXgpID4gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUgfHwgcmFuZ2UuZW5kID09PSBuaWwpIHtcbiAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aCAtIGluZGV4O1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvcn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGluZGV4KSAhPT0gLTEgPyBpbmRleCA6IG5pbDtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19yZWdleHApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc2VsZi5tYXRjaChpbmRleCk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgJiYgLWxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFtsZW5ndGggKz0gbWF0Y2gubGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbbGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5zdWJzdHIoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiXG4gICAgYG5ldyBTdHJpbmcoI3tzZWxmfSlgLmZvcmNlX2VuY29kaW5nKCdiaW5hcnknKVxuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZVxuICAgIGBzZWxmLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2VsZi5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKWBcbiAgZW5kXG5cbiAgZGVmIGNhc2VjbXAob3RoZXIpXG4gICAgcmV0dXJuIG5pbCB1bmxlc3Mgb3RoZXIucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gcmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNob21wKHNlcGFyYXRvciA9ICQvKVxuICAgIHJldHVybiBzZWxmIGlmIGBzZXBhcmF0b3IgPT09IG5pbCB8fCBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIHNlcGFyYXRvciA9IDo6T3BhbC5jb2VyY2VfdG8hKHNlcGFyYXRvciwgOjpTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gXCJcXG5cIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoL1xccj9cXG4/JC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlcGFyYXRvciA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoLyhcXHI/XFxuKSskLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZi5sZW5ndGggPj0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGFpbCA9IHNlbGYuc3Vic3RyKHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCwgc2VwYXJhdG9yLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRhaWwgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hvcFxuICAgICV4e1xuICAgICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCByZXN1bHQ7XG5cbiAgICAgIGlmIChsZW5ndGggPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gXCJcXG5cIiAmJiBzZWxmLmNoYXJBdChsZW5ndGggLSAyKSA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNoclxuICAgIGBzZWxmLmNoYXJBdCgwKWBcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogbmlsKVxuICAgIHVubGVzcyBmcmVlemUubmlsPyB8fCBmcmVlemUgPT0gdHJ1ZSB8fCBmcmVlemUgPT0gZmFsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5leHBlY3RlZCB2YWx1ZSBmb3IgZnJlZXplOiAje2ZyZWV6ZS5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmLCBmcmVlemU6IGZyZWV6ZSlcblxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlXG4gICAgICBgaWYgKCFjb3B5LiQkZnJvemVuKSB7IGNvcHkuJCRmcm96ZW4gPSB0cnVlOyB9YFxuICAgIGVsc2lmIGZyZWV6ZS5uaWw/XG4gICAgICBgaWYgKHNlbGYuJCRmcm96ZW4pIHsgY29weS4kJGZyb3plbiA9IHRydWU7IH1gXG4gICAgZW5kXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnQXJndW1lbnRFcnJvcjogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSspJ31cbiAgICAgIH1cbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcbiAgICAgIGlmIChjaGFyX2NsYXNzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoIC0gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpLmxlbmd0aDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9wcmVmaXgocHJlZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFwcmVmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXgsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfc3VmZml4KHN1ZmZpeClcbiAgICAleHtcbiAgICAgIGlmICghc3VmZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpID09PSBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRvd25jYXNlXG4gICAgYHNlbGYudG9Mb3dlckNhc2UoKWBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgY2hvbXA6IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2xpbmUsIHNlcGFyYXRvciwgY2hvbXA6IGNob21wIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gbmlsKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmKTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgc2VwYXJhdG9yID0gJGNvZXJjZV90byhzZXBhcmF0b3IsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZCwgdmFsdWU7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvciAoYSA9IHNlbGYuc3BsaXQoLygoPzpcXHI/XFxuKXsyfSkoPzooPzpcXHI/XFxuKSopLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoYVtpXSB8fCBhW2kgKyAxXSkge1xuICAgICAgICAgICAgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChjaG9tcCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChcIlxcblwiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXR0ZWRbaV07XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIHZhbHVlICs9IHNlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvbXApIHtcbiAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChzZXBhcmF0b3IpfTtcbiAgICAgICAgfVxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVuZF93aXRoPygqc3VmZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3VmZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBnc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpnc3ViLCBwYXR0ZXJufTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLCBtYXRjaF9kYXRhID0gbmlsLCBpbmRleCA9IDAsIG1hdGNoLCBfcmVwbGFjZW1lbnQ7XG5cbiAgICAgIGlmIChwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IGJsb2NrKG1hdGNoWzBdKTtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDsgLy8gc2F2ZSBhbmQgcmVzdG9yZSBsYXN0SW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFyZXBsYWNlbWVudC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQgKyAoc2VsZlttYXRjaC5pbmRleF0gfHwgXCJcIikpO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihvdGhlcikgIT09IC0xO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KHNlYXJjaCwgb2Zmc2V0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHJlZ2V4O1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgcmVnZXggPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVnZXhgLCBgbWF0Y2hgKX1cbiAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDAgJiYgb2Zmc2V0ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cbiAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHUwMDdGLVxcdTAwOUZcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICAgIG1ldGEgPSB7XG4gICAgICAgICAgICAnXFx1MDAwNyc6ICdcXFxcYScsXG4gICAgICAgICAgICAnXFx1MDAxYic6ICdcXFxcZScsXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1xcdic6ICdcXFxcdicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVzY2FwZWQgPSBzZWxmLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoY2hyKSB7XG4gICAgICAgICAgICBpZiAobWV0YVtjaHJdKSByZXR1cm4gbWV0YVtjaHJdO1xuICAgICAgICAgICAgY2hyID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hyIDw9IDB4ZmYgJiYgKHNlbGYuZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpIHx8IHNlbGYuaW50ZXJuYWxfZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjaHIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiAnXCInICsgZXNjYXBlZC5yZXBsYWNlKC9cXCNbXFwkXFxAXFx7XS9nLCAnXFxcXCQmJykgKyAnXCInO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyblxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIGxpbmVzKHNlcGFyYXRvciA9ICQvLCBjaG9tcDogZmFsc2UsICZibG9jaylcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgY2hvbXA6IGNob21wLCAmYmxvY2spXG4gICAgYmxvY2sgPyBzZWxmIDogZS50b19hXG4gIGVuZFxuXG4gIGRlZiBsanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ICA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgIHdpZHRoIC09IHNlbGYubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHdpZHRoKSB7XG4gICAgICAgIHJlc3VsdCArPSBwYWRzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmICsgcmVzdWx0LnNsaWNlKDAsIHdpZHRoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9eW1xcdTAwMDBcXHNdKi8sICcnKWBcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX29ubHk/XG4gICAgIyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyBtdXN0IHJldHVybiBmYWxzZVxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmVuY29kaW5nLmFzY2lpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2gocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICAgIHBhdHRlcm4gPSA6OlJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgOjpSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXG4gICAgZW5kXG5cbiAgICBwYXR0ZXJuLm1hdGNoKHNlbGYsIHBvcywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZClcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IDo6UmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyA6OlJlZ2V4cCA9PT0gcGF0dGVyblxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2g/KHNlbGYsIHBvcylcbiAgZW5kXG5cbiAgZGVmIG5leHRcbiAgICAleHtcbiAgICAgIHZhciBpID0gc2VsZi5sZW5ndGg7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9jdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLFxuICAgICAgICAgIHJhZGl4ID0gODtcblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC9pLCBmdW5jdGlvbiAob3JpZ2luYWwsIGhlYWQsIGZsYWcsIHRhaWwpIHtcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBpZiAodGFpbC5jaGFyQXQoMSkgPT09ICd4JyAmJiBmbGFnID09PSAnMHgnKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9yZFxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvZGVQb2ludEF0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY29kZVBvaW50QXQoMCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG07XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IHNlcC5leGVjKHNlbGYpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgc2VwYCwgYG1gfTtcbiAgICAgICAgICBzZXAgPSBtWzBdO1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYuaW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLCAnJywgJyddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJylgXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwgfHwgX20uaW5kZXggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7OjpNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmxhc3RJbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGkgPT09IC0xID8gbmlsIDogaTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGNoYXJzICAgICA9IE1hdGguZmxvb3Iod2lkdGggLSBzZWxmLmxlbmd0aCksXG4gICAgICAgICAgcGF0dGVybnMgID0gTWF0aC5mbG9vcihjaGFycyAvIHBhZHN0ci5sZW5ndGgpLFxuICAgICAgICAgIHJlc3VsdCAgICA9IEFycmF5KHBhdHRlcm5zICsgMSkuam9pbihwYWRzdHIpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IGNoYXJzIC0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHJlc3VsdCArIHBhZHN0ci5zbGljZSgwLCByZW1haW5pbmcpICsgc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBycGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZXApO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJycsICcnLCBzZWxmXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc2NhbihwYXR0ZXJuLCBub19tYXRjaGRhdGE6IGZhbHNlLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgbWF0Y2hfZGF0YSA9IG5pbCxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZikpICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2hfZGF0YSA9ICN7OjpNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYCwgbm9fbWF0Y2hkYXRhOiBub19tYXRjaGRhdGF9O1xuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gcmVzdWx0LnB1c2gobWF0Y2hbMF0pIDogcmVzdWx0LnB1c2goI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IE9wYWwueWllbGQxKGJsb2NrLCBtYXRjaFswXSkgOiBPcGFsLnlpZWxkMShibG9jaywgI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5vX21hdGNoZGF0YSkgI3skfiA9IGBtYXRjaF9kYXRhYH07XG5cbiAgICAgIHJldHVybiAoYmxvY2sgIT09IG5pbCA/IHNlbGYgOiByZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBXZSByZWRlZmluZSB0aGlzIG1ldGhvZCBvbiBTdHJpbmcsIGFzIGtlcm5lbC5yYiBpcyBpbiBzdHJpY3QgbW9kZVxuICAjIHNvIHRoYXQgdGhpbmdzIGxpa2UgQm9vbGVhbiBkb24ndCBnZXQgYm94ZWQuIEZvciBTdHJpbmcgdGhvdWdoIC1cbiAgIyB3ZSBlaXRoZXIgbmVlZCB0byBib3ggaXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgb24gaXQsIG9yIHJ1biBpdCBpblxuICAjIG5vbi1zdHJpY3QgbW9kZS4gVGhpcyBpcyBhIG1lc3MgYW5kIHdlIG5lZWQgdG8gY29tZSBiYWNrIHRvIGl0XG4gICMgYXQgYSBsYXRlciB0aW1lLlxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkIHx8IHBhdHRlcm4gPT09IG5pbCkge1xuICAgICAgICBwYXR0ZXJuID0gI3skOyB8fCAnICd9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBpLCBpaTtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcgJykge1xuICAgICAgICAgIHBhdHRlcm4gPSAvXFxzKy9nbTtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzdHJpbmcuc3BsaXQocGF0dGVybik7XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxICYmIHJlc3VsdFswXSA9PT0gc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0WzBdXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChpID0gcmVzdWx0LmluZGV4T2YodW5kZWZpbmVkKSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICByZXN1bHQubGVuZ3RoIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcblxuICAgICAgaWYgKGxpbWl0IDwgMCkge1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnICYmIHBhdHRlcm4uc291cmNlLmluZGV4T2YoJyg/PScpID09PSAtMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gbWF0Y2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKGxpbWl0IC0gMSkuam9pbignJykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCBzdHJpbmcuc2xpY2UoaW5kZXgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3F1ZWV6ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKC8oLilcXDErL2csICckMScpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgY2hhcl9jbGFzcyArICcpXFxcXDErJywgJ2cnKSwgJyQxJyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVmaXhlc1tpXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHZhciByZWdleHAgPSBwcmVmaXhlc1tpXTtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhzZWxmKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGByZWdleHBgLCBgbWF0Y2hgKX07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICAgIGlmIChzZWxmLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15bXFxzXFx1MDAwMF0qfFtcXHNcXHUwMDAwXSokL2csICcnKWBcbiAgZW5kXG5cbiAgZGVmIHN1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgcmVzdWx0ID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfVxuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgxIGZvciAyKSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgYmxvY2sobWF0Y2hbMF0pICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VtKG4gPSAxNilcbiAgICAleHtcbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgJiAoTWF0aC5wb3coMiwgbikgLSAxKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzd2FwY2FzZVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYucmVwbGFjZSgvKFthLXpdKyl8KFtBLVpdKykvZywgZnVuY3Rpb24oJDAsJDEsJDIpIHtcbiAgICAgICAgcmV0dXJuICQxID8gJDAudG9VcHBlckNhc2UoKSA6ICQwLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQoc2VsZi5yZXBsYWNlKC9fL2csICcnKSk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpIHx8IHJlc3VsdCA9PSBJbmZpbml0eSB8fCByZXN1bHQgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faShiYXNlID0gMTApXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICByYWRpeCA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChyYWRpeCA9PT0gMSB8fCByYWRpeCA8IDAgfHwgcmFkaXggPiAzNikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YHJhZGl4YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC8sIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcgJiYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDIpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSA4KSB7XG4gICAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxMCkge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSB7XG4gICAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBtZXRob2RfbmFtZSA9IGBzZWxmLnZhbHVlT2YoKWBcblxuICAgIHByb2MgPSA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2WyckJyArICN7bWV0aG9kX25hbWV9XTtcblxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICAgICAgYXJnc1swXSA9ICN7bWV0aG9kX25hbWV9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5jYWxsKHJlY3YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBgcHJvYy4kJHNvdXJjZV9sb2NhdGlvbiA9IG5pbGBcblxuICAgIHByb2NcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgdHIoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDAgfHwgZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X3RvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGFzdF90byA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X3RvLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiA9PSBudWxsID8gZ2xvYmFsX3N1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgIT0gbnVsbCA/IHN1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld19zdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJfcyhmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgIHRvID0gJGNvZXJjZV90byh0bywgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvX2NoYXJzID0gdG9fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICAgICAgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aF9kaWZmID0gZnJvbV9sZW5ndGggLSB0b19sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGhfZGlmZiA+IDApIHtcbiAgICAgICAgICB2YXIgcGFkX2NoYXIgPSAodG9fbGVuZ3RoID4gMCA/IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdIDogJycpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGhfZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICB0b19jaGFycy5wdXNoKHBhZF9jaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0b19jaGFyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgdmFyIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGxcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdXG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgaWYgKHN1YiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9zdWJzdGl0dXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbmV3X3N0ciArPSBnbG9iYWxfc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XG4gICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoc3ViICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCB8fCBsYXN0X3N1YnN0aXR1dGUgIT09IHN1Yikge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IHN1YjtcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gc3ViO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XG4gICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld19zdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYudG9VcHBlckNhc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgZXhjbCA9IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp1cHRvLCBzdG9wLCBleGNsIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIHZhciBhLCBiLCBzID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICBzdG9wID0gJGNvZXJjZV90byhzdG9wLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgc3RvcC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICBhID0gcy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBiID0gc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHMsIDEwKS50b1N0cmluZygpID09PSBzICYmIHBhcnNlSW50KHN0b3AsIDEwKS50b1N0cmluZygpID09PSBzdG9wKSB7XG5cbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHN0b3AsIDEwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soYS50b1N0cmluZygpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCA8PSBzdG9wLmxlbmd0aCAmJiBzIDw9IHN0b3ApIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBzID09PSBzdG9wKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhzKTtcblxuICAgICAgICAgIHMgPSAje2BzYC5zdWNjfTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cykge1xuICAgICAgZnVuY3Rpb24gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJfY2hhcixcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoLFxuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20sXG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byxcbiAgICAgICAgICAgIGNoYXJfY29kZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY3Vycl9jaGFyID0gc2V0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY3Vycl9jaGFyID09PSAnLScgJiYgaSA+IDAgJiYgaSA8IChsZW4gLSAxKSAmJiAhc2tpcF9uZXh0X2Rhc2gpIHtcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tID0gc2V0LmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8gPSBzZXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhcl9jb2RlX2Zyb20gPiBjaGFyX2NvZGVfdXB0bykge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BjaGFyX2NvZGVfZnJvbWB9LSN7YGNoYXJfY29kZV91cHRvYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY2hhcl9jb2RlID0gY2hhcl9jb2RlX2Zyb20gKyAxOyBjaGFyX2NvZGUgPCBjaGFyX2NvZGVfdXB0byArIDE7IGNoYXJfY29kZSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gKGN1cnJfY2hhciA9PT0gJ1xcXFwnKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyX2NoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gICAgICAgIGlmIChzZXRBLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldEEubGVuZ3RoLFxuICAgICAgICAgICAgY2hyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBzZXRBLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoc2V0Qi5pbmRleE9mKGNocikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgbGVuLCBzZXQsIG5lZywgY2hyLCB0bXAsXG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9ICcnLFxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIG5lZyA9IChzZXQuY2hhckF0KDApID09PSAnXicgJiYgc2V0Lmxlbmd0aCA+IDEpO1xuICAgICAgICBzZXQgPSBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KG5lZyA/IHNldC5zbGljZSgxKSA6IHNldCk7XG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKG5lZ19pbnRlcnNlY3Rpb24sIHNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihwb3NfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgJiYgbmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRtcCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gcG9zX2ludGVyc2VjdGlvbi5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24uaW5kZXhPZihjaHIpID09PSAtMSkge1xuICAgICAgICAgICAgdG1wICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IHRtcDtcbiAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnWycgKyAjezo6UmVnZXhwLmVzY2FwZShgcG9zX2ludGVyc2VjdGlvbmApfSArICddJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1teJyArICN7OjpSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIkludmFsaWQgbm9ybWFsaXphdGlvbiBmb3JtICN7Zm9ybX1cIiB1bmxlc3MgJWlbbmZjIG5mZCBuZmtjIG5ma2RdLmluY2x1ZGU/KGZvcm0pXG4gICAgYHNlbGYubm9ybWFsaXplKCN7Zm9ybS51cGNhc2V9KWBcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplZD8oZm9ybSA9IDpuZmMpXG4gICAgdW5pY29kZV9ub3JtYWxpemUoZm9ybSkgPT0gc2VsZlxuICBlbmRcblxuICBkZWYgdW5wYWNrKGZvcm1hdClcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL3N0cmluZy91bnBhY2snLlwiXG4gIGVuZFxuXG4gIGRlZiB1bnBhY2sxKGZvcm1hdClcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrMSwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7IHJldHVybiBzZWxmOyB9XG4gICAgICAkcHJvcChzZWxmLCBcIiQkZnJvemVuXCIsIHRydWUpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgLUBcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRmcm96ZW4pIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnICYmIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnKSByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHNlbGYuJGR1cCgpLiRmcmVlemUoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJyB8fCBzZWxmLiQkZnJvemVuID09PSB0cnVlYFxuICBlbmRcblxuICBhbGlhcyArQCBkdXBcbiAgYWxpYXMgPT09ID09XG4gIGFsaWFzIGJ5dGVzbGljZSBbXVxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGVxdWFsPyA9PT1cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuICBhbGlhcyBzbGljZSBbXVxuICBhbGlhcyBzdWNjIG5leHRcbiAgYWxpYXMgdG9fc3RyIHRvX3NcbiAgYWxpYXMgdG9fc3ltIGludGVyblxuXG4gIDo6T3BhbC5wcmlzdGluZSBzZWxmLCA6aW5pdGlhbGl6ZVxuZW5kXG5cblN5bWJvbCA9IFN0cmluZ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpTdHJpbmc+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJfX2lkX18iLCJ0cnlfY29udmVydCIsIndoYXQiLCJPcGFsIiwiY29lcmNlX3RvPyIsIlN0cmluZyIsIm5ldyIsImluaXRpYWxpemUiLCJhcmdzIiwiJSIsImRhdGEiLCJBcnJheSIsImZvcm1hdCIsIioiLCJjb3VudCIsIkludGVnZXIiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJSYW5nZUVycm9yIiwiKyIsIm90aGVyIiwiPD0+IiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19zIiwiPT0iLCI9fiIsIlR5cGVFcnJvciIsIltdIiwiaW5kZXgiLCJsZW5ndGgiLCIkfiIsIk1hdGNoRGF0YSIsImIiLCJmb3JjZV9lbmNvZGluZyIsImNhcGl0YWxpemUiLCJjYXNlY21wIiwiY2FzZWNtcD8iLCJjZW50ZXIiLCJ3aWR0aCIsInBhZHN0ciIsImVtcHR5PyIsImxqdXN0IiwiLyIsIjIiLCJjZWlsIiwicmp1c3QiLCJmbG9vciIsImNob21wIiwic2VwYXJhdG9yIiwiJC8iLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiJGt3YXJncyIsImZyZWV6ZSIsIm5pbD8iLCJjbGFzcyIsImNvcHkiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiaW5pdGlhbGl6ZV9jbG9uZSIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZGVsZXRlIiwiZGVsZXRlX3ByZWZpeCIsInByZWZpeCIsImRlbGV0ZV9zdWZmaXgiLCJzdWZmaXgiLCJkb3duY2FzZSIsImVhY2hfbGluZSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiZW5kX3dpdGg/IiwiZ3N1YiIsInBhdHRlcm4iLCJyZXBsYWNlbWVudCIsImhhc2giLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsInNlYXJjaCIsIm9mZnNldCIsImluc3BlY3QiLCJpbnRlcm4iLCJsaW5lcyIsImUiLCJibG9jayIsInRvX3Byb2MiLCJ0b19hIiwibHN0cmlwIiwiYXNjaWlfb25seT8iLCJtYXRjaCIsInBvcyIsIlJlZ2V4cCIsIm1hdGNoPyIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJzZXAiLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJub19tYXRjaGRhdGEiLCJjYXB0dXJlcyIsInNpbmdsZXRvbl9jbGFzcyIsInNwbGl0IiwibGltaXQiLCIkcmV0X29yXzEiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwibiIsInN3YXBjYXNlIiwidG9fZiIsImJhc2UiLCIxMCIsIm1ldGhvZF9uYW1lIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ0ciIsImZyb20iLCJ0byIsInRyX3MiLCJ1cGNhc2UiLCJ1cHRvIiwic3RvcCIsImV4Y2wiLCJzdWNjIiwiZXNjYXBlIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiX2xvYWQiLCJ1bmljb2RlX25vcm1hbGl6ZSIsImZvcm0iLCJ1bmljb2RlX25vcm1hbGl6ZWQ/IiwidW5wYWNrIiwidW5wYWNrMSIsIi1AIiwiZnJvemVuPyIsInByaXN0aW5lIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFB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QUNFQSxPQUFDQSxrREFBREE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLElBQU4sRUFBUyxLQUFUO0lBQ0EsYUFBTSxLQUFOLEVBQVUsSUFBVjtJQUNBLGFBQU0sV0FBTixFQUFnQixJQUFoQjtJQUNBLGFBQU0sTUFBTixFQUFXLElBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxLQUFiO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0lBQ0EsYUFBTSxPQUFOLEVBQVksSUFBWjtJQUNBLGFBQU0sTUFBTixFQUFXLE1BQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0lBQ0EsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUVBdEosT0FBQU0sS0FBTWlKLFVBQUFBLENBQVV6SixJQUFoQixFQUFzQixZQUFoQnlKO0VBeDFEUnZKLEdBQU0sSUFBTkEsRUFBa0JILE1BQWxCRztFQTIxREFILE9BQUEsa0NBQVNXLFlBQVQ7QUFoMkRBWDsifX0seyJvZmZzZXQiOnsibGluZSI6MTYzNDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jhc2ljX29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHVzZV9zdHJpY3Q6IHRydWVcblxuY2xhc3MgOjpCYXNpY09iamVjdFxuICBkZWYgaW5pdGlhbGl6ZSgqKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuXG4gIGRlZiBfX2lkX19cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgICAgfVxuICAgICAgT3BhbC5wcm9wKHNlbGYsICckJGlkJywgT3BhbC51aWQoKSk7XG4gICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9fc2VuZF9fKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3ltYm9sLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpbnNwZWN0fSBpcyBub3QgYSBzeW1ib2wgbm9yIGEgc3RyaW5nXCJ9XG4gICAgICB9XG5cbiAgICAgIHZhciBmdW5jID0gc2VsZlsnJCcgKyBzeW1ib2xdO1xuXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGZ1bmMuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kbWV0aG9kX21pc3NpbmcuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRtZXRob2RfbWlzc2luZy5hcHBseShzZWxmLCBbc3ltYm9sXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICFcbiAgICBmYWxzZVxuICBlbmRcbiAgOjpPcGFsLnByaXN0aW5lIDohXG5cbiAgZGVmICE9KG90aGVyKVxuICAgICEoc2VsZiA9PSBvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJyB1bmxlc3MgKDEuLjMpLmNvdmVyPyBhcmdzLnNpemVcblxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcbiAgICAgIGRlZmF1bHRfZXZhbF9vcHRpb25zID0geyBmaWxlOiAoZmlsZSB8fCAnKGV2YWwpJyksIGV2YWw6IHRydWUgfVxuICAgICAgY29tcGlsaW5nX29wdGlvbnMgPSBfX09QQUxfQ09NUElMRVJfQ09ORklHX18ubWVyZ2UoZGVmYXVsdF9ldmFsX29wdGlvbnMpXG4gICAgICBjb21waWxlZCA9IDo6T3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyBkb1xuICAgICAgICAleHtuZXcgRnVuY3Rpb24oXCJPcGFsLHNlbGZcIiwgXCJyZXR1cm4gXCIgKyBjb21waWxlZCkoT3BhbCwgc2VsZil9XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/ICYmIGFyZ3MubGVuZ3RoID49IDEgJiYgYXJncy5maXJzdFswXSA9PSAnQCdcbiAgICAgICMgZ2V0IGluc3RhbmNlIHZhcmlhYmxlXG4gICAgICByZXR1cm4gaW5zdGFuY2VfdmFyaWFibGVfZ2V0KGFyZ3MuZmlyc3QpXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAvLyBOZWVkIHRvIHBhc3MgJCRldmFsIHNvIHRoYXQgbWV0aG9kIGRlZmluaXRpb25zIGtub3cgaWYgdGhpcyBpc1xuICAgICAgLy8gYmVpbmcgZG9uZSBvbiBhIGNsYXNzL21vZHVsZS4gQ2Fubm90IGJlIGNvbXBpbGVyIGRyaXZlbiBzaW5jZVxuICAgICAgLy8gc2VuZCg6aW5zdGFuY2VfZXZhbCkgbmVlZHMgdG8gd29yay5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc2VsZi4kJGV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9leGVjKCphcmdzLCAmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgaW5zcGVjdF9yZXN1bHQgPSA6Ok9wYWwuaW5zcGVjdChzZWxmKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXG4gICAgICBcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdF9yZXN1bHR9XCIsIHN5bWJvbCwgYXJnc1xuICAgICksIG5pbCwgOjpLZXJuZWwuY2FsbGVyKDEpXG4gIGVuZFxuXG4gIDo6T3BhbC5wcmlzdGluZShzZWxmLCA6bWV0aG9kX21pc3NpbmcpXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJhc2ljT2JqZWN0PiIsImluaXRpYWxpemUiLCI9PSIsIm90aGVyIiwiZXFsPyIsInNlbGYiLCJfX2lkX18iLCJfX3NlbmRfXyIsInN5bWJvbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiaW5zcGVjdCIsIiEiLCJPcGFsIiwicHJpc3RpbmUiLCIhPSIsImluc3RhbmNlX2V2YWwiLCJibG9jayIsIm5pbD8iLCIxIiwiMyIsImNvdmVyPyIsImFyZ3MiLCJzaXplIiwiS2VybmVsIiwiQXJndW1lbnRFcnJvciIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCIkcmV0X29yXzEiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImJsb2NrIGluIGluc3RhbmNlX2V2YWwiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3RhbmNlX2V2YWwiLCI+PSIsImxlbmd0aCIsImZpcnN0IiwiW10iLCIwIiwiaW5zdGFuY2VfdmFyaWFibGVfZ2V0IiwiYW55PyIsImluc3RhbmNlX2V4ZWMiLCJzaW5nbGV0b25fbWV0aG9kX2FkZGVkIiwic2luZ2xldG9uX21ldGhvZF9yZW1vdmVkIiwic2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQiLCJtZXRob2RfbWlzc2luZyIsImluc3BlY3RfcmVzdWx0IiwiTm9NZXRob2RFcnJvciIsIm5ldyIsImNhbGxlciIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtZXRob2RfbmFtZSIsImluY2x1ZGVfYWxsIl0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7Ozs7O0FBQ0VDLElBQUFBLDBCQUFBQSxzQkFIRixFQUdFQTtBQUFBQSxNQUFBQTs7O01BSEY7TUFHaUI7TUFIakJBLE9BQUE7SUFHRUEsQ0FBQUEsSUFBQUE7O0FBR0FDLElBQUFBLGtCQUFBQSwrQkFBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGNBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsaUNBQVNELEtBQVRDO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQyxJQUFLSCxPQUFBQSxDQUFHQyxLQUFIRDtJQURQRSxDQUFBQSxHQUFBQTtJQUlBLGFBQU0sUUFBTixFQUFhLElBQWI7O0FBRUFFLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVBFQSxDQUFBQSxHQUFBQTs7QUFVQUMsSUFBQUEsd0JBQUFBLG9CQUFhQyxNQUFELEVBMUJkLEVBMEJFRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQTFCRjtNQTBCdUI7O0FBRXZCQTtBQUNBQSxRQUFVRixJQUFBSSxPQUFBQSxDQUFNQyxnQkFBTixFQUFtQixFQUFBLEdBQUEsQ0FBR0wsSUFBQU0sU0FBQUEsQ0FBQUEsQ0FBSCxDQUFBLEdBQVdKLCtCQUE5QkU7QUFD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QUFBQTtFQXJKRnZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2NTYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvciwgY29lcmNlX3RvXG5cbm1vZHVsZSA6Ok9wYWxcbiAgZGVmIHNlbGYuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylcbiAgICBgT3BhbC5icmlkZ2UoY29uc3RydWN0b3IsIGtsYXNzKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvIShvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgY29lcmNlZCA9IGAkY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKWBcblxuICAgIHVubGVzcyB0eXBlID09PSBjb2VyY2VkXG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpYFxuICAgIGVuZFxuXG4gICAgY29lcmNlZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8/KG9iamVjdCwgdHlwZSwgbWV0aG9kLCAqYXJncylcbiAgICByZXR1cm4gdW5sZXNzIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcblxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICByZXR1cm4gaWYgY29lcmNlZC5uaWw/XG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIG9iamVjdCBpZiB0eXBlID09PSBvYmplY3RcblxuICAgIGlmIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcbiAgICAgIG9iamVjdC5fX3NlbmRfXyBtZXRob2RcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29tcGFyZShhLCBiKVxuICAgIGNvbXBhcmUgPSBhIDw9PiBiXG5cbiAgICBpZiBgY29tcGFyZSA9PT0gbmlsYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3thLmNsYXNzfSB3aXRoICN7Yi5jbGFzc30gZmFpbGVkXCJcbiAgICBlbmRcblxuICAgIGNvbXBhcmVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJncy4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NfYXJ5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmVzcG9uZF90bz8ob2JqLCBtZXRob2QsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmoucmVzcG9uZF90bz8obWV0aG9kLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG5cbiAgICB1bmxlc3MgYC9eQFthLXpBLVpfXVthLXpBLVowLTlfXSo/JC8udGVzdChuYW1lKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIicje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgaWYgYG5hbWUubGVuZ3RoIDwgMyB8fCBuYW1lLnNsaWNlKDAsMikgIT09ICdAQCdgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJgI3tuYW1lfScgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0X25hbWU/KGNvbnN0X25hbWUpXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIGNvbnN0X25hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICN7Y29uc3RfbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7Y29uc3RfbmFtZX1bMF0gPT09ICN7Y29uc3RfbmFtZX1bMF0udG9VcHBlckNhc2UoKVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gOjpPcGFsLmNvZXJjZV90byEoY29uc3RfbmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpIGlmIGRlZmluZWQ/IDo6U3RyaW5nXG5cbiAgICAleHtcbiAgICAgIGlmICghY29uc3RfbmFtZSB8fCBjb25zdF9uYW1lWzBdICE9IGNvbnN0X25hbWVbMF0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAje3JhaXNlIDo6TmFtZUVycm9yLCBcIndyb25nIGNvbnN0YW50IG5hbWUgI3tjb25zdF9uYW1lfVwifVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0X25hbWVcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICAjIE1hcmsgc29tZSBtZXRob2RzIGFzIHByaXN0aW5lIGluIG9yZGVyIHRvIGFwcGx5IG9wdGltaXphdGlvbnMgd2hlbiB0aGV5XG4gICMgYXJlIHN0aWxsIGluIHRoZWlyIG9yaWdpbmFsIGZvcm0uIFRoaXMgY291bGQgcHJvYmFibHkgYmUgbW92ZWQgdG9cbiAgIyB0aGUgYE9wYWwuZGVmKClgIEpTIEFQSSwgYnV0IGZvciBub3cgaXQgd2lsbCBzdGF5IG1hbnVhbC5cbiAgI1xuICAjIEBleGFtcGxlXG4gICNcbiAgIyAgIE9wYWwucHJpc3RpbmUgQXJyYXksIDphbGxvY2F0ZSwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcbiAgI1xuICAjICAgY2xhc3MgQXJyYXlcbiAgIyAgICAgZGVmIGR1cFxuICAjICAgICAgICV4e1xuICAjICAgICAgICAgaWYgKFxuICAjICAgICAgICAgICBzZWxmLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICMgICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZVxuICAjICAgICAgICAgKSByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgIyAgICAgICB9XG4gICNcbiAgIyAgICAgICBzdXBlclxuICAjICAgICBlbmRcbiAgIyAgIGVuZFxuICAjXG4gICMgQHBhcmFtIG93bmVyX2NsYXNzIFtDbGFzc10gdGhlIGNsYXNzIG93bmluZyB0aGUgbWV0aG9kc1xuICAjIEBwYXJhbSBtZXRob2RfbmFtZXMgW0FycmF5PFN5bWJvbD5dIHRoZSBsaXN0IG9mIG1ldGhvZHMgbmFtZXMgdG8gbWFya1xuICAjIEByZXR1cm4gW25pbF1cbiAgZGVmIHNlbGYucHJpc3RpbmUob3duZXJfY2xhc3MsICptZXRob2RfbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aG9kX25hbWUsIG1ldGhvZDtcbiAgICAgIGZvciAodmFyIGkgPSBtZXRob2RfbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWV0aG9kX25hbWUgPSBtZXRob2RfbmFtZXNbaV07XG4gICAgICAgIG1ldGhvZCA9IG93bmVyX2NsYXNzLiQkcHJvdG90eXBlWyckJyttZXRob2RfbmFtZV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCAmJiAhbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIG1ldGhvZC4kJHByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXG5cbiAgIyBQZXJmb3JtcyBhIHNhZmUgY2FsbCB0byBpbnNwZWN0IGZvciBhbnkgdmFsdWUsIHdoZXRoZXJcbiAgIyBuYXRpdmUgb3IgT3BhbC13cmFwcGVkLlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtPYmplY3RdXG4gICMgQHJldHVybiBbU3RyaW5nXVxuICBkZWYgc2VsZi5pbnNwZWN0KHZhbHVlID0gdW5kZWZpbmVkKVxuICAgIGB2YXIgcHVzaGVkID0gZmFsc2VgXG4gICAgYmVnaW5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBKUyBudWxsIHZhbHVlXG4gICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gSlMgdW5kZWZpbmVkIHZhbHVlXG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS4kJGNsYXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIEpTIG9iamVjdCAvIG90aGVyIHZhbHVlIHRoYXQgaXMgbm90IGJyaWRnZWRcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLiRpbnNwZWN0ICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlLiRpbnNwZWN0LiQkc3R1Yikge1xuICAgICAgICAgIC8vIEJhc2ljT2JqZWN0IGFuZCBmcmllbmRzXG4gICAgICAgICAgcmV0dXJuICN7XCIjPCN7YHZhbHVlLiQkY2xhc3NgfToweCN7dmFsdWUuX19pZF9fLnRvX3MoMTYpfT5cIn1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnNwZWN0X3N0YWNrLmluZGV4T2YoI3t2YWx1ZS5fX2lkX199KSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBpbnNwZWN0IHJlY3Vyc2luZyBpbnNpZGUgaW5zcGVjdCB0byBmaW5kIG91dCBhYm91dCB0aGVcbiAgICAgICAgICAvLyBzYW1lIG9iamVjdFxuICAgICAgICAgIHJldHVybiAje1wiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJ9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gYW55dGhpbmcgc3VwcG9ydGluZyBPcGFsXG4gICAgICAgICAgaW5zcGVjdF9zdGFjay5wdXNoKCN7dmFsdWUuX19pZF9ffSk7XG4gICAgICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuJGluc3BlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmlsXG4gICAgcmVzY3VlIDo6RXhjZXB0aW9uID0+IGUgIyBydWJvY29wOmRpc2FibGUgTGludC9SZXNjdWVFeGNlcHRpb25cbiAgICAgIFwiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJcbiAgICBlbnN1cmVcbiAgICAgIGBpZiAocHVzaGVkKSBpbnNwZWN0X3N0YWNrLnBvcCgpYFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+IiwiYnJpZGdlIiwic2VsZiIsImNvbnN0cnVjdG9yIiwia2xhc3MiLCJjb2VyY2VfdG8hIiwib2JqZWN0IiwidHlwZSIsIm1ldGhvZCIsImNvZXJjZWQiLCJLZXJuZWwiLCJyYWlzZSIsImNvZXJjZV90bz8iLCJyZXNwb25kX3RvPyIsIm5pbD8iLCJ0cnlfY29udmVydCIsIl9fc2VuZF9fIiwiY29tcGFyZSIsImEiLCJiIiwiPD0+IiwiQXJndW1lbnRFcnJvciIsImNsYXNzIiwiZGVzdHJ1Y3R1cmUiLCJhcmdzIiwib2JqIiwiaW5jbHVkZV9hbGwiLCJpbnN0YW5jZV92YXJpYWJsZV9uYW1lISIsIm5hbWUiLCJPcGFsIiwiU3RyaW5nIiwiTmFtZUVycm9yIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lPyIsImNvbnN0X25hbWUiLCJjb25zdF9uYW1lISIsInByaXN0aW5lIiwib3duZXJfY2xhc3MiLCJpbnNwZWN0IiwidmFsdWUiLCJfX2lkX18iLCJ0b19zIiwiMTYiLCJFeGNlcHRpb24iLCJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7Ozs7SUFDRUMsTUFBSUMsSUFBSkQsYUFBQUEsa0JBQWdCRSxXQUFELEVBQWNDLEtBQTdCSDtBQUFBQTtNQUNFQSxPQUFDQSwrQkFBREE7SUFERkEsQ0FBQUEs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aW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2lvLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6SU9cbiAgc2VsZjo6U0VFS19TRVQgPSAwXG4gIHNlbGY6OlNFRUtfQ1VSID0gMVxuICBzZWxmOjpTRUVLX0VORCA9IDJcbiAgc2VsZjo6U0VFS19EQVRBID0gM1xuICBzZWxmOjpTRUVLX0hPTEUgPSA0XG5cbiAgc2VsZjo6UkVBREFCTEUgPSAxXG4gIHNlbGY6OldSSVRBQkxFID0gNFxuXG4gIGF0dHJfcmVhZGVyIDplb2ZcblxuICBhdHRyX2FjY2Vzc29yIDpyZWFkX3Byb2MsICA6c3luYywgOnR0eSwgOndyaXRlX3Byb2NcblxuICBkZWYgaW5pdGlhbGl6ZShmZCwgZmxhZ3MgPSAncicpXG4gICAgQGZkID0gZmRcbiAgICBAZmxhZ3MgPSBmbGFnc1xuICAgIEBlb2YgPSBmYWxzZVxuXG4gICAgaWYgZmxhZ3MuaW5jbHVkZT8oJ3InKSAmJiAhZmxhZ3MubWF0Y2g/KC9bd2ErXS8pXG4gICAgICBAY2xvc2VkID0gOndyaXRlXG4gICAgZWxzaWYgZmxhZ3MubWF0Y2g/KC9bd2FdLykgJiYgIWZsYWdzLm1hdGNoPygvW3IrXS8pXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGZpbGVub1xuICAgIEBmZFxuICBlbmRcblxuICBkZWYgdHR5P1xuICAgIGBzZWxmLnR0eSA9PSB0cnVlYFxuICBlbmRcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBkZWYgZmx1c2hcbiAgICAjIG5vb3BcbiAgZW5kXG5cbiAgZGVmIDw8KHN0cmluZylcbiAgICB3cml0ZShzdHJpbmcpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJpbnQoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9ICN7OjpLZXJuZWwuU3RyaW5nKGBhcmdzW2ldYCl9XG4gICAgICB9XG4gICAgICBzZWxmLiR3cml0ZShhcmdzLmpvaW4oI3skLH0pKTtcbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBwdXRzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIGxpbmVcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3dyaXRlIFwiXFxuXCJ9O1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19hcnJheSl7XG4gICAgICAgICAgICB2YXIgYXJ5ID0gI3tgYXJnc1tpXWAuZmxhdHRlbn1cbiAgICAgICAgICAgIGlmIChhcnkubGVuZ3RoID4gMCkgI3twdXRzKCpgYXJ5YCl9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2ldLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIGxpbmUgPSBhcmdzW2ldLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxpbmUgPSAjezo6S2VybmVsLlN0cmluZyhgYXJnc1tpXWApfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGluZS5lbmRzV2l0aChcIlxcblwiKSkgbGluZSArPSBcIlxcblwiXG4gICAgICAgICAgICAje3dyaXRlIGBsaW5lYH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gICMgUmVhZGluZ1xuXG4gIGRlZiBnZXRjXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIHBhcnRzID0gJydcblxuICAgICMgV2lsbCBleGVjdXJlIGF0IG1vc3QgdHdpY2UgLSBvbmUgdGltZSByZWFkaW5nIGZyb20gYSBidWZmZXJcbiAgICAjIHNlY29uZCB0aW1lIGV4ZWN1dGluZyByZWFkIHByb2NcbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXG4gICAgICBpZiBAcmVhZF9idWZmZXIgIT0gJydcbiAgICAgICAgcmV0ID0gQHJlYWRfYnVmZmVyWzBdXG4gICAgICAgIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclsxLi4tMV1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKDEpXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGVcbiAgICBnZXRjJi5vcmRcbiAgZW5kXG5cbiAgZGVmIHJlYWRieXRlXG4gICAgcmVhZGNoYXIub3JkXG4gIGVuZFxuXG4gIGRlZiByZWFkY2hhclxuICAgIGdldGMgfHwgOjpLZXJuZWwucmFpc2UoOjpFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnKVxuICBlbmRcblxuICBkZWYgcmVhZGxpbmUoKmFyZ3MpXG4gICAgZ2V0cygqYXJncykgfHwgOjpLZXJuZWwucmFpc2UoOjpFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnKVxuICBlbmRcblxuICBkZWYgZ2V0cyhzZXAgPSBmYWxzZSwgbGltaXQgPSBuaWwsIG9wdHMgPSB7fSlcbiAgICBpZiBgc2VwLiQkaXNfbnVtYmVyYCAmJiAhbGltaXRcbiAgICAgIHNlcCwgbGltaXQsIG9wdHMgPSBmYWxzZSwgc2VwLCBsaW1pdFxuICAgIGVuZFxuICAgIGlmIGBzZXAuJCRpc19oYXNoYCAmJiAhbGltaXQgJiYgb3B0cyA9PSB7fVxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IGZhbHNlLCBuaWwsIHNlcFxuICAgIGVsc2lmIGBsaW1pdC4kJGlzX2hhc2hgICYmIG9wdHMgPT0ge31cbiAgICAgIHNlcCwgbGltaXQsIG9wdHMgPSBzZXAsIG5pbCwgbGltaXRcbiAgICBlbmRcblxuICAgIG9yaWdfc2VwID0gc2VwXG5cbiAgICBzZXAgPSAkLyBpZiBzZXAgPT0gZmFsc2VcbiAgICBzZXAgPSAvXFxyP1xcblxccj9cXG4vIGlmIHNlcCA9PSAnJ1xuICAgIHNlcCB8fD0gJydcbiAgICBzZXAgPSBzZXAudG9fc3RyIHVubGVzcyBvcmlnX3NlcCA9PSAnJ1xuXG4gICAgIyBUcnkgdG8gZGVkdWNlIGxlbmd0aCBvZiBhIHJlZ2V4cFxuICAgIHNlcGxlbiA9IG9yaWdfc2VwID09ICcnID8gMiA6IHNlcC5sZW5ndGhcblxuICAgIHNlcCA9IC8gLyBpZiBzZXAgPT0gJyAnICMgV1RGIGlzIHRoaXMsIFN0cmluZyNzcGxpdChcIiBcIikgbWF0Y2hlcyBhbGwgd2hpdGVzcGFjZXM/Pz9cblxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBkYXRhID0gJydcbiAgICByZXQgPSBuaWxcblxuICAgIGJlZ2luXG4gICAgICBAcmVhZF9idWZmZXIgKz0gZGF0YVxuICAgICAgaWYgc2VwICE9ICcnICYmIChgc2VwLiQkaXNfcmVnZXhwYCA/IEByZWFkX2J1ZmZlci5tYXRjaD8oc2VwKSA6IEByZWFkX2J1ZmZlci5pbmNsdWRlPyhzZXApKVxuICAgICAgICBvcmlnX2J1ZmZlciA9IEByZWFkX2J1ZmZlclxuICAgICAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlci5zcGxpdChzZXAsIDIpXG4gICAgICAgIHJldCArPSBvcmlnX2J1ZmZlcltyZXQubGVuZ3RoLCBzZXBsZW5dIGlmIHJldCAhPSBvcmlnX2J1ZmZlclxuICAgICAgICBicmVha1xuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIGRhdGEgPSBzeXNyZWFkX25vcmFpc2Uoc2VwID09ICcnID8gNjVfNTM2IDogMSlcblxuICAgIHVubGVzcyByZXRcbiAgICAgIHJldCwgQHJlYWRfYnVmZmVyID0gKEByZWFkX2J1ZmZlciB8fCAnJyksICcnXG4gICAgICByZXQgPSBuaWwgaWYgcmV0ID09ICcnXG4gICAgZW5kXG5cbiAgICBpZiByZXRcbiAgICAgIGlmIGxpbWl0XG4gICAgICAgIHJldCA9IHJldFswLi4ubGltaXRdXG4gICAgICAgIEByZWFkX2J1ZmZlciA9IHJldFtsaW1pdC4uLTFdICsgQHJlYWRfYnVmZmVyXG4gICAgICBlbmRcbiAgICAgIHJldCA9IHJldC5zdWIoL1xccj9cXG5cXHovLCAnJykgaWYgb3B0c1s6Y2hvbXBdXG4gICAgICByZXQgPSByZXQuc3ViKC9cXEFbXFxyXFxuXSsvLCAnJykgaWYgb3JpZ19zZXAgPT0gJydcbiAgICBlbmRcblxuICAgICRfID0gcmV0IGlmIG9yaWdfc2VwID09IGZhbHNlXG4gICAgcmV0XG4gIGVuZFxuXG4gICMgVGhpcyBtZXRob2QgaXMgdG8gYmUgb3ZlcmxvYWRlZCwgb3IgcmVhZF9wcm9jIGNhbiBiZSBjaGFuZ2VkXG4gIGRlZiBzeXNyZWFkKGludGVnZXIpXG4gICAgYHNlbGYucmVhZF9wcm9jKGludGVnZXIpYCB8fCBiZWdpblxuICAgICAgQGVvZiA9IHRydWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBzeXNyZWFkX25vcmFpc2UoaW50ZWdlcilcbiAgICBzeXNyZWFkKGludGVnZXIpXG4gIHJlc2N1ZSA6OkVPRkVycm9yXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiByZWFkcGFydGlhbChpbnRlZ2VyKVxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0ID0gc3lzcmVhZChpbnRlZ2VyKVxuICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyICsgKHBhcnQgfHwgJycpLCAnJ1xuICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcbiAgICByZXRcbiAgZW5kXG5cbiAgZGVmIHJlYWQoaW50ZWdlciA9IG5pbClcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydHMgPSAnJ1xuICAgIHJldCA9IG5pbFxuXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBwYXJ0c1xuICAgICAgaWYgaW50ZWdlciAmJiBAcmVhZF9idWZmZXIubGVuZ3RoID4gaW50ZWdlclxuICAgICAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclswLi4uaW50ZWdlcl0sIEByZWFkX2J1ZmZlcltpbnRlZ2VyLi4tMV1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKGludGVnZXIgfHwgNjVfNTM2KVxuXG4gICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIsICcnXG4gICAgcmV0XG4gIGVuZFxuXG4gICMgRWFjaGVzXG5cbiAgZGVmIHJlYWRsaW5lcyhzZXBhcmF0b3IgPSAkLylcbiAgICBlYWNoX2xpbmUoc2VwYXJhdG9yKS50b19hXG4gIGVuZFxuXG4gIGRlZiBlYWNoKHNlcCA9ICQvLCAqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCwgc2VwLCAqYXJncyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSAocyA9IGdldHMoc2VwLCAqYXJncykpXG4gICAgICB5aWVsZChzKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfYnl0ZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSAocyA9IGdldGJ5dGUpXG4gICAgICB5aWVsZChzKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY2hhciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSAocyA9IGdldGMpXG4gICAgICB5aWVsZChzKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIENsb3NlZG5lc3NcblxuICBkZWYgY2xvc2VcbiAgICBAY2xvc2VkID0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3JlYWRcbiAgICBpZiBAY2xvc2VkID09IDp3cml0ZVxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbG9zZV93cml0ZVxuICAgIGlmIEBjbG9zZWQgPT0gOnJlYWRcbiAgICAgIEBjbG9zZWQgPSA6Ym90aFxuICAgIGVsc2VcbiAgICAgIEBjbG9zZWQgPSA6d3JpdGVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZD9cbiAgICBAY2xvc2VkID09IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjbG9zZWRfcmVhZD9cbiAgICBAY2xvc2VkID09IDpyZWFkIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF93cml0ZT9cbiAgICBAY2xvc2VkID09IDp3cml0ZSB8fCBAY2xvc2VkID09IDpib3RoXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIGNoZWNrX3dyaXRhYmxlXG4gICAgaWYgY2xvc2VkX3dyaXRlP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJT0Vycm9yLCAnbm90IG9wZW5lZCBmb3Igd3JpdGluZydcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfcmVhZGFibGVcbiAgICBpZiBjbG9zZWRfcmVhZD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SU9FcnJvciwgJ25vdCBvcGVuZWQgZm9yIHJlYWRpbmcnXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIGVhY2hfbGluZSBlYWNoXG4gIGFsaWFzIGVvZj8gZW9mXG5lbmRcblxuOjpTVERJTiAgPSAkc3RkaW4gID0gOjpJTy5uZXcoMCwgJ3InKVxuOjpTVERPVVQgPSAkc3Rkb3V0ID0gOjpJTy5uZXcoMSwgJ3cnKVxuOjpTVERFUlIgPSAkc3RkZXJyID0gOjpJTy5uZXcoMiwgJ3cnKVxuXG5gdmFyIGNvbnNvbGUgPSBPcGFsLmdsb2JhbC5jb25zb2xlYFxuOjpTVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxuOjpTVERFUlIud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZGVycikgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRlcnIud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS53YXJuKHMpfWBcblxuOjpTVERJTi5yZWFkX3Byb2MgPSBgZnVuY3Rpb24ocykgeyB2YXIgcCA9IHByb21wdCgpOyBpZiAocCAhPT0gbnVsbCkgcmV0dXJuIHAgKyBcIlxcblwiOyByZXR1cm4gbmlsOyB9YFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6SU8+Iiwic2VsZiIsIjAiLCIxIiwiMiIsIjMiLCI0IiwiYXR0cl9yZWFkZXIiLCJhdHRyX2FjY2Vzc29yIiwiaW5pdGlhbGl6ZSIsImZkIiwiZmxhZ3MiLCJAZmQiLCJAZmxhZ3MiLCJAZW9mIiwiaW5jbHVkZT8iLCJtYXRjaD8iLCJAY2xvc2VkIiwiZmlsZW5vIiwidHR5PyIsIndyaXRlIiwic3RyaW5nIiwic2l6ZSIsImZsdXNoIiwiPDwiLCJwcmludCIsIktlcm5lbCIsIlN0cmluZyIsIiQsIiwicHV0cyIsImZsYXR0ZW4iLCJnZXRjIiwiQHJlYWRfYnVmZmVyIiwiJHJldF9vcl8xIiwicGFydHMiLCIrIiwicmV0IiwiW10iLCItMSIsInN5c3JlYWRfbm9yYWlzZSIsImdldGJ5dGUiLCJyZWFkYnl0ZSIsInJlYWRjaGFyIiwib3JkIiwicmFpc2UiLCJFT0ZFcnJvciIsInJlYWRsaW5lIiwiZ2V0cyIsImFyZ3MiLCJzZXAiLCJsaW1pdCIsIm9wdHMiLCJvcmlnX3NlcCIsIiQvIiwidG9fc3RyIiwic2VwbGVuIiwibGVuZ3RoIiwiZGF0YSIsIm9yaWdfYnVmZmVyIiwic3BsaXQiLCI2NTUzNiIsInN1YiIsIiRfIiwic3lzcmVhZCIsImludGVnZXIiLCJyZWFkcGFydGlhbCIsInBhcnQiLCJyZWFkIiwiPiIsInJlYWRsaW5lcyIsInNlcGFyYXRvciIsImVhY2hfbGluZSIsInRvX2EiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJzIiwiZWFjaF9ieXRlIiwiZWFjaF9jaGFyIiwiY2xvc2UiLCJjbG9zZV9yZWFkIiwiY2xvc2Vfd3JpdGUiLCJjbG9zZWQ/IiwiPT0iLCJjbG9zZWRfcmVhZD8iLCJjbG9zZWRfd3JpdGU/IiwiY2hlY2tfd3JpdGFibGUiLCJJT0Vycm9yIiwiY2hlY2tfcmVhZGFibGUiLCIkc3RkaW4iLCJJTyIsIm5ldyIsIiRzdGRvdXQiLCIkc3RkZXJyIiwiU1RET1VUIiwid3JpdGVfcHJvYz0iLCJTVERFUlIiLCJyZWFkX3Byb2M9IiwiU1RESU4iXSwibWFwcGluZ3MiOiJBQUFBQSw2QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRSxXQUFBQyxJQUFBLGNBQWlCQyxDQUFqQjtJQUNBLFdBQUFELElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxjQUFpQkcsQ0FBakI7SUFDQSxXQUFBSCxJQUFBLGVBQWtCSSxDQUFsQjtJQUNBLFdBQUFKLElBQUEsZUFBa0JLLENBQWxCO0lBRUEsV0FBQUwsSUFBQSxjQUFpQkUsQ0FBakI7SUFDQSxXQUFBRixJQUFBLGNBQWlCSyxDQUFqQjtJQUVBTCxJQUFBTSxhQUFBQSxDQUFZLEtBQVpBO0lBRUFOLElBQUFPLGVBQUFBLENBQWMsV0FBZCxFQUEyQixNQUEzQixFQUFrQyxLQUFsQyxFQUF3QyxZQUF4Q0E7O0FBRUFDLElBQUFBLDBCQUFBQSxz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QUFvRixrQkFBQUEsQ0FBQUEsQ0FBSCxDQUFBO1FBQ0VDLE9BQUE1RCxPQUFRa0IsT0FBQUEsQ0FBTzJDLGNBQWYsRUFBMEJELHdCQUFsQjFDO01BRFY7UUE5UkowQyxPQUFBO01BOFJJO0lBREZBLENBQUFBLEdBQUFBOztBQU9BRSxJQUFBQSw4QkFBQUEsMEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR3ZGLElBQUFtRixpQkFBQUEsQ0FBQUEsQ0FBSCxDQUFBO1FBQ0VJLE9BQUE5RCxPQUFRa0IsT0FBQUEsQ0FBTzJDLGNBQWYsRUFBMEJDLHdCQUFsQjVDO01BRFY7UUFyU0o0QyxPQUFBO01BcVNJO0lBREZBLENBQUFBLEdBQUFBO0lBTUEsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0F4RixPQUFBLGFBQU0sTUFBTixFQUFXLEtBQVg7RUEzU0ZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE4U0EsV0FBQSxJQUFBLFdBQVd5RixDQUFBQSxlQUFVQyxTQUFJQyxLQUFBQSxDQUFLekYsQ0FBVCxFQUFZSCxHQUFSNEYsQ0FBZEYsQ0FBWDtFQUNBLFdBQUEsSUFBQSxZQUFXRyxDQUFBQSxnQkFBVUYsU0FBSUMsS0FBQUEsQ0FBS3hGLENBQVQsRUFBWUosR0FBUjRGLENBQWRDLENBQVg7RUFDQSxXQUFBLElBQUEsWUFBV0MsQ0FBQUEsZ0JBQVVILFNBQUlDLEtBQUFBLENBQUt2RixDQUFULEVBQVlMLEdBQVI0RixDQUFkRSxDQUFYO0VBRUM5RjtFQUNEK0YsYUFBUUMsZ0JBQUFBLENBQWVoRyx3SUFBZmdHO0VBQ1JDLGFBQVFELGdCQUFBQSxDQUFlaEcseUlBQWZnRztFQUVSaEcsT0FBT2tHLE1BQUFBLENBQWNsRyw4RUFBZGtHLENBQUFBLEVBQUFBLE1BQVBDLFlBQU9ELGNBQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO0FBdFRQbEc7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3MjEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2dlbmVyYXRvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGRlbnlfZnJvemVuX2FjY2Vzc1xuXG5jbGFzcyBFbnVtZXJhdG9yXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICB5aWVsZGVyID0gWWllbGRlci5uZXcoJmJsb2NrKVxuXG4gICAgICAleHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICBPcGFsLnlpZWxkWCgje0BibG9ja30sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS4kdGhyb3dlcl90eXBlID09IFwiYnJlYWtlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZS4kdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpHZW5lcmF0b3I+Iiwic2VsZiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiS2VybmVsIiwicmFpc2UiLCJMb2NhbEp1bXBFcnJvciIsIkBibG9jayIsImVhY2giLCJ5aWVsZGVyIiwibmV3IiwiWWllbGRlciIsInRvX3Byb2MiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFFQUUsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNHQTtRQUVELEtBQUEsUUFBeURDLEtBQXpELENBQUE7VUFBQUMsT0FBUUMsT0FBQUEsQ0FBT0MscUJBQWYsRUFBaUNKLGdCQUF6Qkc7UUFBUjtRQUVBSCxPQUFBSyxDQUFBQSxhQUFTSixLQUFUSTtNQUxGTCxDQUFBQSxHQUFBQTtNQVFBSixPQUFBVSxvQkFBQUEsZ0JBZEosRUFjSUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFkSjtRQWNhO1FBQ1BDLFVBQWlCQyxNQUFQQyxhQUFPRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNUCxLQUFEUyxTQUFBQSxDQUFBQSxDQUFMRjs7QUFHdkJGO0FBQ0FBLHVCQUF5QkMsT0FBUUQ7O0FBRWpDQSxzQkFBd0JELFVBQU9DO0FBQy9CQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQUVNQSxPQUFBVDtNQW5CRlMsQ0FBQUEsSUFBQUE7SUFYRlYsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3MjcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpNZXRob2RcbiAgYXR0cl9yZWFkZXIgOm93bmVyLCA6cmVjZWl2ZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUocmVjZWl2ZXIsIG93bmVyLCBtZXRob2QsIG5hbWUpXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgICBAb3duZXIgICAgPSBvd25lclxuICAgIEBuYW1lICAgICA9IG5hbWVcbiAgICBAbWV0aG9kICAgPSBtZXRob2RcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAje0BtZXRob2R9LiQkcCA9IGJsb2NrO1xuXG4gICAgICByZXR1cm4gI3tAbWV0aG9kfS5hcHBseSgje0ByZWNlaXZlcn0sIGFyZ3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN1cnJ5KGFyaXR5ID0gdW5kZWZpbmVkKVxuICAgIEBtZXRob2QuY3VycnkoYXJpdHkpXG4gIGVuZFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBAbWV0aG9kID4+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBAbWV0aG9kIDw8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiB1bmJpbmRcbiAgICA6OlVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbmVuZFxuXG5jbGFzcyA6OlVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7OjpNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgYmluZCBzaW5nbGV0b24gbWV0aG9kIHRvIGEgZGlmZmVyZW50IGNsYXNzIChleHBlY3RlZCAje29iamVjdH0ua2luZF9vZj8oI3tAb3duZXJ9IHRvIGJlIHRydWUpXCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJpbmRfY2FsbChvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgYmluZChvYmplY3QpLmNhbGwoKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAc291cmNlfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk1ldGhvZD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwicmVjZWl2ZXIiLCJvd25lciIsIm1ldGhvZCIsIm5hbWUiLCJAcmVjZWl2ZXIiLCJAb3duZXIiLCJAbmFtZSIsIkBtZXRob2QiLCJhcml0eSIsInBhcmFtZXRlcnMiLCJzb3VyY2VfbG9jYXRpb24iLCIkcmV0X29yXzEiLCIwIiwiY29tbWVudHMiLCJjYWxsIiwiY3VycnkiLCI+PiIsIm90aGVyIiwiPDwiLCJ1bmJpbmQiLCJVbmJvdW5kTWV0aG9kIiwibmV3IiwiY2xhc3MiLCJ0b19wcm9jIiwiaW5zcGVjdCIsImpvaW4iLCI8Y2xhc3M6VW5ib3VuZE1ldGhvZD4iLCJzb3VyY2UiLCJAc291cmNlIiwiYmluZCIsIm9iamVjdCIsIk1ldGhvZCIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiYmluZF9jYWxsIiwiYXJncyIsImJsb2NrIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFB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Y29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9hcml0aG1ldGljX3NlcXVlbmNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6RW51bWVyYXRvclxuICBjbGFzcyBzZWxmOjpBcml0aG1ldGljU2VxdWVuY2UgPCBzZWxmXG4gICAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcml0aG1ldGljX3NlcScsIHRydWUpYFxuXG4gICAgYHZhciBpbmYgPSBJbmZpbml0eWBcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgaW5pdGlhbGl6ZShyYW5nZSwgc3RlcCA9IHVuZGVmaW5lZCwgY3JlYXRpb25fbWV0aG9kID0gOnN0ZXApXG4gICAgICBAY3JlYXRpb25fbWV0aG9kID0gY3JlYXRpb25fbWV0aG9kXG4gICAgICBpZiByYW5nZS5pc19hPyA6OkFycmF5XG4gICAgICAgIEBzdGVwX2FyZzEsIEBzdGVwX2FyZzIsIEB0b3BmeCwgQGJ5cGZ4ID0gKnJhbmdlXG4gICAgICAgIEByZWNlaXZlcl9udW0gPSBzdGVwXG4gICAgICAgIEBzdGVwID0gMVxuXG4gICAgICAgIEByYW5nZSA9IGlmIEBzdGVwX2FyZzJcbiAgICAgICAgICAgICAgICAgICBAc3RlcCA9IEBzdGVwX2FyZzJcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4uQHN0ZXBfYXJnMSlcbiAgICAgICAgICAgICAgICAgZWxzaWYgQHN0ZXBfYXJnMVxuICAgICAgICAgICAgICAgICAgIChAcmVjZWl2ZXJfbnVtLi5Ac3RlcF9hcmcxKVxuICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgKEByZWNlaXZlcl9udW0uLm5pbClcbiAgICAgICAgICAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIEBza2lwcGVkX2FyZyA9IHRydWUgdW5sZXNzIHN0ZXBcbiAgICAgICAgQHJhbmdlLCBAc3RlcCA9IHJhbmdlLCBzdGVwIHx8IDFcbiAgICAgIGVuZFxuXG4gICAgICBAb2JqZWN0ID0gc2VsZlxuXG4gICAgICA6Oktlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwiIGlmIEBzdGVwID09IDBcbiAgICAgIHVubGVzcyBAc3RlcC5yZXNwb25kX3RvPyA6dG9faW50XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje0BzdGVwLmNsYXNzfSBcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW50byBJbnRlZ2VyJ1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhdHRyX3JlYWRlciA6c3RlcFxuXG4gICAgZGVmIGJlZ2luXG4gICAgICBAcmFuZ2UuYmVnaW5cbiAgICBlbmRcblxuICAgIGRlZiBlbmRcbiAgICAgIEByYW5nZS5lbmRcbiAgICBlbmRcblxuICAgIGRlZiBleGNsdWRlX2VuZD9cbiAgICAgIEByYW5nZS5leGNsdWRlX2VuZD9cbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgX2xlc3Nlcl90aGFuX2VuZD8odmFsKVxuICAgICAgZW5kXyA9IHNlbGYuZW5kIHx8IGBpbmZgXG4gICAgICBpZiBzdGVwID4gMFxuICAgICAgICBleGNsdWRlX2VuZD8gPyB2YWwgPCBlbmRfIDogdmFsIDw9IGVuZF9cbiAgICAgIGVsc2VcbiAgICAgICAgZXhjbHVkZV9lbmQ/ID8gdmFsID4gZW5kXyA6IHZhbCA+PSBlbmRfXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgX2dyZWF0ZXJfdGhhbl9iZWdpbj8odmFsKVxuICAgICAgYmVnaW5fID0gc2VsZi5iZWdpbiB8fCAtYGluZmBcbiAgICAgIGlmIHN0ZXAgPiAwXG4gICAgICAgIHZhbCA+IGJlZ2luX1xuICAgICAgZWxzZVxuICAgICAgICB2YWwgPCBiZWdpbl9cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICAgaXRlciA9IHNlbGYuYmVnaW4gfHwgLWBpbmZgXG5cbiAgICAgIHJldHVybiBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKSA/IGl0ZXIgOiBuaWwgdW5sZXNzIGNvdW50XG5cbiAgICAgIG91dCA9IFtdXG5cbiAgICAgIHdoaWxlIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpICYmIGNvdW50ID4gMFxuICAgICAgICBvdXQgPDwgaXRlclxuICAgICAgICBpdGVyICs9IHN0ZXBcbiAgICAgICAgY291bnQgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIG91dFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goJmJsb2NrKVxuICAgICAgcmV0dXJuIHNlbGYgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICBjYXNlIHNlbGYuYmVnaW5cbiAgICAgIHdoZW4gbmlsXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIFR5cGVFcnJvciwgXCJuaWwgY2FuJ3QgYmUgY29lcmNlZCBpbnRvIEludGVnZXJcIlxuICAgICAgZW5kXG5cbiAgICAgIGl0ZXIgPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxuXG4gICAgICB3aGlsZSBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKVxuICAgICAgICB5aWVsZCBpdGVyXG4gICAgICAgIGl0ZXIgKz0gc3RlcFxuICAgICAgZW5kXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAgIGNhc2Ugc2VsZi5lbmRcbiAgICAgIHdoZW4gYGluZmAsIC1gaW5mYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsIHNlbGYuZW5kXG4gICAgICB3aGVuIG5pbFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgZW5kbGVzcyBhcml0aG1ldGljIHNlcXVlbmNlJ1xuICAgICAgZW5kXG5cbiAgICAgIGl0ZXIgPSBzZWxmLmVuZCAtICgoc2VsZi5lbmQgLSBzZWxmLmJlZ2luKSAlIHN0ZXApXG4gICAgICBpdGVyIC09IHN0ZXAgdW5sZXNzIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpXG5cbiAgICAgIHJldHVybiBfZ3JlYXRlcl90aGFuX2JlZ2luPyhpdGVyKSA/IGl0ZXIgOiBuaWwgdW5sZXNzIGNvdW50XG5cbiAgICAgIG91dCA9IFtdXG5cbiAgICAgIHdoaWxlIF9ncmVhdGVyX3RoYW5fYmVnaW4/KGl0ZXIpICYmIGNvdW50ID4gMFxuICAgICAgICBvdXQgPDwgaXRlclxuICAgICAgICBpdGVyIC09IHN0ZXBcbiAgICAgICAgY291bnQgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIG91dC5yZXZlcnNlXG4gICAgZW5kXG5cbiAgICBkZWYgc2l6ZVxuICAgICAgc3RlcF9zaWduID0gc3RlcCA+IDAgPyAxIDogLTFcblxuICAgICAgaWYgIV9sZXNzZXJfdGhhbl9lbmQ/KHNlbGYuYmVnaW4pXG4gICAgICAgIDBcbiAgICAgIGVsc2lmIFstYGluZmAsIGBpbmZgXS5pbmNsdWRlPyhzdGVwKVxuICAgICAgICAxXG4gICAgICBlbHNpZiBbLWBpbmZgICogc3RlcF9zaWduLCBuaWxdLmluY2x1ZGU/KHNlbGYuYmVnaW4pIHx8XG4gICAgICAgICAgICBbYGluZmAgKiBzdGVwX3NpZ24sIG5pbF0uaW5jbHVkZT8oc2VsZi5lbmQpXG4gICAgICAgIGBpbmZgXG4gICAgICBlbHNlXG4gICAgICAgIGl0ZXIgPSBzZWxmLmVuZCAtICgoc2VsZi5lbmQgLSBzZWxmLmJlZ2luKSAlIHN0ZXApXG4gICAgICAgIGl0ZXIgLT0gc3RlcCB1bmxlc3MgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcbiAgICAgICAgKChpdGVyIC0gc2VsZi5iZWdpbikgLyBzdGVwKS5hYnMudG9faSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmID09KG90aGVyKVxuICAgICAgc2VsZi5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxuICAgICAgICBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luICYmXG4gICAgICAgIHNlbGYuZW5kID09IG90aGVyLmVuZCAmJlxuICAgICAgICBzdGVwID09IG90aGVyLnN0ZXAgJiZcbiAgICAgICAgZXhjbHVkZV9lbmQ/ID09IG90aGVyLmV4Y2x1ZGVfZW5kP1xuICAgIGVuZFxuXG4gICAgZGVmIGhhc2hcbiAgICAgIFtzZWxmLmJlZ2luLCBzZWxmLmVuZCwgc3RlcCwgZXhjbHVkZV9lbmQ/XS5oYXNoXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgaWYgQHJlY2VpdmVyX251bVxuICAgICAgICBhcmdzID0gaWYgQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICBcIigje0B0b3BmeH0je0BzdGVwX2FyZzEuaW5zcGVjdH0sICN7QGJ5cGZ4fSN7QHN0ZXBfYXJnMi5pbnNwZWN0fSlcIlxuICAgICAgICAgICAgICAgZWxzaWYgQHN0ZXBfYXJnMVxuICAgICAgICAgICAgICAgICBcIigje0B0b3BmeH0je0BzdGVwX2FyZzEuaW5zcGVjdH0pXCJcbiAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICAgIFwiKCN7QHJlY2VpdmVyX251bS5pbnNwZWN0fS4je0BjcmVhdGlvbl9tZXRob2R9I3thcmdzfSlcIlxuICAgICAgZWxzZVxuICAgICAgICBhcmdzID0gdW5sZXNzIEBza2lwcGVkX2FyZ1xuICAgICAgICAgICAgICAgICBcIigje0BzdGVwfSlcIlxuICAgICAgICAgICAgICAgZW5kXG4gICAgICAgIFwiKCgje0ByYW5nZS5pbnNwZWN0fSkuI3tAY3JlYXRpb25fbWV0aG9kfSN7YXJnc30pXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgPT09ID09XG4gICAgYWxpYXMgZXFsPyA9PVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6QXJpdGhtZXRpY1NlcXVlbmNlPiIsImluaXRpYWxpemUiLCJyYW5nZSIsInN0ZXAiLCJjcmVhdGlvbl9tZXRob2QiLCJAY3JlYXRpb25fbWV0aG9kIiwiaXNfYT8iLCJBcnJheSIsIkBzdGVwX2FyZzEiLCJAc3RlcF9hcmcyIiwiQHRvcGZ4IiwiQGJ5cGZ4IiwiQHJlY2VpdmVyX251bSIsIkBzdGVwIiwiMSIsIkByYW5nZSIsIkBza2lwcGVkX2FyZyIsIiRyZXRfb3JfMSIsIkBvYmplY3QiLCJzZWxmIiwiMCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsImJlZ2luIiwiZW5kIiwiZXhjbHVkZV9lbmQ/IiwiX2xlc3Nlcl90aGFuX2VuZD8iLCJ2YWwiLCJlbmRfIiwiPiIsIjwiLCI8PSIsIj49IiwiX2dyZWF0ZXJfdGhhbl9iZWdpbj8iLCJiZWdpbl8iLCItQCIsImZpcnN0IiwiY291bnQiLCJpdGVyIiwib3V0IiwiPDwiLCIrIiwiLSIsImVhY2giLCJibG9ja19naXZlbj8iLCJUeXBlRXJyb3IiLCJsYXN0IiwiRmxvYXREb21haW5FcnJvciIsIlJhbmdlRXJyb3IiLCIlIiwicmV2ZXJzZSIsInNpemUiLCJzdGVwX3NpZ24iLCItMSIsImluY2x1ZGU/IiwiKiIsIi8iLCJhYnMiLCJ0b19pIiwiPT0iLCJvdGhlciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImhhc2giLCJpbnNwZWN0IiwiYXJncyJdLCJtYXBwaW5ncyI6IkFBQUFBLHlEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDR0E7TUFFQUE7O0FBR0RDLE1BQUFBLDBCQUFBQSxzQkFBZUMsS0FBRCxFQUFRQyxJQUFSLEVBQTBCQyxlQUF4Q0g7QUFBQUEsUUFBQUE7Ozs7UUFBd0MsK0NBQWtCO1FBQ3hESSx1QkFBbUJEO1FB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QUl4RCxTQUFKLENBQUEsR0FBVXdELEdBRFosQ0FBQTtVQUdQQSxPQUFDQSxJQUFELEdBQUEsQ0FBS3RELFVBQU1zRCxTQUFBQSxDQUFBQSxDQUFYLENBQUEsR0FBb0JBLElBQXBCLEdBQUEsQ0FBd0JoRSxvQkFBeEIsQ0FBQSxHQUFBLENBQTJDaUUsSUFBM0MsQ0FBQSxHQUFnREQ7UUFabEQ7TUFERkEsQ0FBQUEsR0FBQUE7TUFpQkEsYUFBTSxLQUFOLEVBQVUsSUFBVjtNQUNBckUsT0FBQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBN0tGQSxHQUFNbUIsSUFBTm5CLEVBQWlDbUIsSUFBakNuQjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzY5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyA6OlJhbmdlXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19yYW5nZSA9IHRydWVgXG5cbiAgYXR0cl9yZWFkZXIgOmJlZ2luLCA6ZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZmlyc3QsIGxhc3QsIGV4Y2x1ZGUgPSBmYWxzZSlcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYmFkIHZhbHVlIGZvciByYW5nZScgdW5sZXNzIGZpcnN0IDw9PiBsYXN0IHx8IGZpcnN0Lm5pbD8gfHwgbGFzdC5uaWw/XG5cbiAgICBAYmVnaW4gPSBmaXJzdFxuICAgIEBlbmQgICA9IGxhc3RcbiAgICBAZXhjbCAgPSBleGNsdWRlXG4gIGVuZFxuXG4gIGRlZiA9PT0odmFsdWUpXG4gICAgaW5jbHVkZT8gdmFsdWVcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gaXNfaW5maW5pdGUoc2VsZikge1xuICAgICAgaWYgKHNlbGYuYmVnaW4gPT09IG5pbCB8fCBzZWxmLmVuZCA9PT0gbmlsIHx8XG4gICAgICAgICAgc2VsZi5iZWdpbiA9PT0gLUluZmluaXR5IHx8IHNlbGYuZW5kID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IEluZmluaXR5IHx8IHNlbGYuZW5kID09PSAtSW5maW5pdHkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb3VudCgmYmxvY2spXG4gICAgaWYgIWJsb2NrX2dpdmVuPyAmJiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgICByZXR1cm4gOjpGbG9hdDo6SU5GSU5JVFlcbiAgICBlbmRcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgZW5kbGVzcyByYW5nZSB0byBhbiBhcnJheScgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4ubmlsPyAmJiAtMSkgfHwgKEBiZWdpbiA8PT4gdmFsdWUpIHx8IGZhbHNlXG4gICAgZW5kX2NtcCA9IChAZW5kLm5pbD8gJiYgLTEpIHx8ICh2YWx1ZSA8PT4gQGVuZCkgfHwgZmFsc2VcbiAgICBpZiBAZXhjbFxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDwgMFxuICAgIGVsc2VcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8PSAwXG4gICAgZW5kICYmIGJlZ19jbXAgJiYgYmVnX2NtcCA8PSAwXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxpbWl0O1xuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfbnVtYmVyICYmICN7QGVuZH0uJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufSAlIDEgIT09IDAgfHwgI3tAZW5kfSAlIDEgIT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSBGbG9hdFwifVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gI3tAYmVnaW59LCBsaW1pdCA9ICN7QGVuZH0gKyAje0BleGNsID8gMCA6IDF9OyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgIGJsb2NrKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAje0BiZWdpbi51cHRvKEBlbmQsIEBleGNsLCAmYmxvY2spfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gQGJlZ2luXG4gICAgbGFzdCAgICA9IEBlbmRcblxuICAgIHVubGVzcyBjdXJyZW50LnJlc3BvbmRfdG8/KDpzdWNjKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tICN7Y3VycmVudC5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgd2hpbGUgQGVuZC5uaWw/IHx8IChjdXJyZW50IDw9PiBsYXN0KSA8IDBcbiAgICAgIHlpZWxkIGN1cnJlbnRcblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3VjY1xuICAgIGVuZFxuXG4gICAgeWllbGQgY3VycmVudCBpZiAhQGV4Y2wgJiYgY3VycmVudCA9PSBsYXN0XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgOjpSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgIEBleGNsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChuID0gdW5kZWZpbmVkKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJyBpZiBAYmVnaW4ubmlsP1xuICAgIHJldHVybiBAYmVnaW4gaWYgYG4gPT0gbnVsbGBcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgbGFzdChuID0gdW5kZWZpbmVkKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZScgaWYgQGVuZC5uaWw/XG4gICAgcmV0dXJuIEBlbmQgaWYgYG4gPT0gbnVsbGBcbiAgICB0b19hLmxhc3QobilcbiAgZW5kXG5cbiAgIyBGSVhNRTogY3VycmVudGx5IGhhcmRjb2RlZCB0byBhc3N1bWUgcmFuZ2UgaG9sZHMgbnVtZXJpY3NcbiAgZGVmIG1heFxuICAgIGlmIEBlbmQubmlsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWF4aW11bSBvZiBlbmRsZXNzIHJhbmdlJ1xuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiAhQGJlZ2luLm5pbD8gJiYgKEBiZWdpbiA+IEBlbmQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgYCN7QGV4Y2x9ID8gI3tAZW5kfSAtIDEgOiAje0BlbmR9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWluXG4gICAgaWYgQGJlZ2luLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJ1xuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiAhQGVuZC5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgQGV4Y2wgJiYgQGJlZ2luID09IEBlbmQpXG4gICAgICBuaWxcbiAgICBlbHNlXG4gICAgICBAYmVnaW5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICBpbmZpbml0eSA9IDo6RmxvYXQ6OklORklOSVRZXG5cbiAgICByZXR1cm4gMCBpZiAoQGJlZ2luID09IGluZmluaXR5ICYmICFAZW5kLm5pbD8pIHx8IChAZW5kID09IC1pbmZpbml0eSAmJiAhQGJlZ2luLm5pbD8pXG4gICAgcmV0dXJuIGluZmluaXR5IGlmIGBpc19pbmZpbml0ZShzZWxmKWBcbiAgICByZXR1cm4gbmlsIHVubGVzcyA6Ok51bWVyaWMgPT09IEBiZWdpbiAmJiA6Ok51bWVyaWMgPT09IEBlbmRcblxuICAgIHJhbmdlX2JlZ2luID0gQGJlZ2luXG4gICAgcmFuZ2VfZW5kICAgPSBAZW5kXG4gICAgcmFuZ2VfZW5kICAtPSAxIGlmIEBleGNsXG5cbiAgICByZXR1cm4gMCBpZiByYW5nZV9lbmQgPCByYW5nZV9iZWdpblxuXG4gICAgYE1hdGguYWJzKHJhbmdlX2VuZCAtIHJhbmdlX2JlZ2luKSArIDFgLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobiA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGNvZXJjZVN0ZXBTaXplKCkge1xuICAgICAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICAgICAgbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW4uJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBuID0gI3s6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSBuZWdhdGl2ZVwifVxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAjezo6RmxvYXQ6OkVQU0lMT059LFxuICAgICAgICAgICAgICBzaXplO1xuXG4gICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLmV4Y2wpIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiAtIGVycik7XG4gICAgICAgICAgICBpZiAoc2l6ZSAqIG4gKyBiZWdpbiA8IGVuZCkge1xuICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiArIGVycikgKyAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICBpZiAoQGJlZ2luLmlzX2E/KE51bWVyaWMpIHx8IEBiZWdpbi5uaWw/KSAmJlxuICAgICAgICAgKEBlbmQuaXNfYT8oTnVtZXJpYykgfHwgQGVuZC5uaWw/KSAmJlxuICAgICAgICAgIShAYmVnaW4ubmlsPyAmJiBAZW5kLm5pbD8pXG5cbiAgICAgICAgcmV0dXJuIDo6RW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlLm5ldyhzZWxmLCBuLCA6c3RlcClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgY29lcmNlU3RlcFNpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gZmxvYXQgZnJvbSBzdHJpbmcnfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlYWNoX3dpdGhfaW5kZXggZG8gfHZhbHVlLCBpZHh8XG4gICAgICAgIHlpZWxkKHZhbHVlKSBpZiBpZHggJSBuID09IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUobilcbiAgICBpZiBAYmVnaW4uaXNfYT8oTnVtZXJpYykgJiYgQGVuZC5pc19hPyhOdW1lcmljKVxuICAgICAgOjpFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UubmV3KHNlbGYsIG4sIDolKVxuICAgIGVsc2VcbiAgICAgIHN0ZXAobilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6YnNlYXJjaCkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaWYgYGlzX2luZmluaXRlKHNlbGYpICYmIChzZWxmLmJlZ2luLiQkaXNfbnVtYmVyIHx8IHNlbGYuZW5kLiQkaXNfbnVtYmVyKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgXCJDYW4ndCAjYnNlYXJjaCBhbiBpbmZpbml0ZSByYW5nZVwiXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2luIHx8ICcnfSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kIHx8ICcnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbiAmJiBAYmVnaW4uaW5zcGVjdH0je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCAmJiBAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuXG4gIGFsaWFzID09IGVxbD9cbiAgYWxpYXMgaW5jbHVkZT8gY292ZXI/XG4gIGFsaWFzIG1lbWJlcj8gY292ZXI/XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmFuZ2U+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJmaXJzdCIsImxhc3QiLCJleGNsdWRlIiwiQGJlZ2luIiwiS2VybmVsIiwicmFpc2UiLCJOYW1lRXJyb3IiLCI8PT4iLCJuaWw/IiwiQXJndW1lbnRFcnJvciIsIkBlbmQiLCJAZXhjbCIsIj09PSIsInZhbHVlIiwiaW5jbHVkZT8iLCJjb3VudCIsImJsb2NrX2dpdmVuPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwidG9fYSIsIlR5cGVFcnJvciIsImNvdmVyPyIsImJlZ19jbXAiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCItMSIsImVuZF9jbXAiLCI8IiwiMCIsIjw9IiwiZWFjaCIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsInNpemUiLCIxIiwidXB0byIsImJsb2NrIiwidG9fcHJvYyIsImN1cnJlbnQiLCJyZXNwb25kX3RvPyIsImNsYXNzIiwic3VjYyIsImVxbD8iLCJvdGhlciIsIlJhbmdlIiwiZXhjbHVkZV9lbmQ/IiwiYmVnaW4iLCJlbmQiLCJuIiwiUmFuZ2VFcnJvciIsIm1heCIsIj4iLCJtaW4iLCJpbmZpbml0eSIsIi1AIiwiTnVtZXJpYyIsInJhbmdlX2JlZ2luIiwicmFuZ2VfZW5kIiwiLSIsInRvX2kiLCJzdGVwIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiLyIsImNlaWwiLCJGbG9hdDo6RVBTSUxPTiIsImlzX2E/IiwiRW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlIiwiRW51bWVyYXRvciIsIm5ldyIsImJsb2NrIGluIHN0ZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIHN0ZXAiLCJpIiwibG9vcCIsIisiLCIqIiwiPj0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpZHgiLCIlIiwiYnNlYXJjaCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19zIiwiaW5zcGVjdCIsIm1hcnNoYWxfbG9hZCIsImFyZ3MiLCJbXSIsImhhc2giXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUVDRDtJQUVERixJQUFBSyxhQUFBQSxDQUFZLE9BQVosRUFBb0IsS0FBcEJBOztBQUVBQyxJQUFBQSwwQkFBQUEsc0JBQWVDLEtBQUQsRUFBUUMsSUFBUixFQUFjQyxPQUE1Qkg7QUFBQUEsTUFBQUE7OztNQUE0QiwrQkFBVTtNQUNwQyxJQUFBLFFBQTJESSxVQUEzRCxDQUFBO1FBQUFDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCUCwyQkFBcEJNO01BQVI7TUFDQSxLQUE2RCxDQUFBLENBQUEsUUFBQUwsS0FBTU8sUUFBQUEsQ0FBSU4sSUFBSk0sQ0FBTixDQUFBLElBQUEsQ0FBQSxRQUFrQlAsS0FBS1EsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQWdDUCxJQUFJTyxTQUFBQSxDQUFBQSxDQUFwQyxDQUFBLENBQUEsQ0FBN0Q7UUFBQUosT0FBUUMsT0FBQUEsQ0FBT0ksb0JBQWYsRUFBZ0NWLHFCQUF4Qk07TUFBUjtNQUVBRixhQUFTSDtNQUNUVSxXQUFTVDtNQUNURixPQUFBWSxDQUFBQSxZQUFTVCxPQUFUUztJQU5GWixDQUFBQSxJQUFBQTs7QUFTQWEsSUFBQUEsbUJBQUFBLDRCQUFRQyxLQUFSRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQW5CLElBQUFxQixhQUFBQSxDQUFTRCxLQUFUQztJQURGRixDQUFBQSxHQUFBQTs7QUFLRmpCO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVFb0IsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFLElBQUcsQ0FBQSxLQUFDQyxlQUFELENBQUEsSUFBQSxDQUFBLFFBQWtCRCxpQkFBbEIsQ0FBQSxDQUFBLENBQUg7UUFDRSxPQUFPRSxJQUFBQyxZQUFBRDtNQURUO01BR0FGLE9BQUEsT0FBQXRCLElBQUEsRUFBQSxnREFBQSxTQUFBLEVBQUEsRUFBQSxFQUFBLEtBQUE7SUFKRnNCLENBQUFBLEdBQUFBOztBQU9BSSxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7TUFDRSxJQUFBLFFBQTJFQSxpQkFBM0UsQ0FBQTtRQUFBZixPQUFRQyxPQUFBQSxDQUFPZSxnQkFBZixFQUE0QkQsMENBQXBCZDtNQUFSO01BQ0FjLE9BQUEsT0FBQTFCLElBQUEsRUFBQSw4Q0FBQSxRQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7SUFGRjBCLENBQUFBLEdBQUFBOztBQUtBRSxJQUFBQSxzQkFBQUEsNkJBQVdSLEtBQVhRO0FBQUFBLE1BQUFBOzs7TUFDRUMsVUFBVSxDQUFBLFFBQUFDLENBQUFBLFlBQUEsQ0FBQSxRQUFBQyxDQUFBQSxZQUFDLENBQUEsUUFBQUMsQ0FBQUEsWUFBQXRCLFVBQU1LLFNBQUFBLENBQUFBLENBQU5pQixDQUFBLENBQUEsR0FBQSxDQUFlQyxFQUFmLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBREYsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBd0JyQixVQUFPSSxRQUFBQSxDQUFJTSxLQUFKTixDQUEvQixDQUFBLENBQUFnQixDQUFBLENBQUEsSUFBQSxDQUFBLFNBQUEsQ0FBQTtNQUNWSSxVQUFVLENBQUEsUUFBQUosQ0FBQUEsWUFBQSxDQUFBLFFBQUFDLENBQUFBLFlBQUMsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBZixRQUFJRixTQUFBQSxDQUFBQSxDQUFKaUIsQ0FBQSxDQUFBLEdBQUEsQ0FBYUMsRUFBYixJQUFBLENBQUEsU0FBQSxDQUFBLENBQURGLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXNCWCxLQUFNTixRQUFBQSxDQUFJRyxRQUFKSCxDQUE1QixDQUFBLENBQUFnQixDQUFBLENBQUEsSUFBQSxDQUFBLFNBQUEsQ0FBQTtNQUNWLElBQUEsUUFBQUEsQ0FBQUEsWUFBQSxDQUFBLFFBQUFDLENBQUFBLFlBQUEsQ0FBQSxRQUFHYixTQUFILENBQUEsR0FBQSxDQUNFLENBQUEsUUFBQWMsQ0FBQUEsWUFBQUUsT0FBQUYsQ0FBQSxDQUFBLEdBQUEsQ0FBbUJHLE9BQVJELE9BQVFDLEVBQUVDLENBQUZELENBQW5CLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FERixJQUdFLENBQUEsUUFBQUgsQ0FBQUEsWUFBQUUsT0FBQUYsQ0FBQSxDQUFBLEdBQUEsQ0FBbUJLLE9BQVJILE9BQVFHLEVBQUdELENBQUhDLENBQW5CLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FIRixDQUFBTixDQUFBLENBQUEsR0FBQSxDQUlPRixPQUpQLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQUMsQ0FBQSxDQUFBO1FBSWtCRixPQUFRUyxPQUFSUixPQUFRUSxFQUFHRCxDQUFIQztNQUoxQjtRQUFBVCxPQUFBO01BQUE7SUFIRkEsQ0FBQUEsR0FBQUE7O0FBVUFVLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRSxLQUF1Q2YsZUFBdkM7UUFBQSxPQUFPZ0IsTUFBQXZDLElBQUF1QyxZQUFBQSxFQUFBQSxDQUFTLE1BQVRBLENBQUFBLEVBQUFDLGFBQUFBLEVBQUFDOztVQUFrQkEsT0FBQXpDLElBQUEwQyxNQUFBQSxDQUFBQSxDQUFsQkYsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFEO01BQVA7O0FBR0pEOztBQUVBQSxVQUFZNUIsVUFBTzRCLGdCQUFrQnJCLFFBQUtxQjtBQUMxQ0EsWUFBYzVCLFVBQU80QixjQUFnQnJCLFFBQUtxQjtBQUMxQ0EsVUFBWTNCLE9BQVFDLE9BQUFBLENBQU9lLGdCQUFmLEVBQTRCVywwQkFBcEIxQjtBQUNwQjBCOztBQUVBQSxpQkFBbUI1QixVQUFPNEIsVUFBWXJCLFFBQUtxQixHQUFLLENBQUEsUUFBQXBCLFNBQUEsQ0FBQSxHQUFBLENBQVFrQixDQUFSLElBQUEsQ0FBWU8sQ0FBWixDQUFBLENBQWNMO0FBQzlEQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBLFVBQVk1QixVQUFPNEIsZ0JBQWtCckIsUUFBS3FCO0FBQzFDQSxRQUFnQk0sTUFBTmxDLFVBQU1rQyxRQUFBQSxFQUFBQSxDQUFNM0IsUUFBWixFQUFrQkMsU0FBWjBCLENBQUFBLEVBQW9CQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFuQkY7QUFDaEJOO0FBQ0FBO0FBQ0FBO01BRUlTLFVBQVVyQztNQUNWRixPQUFVUztNQUVWLEtBQUEsUUFBTzhCLE9BQU9DLGdCQUFBQSxDQUFhLE1BQWJBLENBQWQsQ0FBQTtRQUNFckMsT0FBUUMsT0FBQUEsQ0FBT2UsZ0JBQWYsRUFBNkJXLHFCQUFELEdBQUEsQ0FBc0JTLE9BQU9FLE9BQUFBLENBQUFBLENBQTdCLENBQXBCckM7TUFEVjtNQUlBLE9BQUEsUUFBTSxDQUFBLFFBQUFrQixDQUFBQSxZQUFBYixRQUFJRixTQUFBQSxDQUFBQSxDQUFKZSxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFnQ0ssT0FBbEJZLE9BQVFqQyxRQUFBQSxDQUFJTixJQUFKTSxDQUFVcUIsRUFBRUMsQ0FBRkQsQ0FBaEMsQ0FBQSxDQUFOLENBQUE7O1FBQ0UsbUJBQU1ZLE9BQU47UUFFQUEsVUFBVUEsT0FBT0csTUFBQUEsQ0FBQUE7TUFIbkI7TUFNQSxJQUFpQixDQUFBLEtBQUNoQyxTQUFELENBQUEsSUFBQSxDQUFBLE1BQVU2QixPQUFWLEVBQXFCdkMsSUFBckIsQ0FBQSxDQUFBLENBQWpCO1FBQUEsbUJBQU11QyxPQUFOO01BQUE7TUFFQVQsT0FBQXRDO0lBdkNGc0MsQ0FBQUEsR0FBQUE7O0FBMENBYSxJQUFBQSxvQkFBQUEsMkJBQVNDLEtBQVREO0FBQUFBLE1BQUFBOzs7TUFDRSxLQUFBLFFBQW9CRSxZQUFwQixFQUFnQ0QsS0FBaEMsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBLElBQUEsUUFBQXRCLENBQUFBLFlBQUEsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBYixTQUFNQyxRQUFBQSxDQUFJaUMsS0FBS0UsaUJBQUFBLENBQUFBLENBQVRuQyxDQUFOWSxDQUFBLENBQUEsR0FBQSxDQUNFckIsVUFBTXlDLFNBQUFBLENBQU1DLEtBQUtHLE9BQUFBLENBQUFBLENBQVhKLENBRFIsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFBckIsQ0FBQSxDQUFBO1FBRUVxQixPQUFBbEMsUUFBSWtDLFNBQUFBLENBQU1DLEtBQUtJLEtBQUFBLENBQUFBLENBQVhMO01BRk47UUFBQUEsT0FBQTtNQUFBO0lBSEZBLENBQUFBLEdBQUFBOztBQVFBRyxJQUFBQSw0QkFBQUEsYUFDRSxNQURGQSxDQUFBQSxHQUFBQTs7QUFJQS9DLElBQUFBLHFCQUFBQSxpQkFBVWtELENBQVZsRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFLElBQUEsUUFBNEVHLFVBQU1LLFNBQUFBLENBQUFBLENBQWxGLENBQUE7UUFBQUosT0FBUUMsT0FBQUEsQ0FBTzhDLGlCQUFmLEVBQTZCbkQsMkNBQXJCSztNQUFSO01BQ0EsSUFBQSxRQUFrQkwsU0FBbEIsQ0FBQTtRQUFBLE9BQU9HO01BQVA7TUFDQUgsT0FBQSxPQUFBUCxJQUFBLEVBQUEsZ0RBQUEsU0FBQSxFQUFBLENBQUF5RCxDQUFBLENBQUEsRUFBQSxNQUFBO0lBSEZsRCxDQUFBQSxJQUFBQTs7QUFNQUMsSUFBQUEsb0JBQUFBLGdCQUFTaUQsQ0FBVGpEO0FBQUFBLE1BQUFBOzs7O01BQ0UsSUFBQSxRQUEwRVMsUUFBSUYsU0FBQUEsQ0FBQUEsQ0FBOUUsQ0FBQTtRQUFBSixPQUFRQyxPQUFBQSxDQUFPOEMsaUJBQWYsRUFBNkJsRCx5Q0FBckJJO01BQVI7TUFDQSxJQUFBLFFBQWdCSixTQUFoQixDQUFBO1FBQUEsT0FBT1M7TUFBUDtNQUNBVCxPQUFBUixJQUFBMEIsTUFBQUEsQ0FBQUEsQ0FBSWxCLE1BQUFBLENBQU1pRCxDQUFOakQ7SUFITkEsQ0FBQUEsSUFBQUE7O0FBT0FtRCxJQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQUFBO01BQ0UsSUFBQSxRQUFHMUMsUUFBSUYsU0FBQUEsQ0FBQUEsQ0FBUCxDQUFBO1FBQ0U0QyxPQUFBaEQsT0FBUUMsT0FBQUEsQ0FBTzhDLGlCQUFmLEVBQTZCQyx5Q0FBckIvQztNQURWLE9BRUEsSUFBTVcsZ0JBQU47UUFDRW9DLE9BQUEsT0FBQTNELElBQUEsRUFBQSw0Q0FBQSxPQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7TUFERixPQUVBLElBQU0sQ0FBQSxLQUFDVSxVQUFNSyxTQUFBQSxDQUFBQSxDQUFQLENBQUEsSUFBQSxDQUFpQixDQUFBLFFBQU82QyxPQUFQbEQsVUFBT2tELEVBQUUzQyxRQUFGMkMsQ0FBUCxDQUFBLElBQUEsQ0FDQSxDQUFBLFFBQUExQyxTQUFBLENBQUEsSUFBQSxDQUFBLE1BQVNSLFVBQVQsRUFBbUJPLFFBQW5CLENBQUEsQ0FBQSxDQURBLENBQUEsQ0FBakIsQ0FBQSxDQUFOO1FBRUUwQyxPQUFBO01BRkY7UUFJRUEsT0FBR3pDLFNBQU15QyxHQUFLMUMsUUFBSzBDLE9BQVMxQztNQUo5QjtJQUxGMEMsQ0FBQUEsR0FBQUE7O0FBYUFFLElBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7TUFDRSxJQUFBLFFBQUduRCxVQUFNSyxTQUFBQSxDQUFBQSxDQUFULENBQUE7UUFDRThDLE9BQUFsRCxPQUFRQyxPQUFBQSxDQUFPOEMsaUJBQWYsRUFBNkJHLDJDQUFyQmpEO01BRFYsT0FFQSxJQUFNVyxnQkFBTjtRQUNFc0MsT0FBQSxPQUFBN0QsSUFBQSxFQUFBLDRDQUFBLE9BQUEsRUFBQSxFQUFBLEVBQUEsTUFBQTtNQURGLE9BRUEsSUFBTSxDQUFBLEtBQUNpQixRQUFJRixTQUFBQSxDQUFBQSxDQUFMLENBQUEsSUFBQSxDQUFlLENBQUEsUUFBTzZDLE9BQVBsRCxVQUFPa0QsRUFBRTNDLFFBQUYyQyxDQUFQLENBQUEsSUFBQSxDQUNBLENBQUEsUUFBQTFDLFNBQUEsQ0FBQSxJQUFBLENBQUEsTUFBU1IsVUFBVCxFQUFtQk8sUUFBbkIsQ0FBQSxDQUFBLENBREEsQ0FBQSxDQUFmLENBQUEsQ0FBTjtRQUVFNEMsT0FBQTtNQUZGO1FBSUVBLE9BQUFuRDtNQUpGO0lBTEZtRCxDQUFBQSxHQUFBQTs7QUFhQW5CLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFb0IsV0FBV3RDLElBQUFDLFlBQUFEO01BRVgsSUFBWSxDQUFDLENBQUEsTUFBQWQsVUFBQSxFQUFVb0QsUUFBVixDQUFBLElBQUEsQ0FBQSxLQUF1QjdDLFFBQUlGLFNBQUFBLENBQUFBLENBQTNCLENBQUEsQ0FBQSxDQUFELElBQUEsQ0FBdUMsQ0FBQSxNQUFBRSxRQUFBLEVBQVM2QyxRQUFEQyxPQUFBQSxDQUFBQSxDQUFSLENBQUEsSUFBQSxDQUFBLEtBQXNCckQsVUFBTUssU0FBQUEsQ0FBQUEsQ0FBNUIsQ0FBQSxDQUFBLENBQXZDLENBQUEsQ0FBWjtRQUFBLE9BQU9xQjtNQUFQO01BQ0EsSUFBQSxRQUFvQk0saUJBQXBCLENBQUE7UUFBQSxPQUFPb0I7TUFBUDtNQUNBLEtBQWtCLENBQUEsUUFBQUUsY0FBQSxFQUFjdEQsVUFBZCxDQUFBLElBQUEsQ0FBQSxRQUF3QnNELGNBQXhCLEVBQXNDL0MsUUFBdEMsQ0FBQSxDQUFBLENBQWxCO1FBQUEsT0FBTztNQUFQO01BRUFnRCxjQUFjdkQ7TUFDZHdELFlBQWNqRDtNQUNkLElBQUEsUUFBbUJDLFNBQW5CLENBQUE7UUFBQWdELFlBQVdDLFVBQVhELFNBQVdDLEVBQUd4QixDQUFId0I7TUFBWDtNQUVBLElBQUEsUUFBc0JoQyxPQUFWK0IsU0FBVS9CLEVBQUU4QixXQUFGOUIsQ0FBdEIsQ0FBQTtRQUFBLE9BQU9DO01BQVA7TUFFQU0sT0FBQUEsQ0FBQ0EscUNBQURBLENBQXVDMEIsTUFBQUEsQ0FBQUE7SUFiekMxQixDQUFBQSxHQUFBQTs7QUFnQkEyQixJQUFBQSxvQkFBQUEsZ0JBQVNaLENBQVRZO0FBQUFBLE1BQUFBOztNQUFBQTs7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxjQUFnQkMsS0FBTUMsZUFBQUEsQ0FBWWQsQ0FBbEIsRUFBcUJlLGNBQXJCLEVBQWdDLFFBQTFCRDtBQUN0QkY7O0FBRUFBO0FBQ0FBLFVBQVkxRCxPQUFRQyxPQUFBQSxDQUFPSSxvQkFBZixFQUFnQ3FELHdCQUF4QnpEO0FBQ3BCeUQ7QUFDQUEsVUFBWTFELE9BQVFDLE9BQUFBLENBQU9JLG9CQUFmLEVBQWdDcUQsaUJBQXhCekQ7QUFDcEJ5RDtBQUNBQTs7QUFFQUE7QUFDQUEsYUFBZTNELFVBQU1zQyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFvQnFCO0FBQ3pDQTtBQUNBQTs7QUFFQUEsWUFBYzNELFVBQU8yRCxnQkFBa0JwRCxRQUFLb0Q7QUFDNUNBO0FBQ0FBOztBQUVBQTtBQUNBQSxpQkFBeUJJLFdBQUx6RSxJQUFBMEMsTUFBQUEsQ0FBQUEsQ0FBSytCLEVBQUVoQixDQUFGZ0IsQ0FBSUMsTUFBQUEsQ0FBQUEsQ0FBTUw7QUFDbkNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDBFQUE0RU0sSUFBQWxELFlBQUFrRCxZQUFpQk47QUFDN0ZBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUksS0FBTzlDLGdCQUFQO1FBQ0UsSUFBRyxDQUFBLENBQUMsQ0FBQSxRQUFBYixVQUFNa0UsVUFBQUEsQ0FBT1osYUFBUFksQ0FBTixDQUFBLElBQUEsQ0FBQSxRQUF5QmxFLFVBQU1LLFNBQUFBLENBQUFBLENBQS9CLENBQUEsQ0FBQSxDQUFELElBQUEsQ0FDQyxDQUFBLFFBQUFFLFFBQUkyRCxVQUFBQSxDQUFPWixhQUFQWSxDQUFKLENBQUEsSUFBQSxDQUFBLFFBQXVCM0QsUUFBSUYsU0FBQUEsQ0FBQUEsQ0FBM0IsQ0FBQSxDQUFBLENBREQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxLQUVFLENBQUEsUUFBQWUsQ0FBQUEsWUFBQXBCLFVBQU1LLFNBQUFBLENBQUFBLENBQU5lLENBQUEsQ0FBQSxHQUFBLENBQWViLFFBQUlGLFNBQUFBLENBQUFBLENBQW5CLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FGRixDQUFBLENBQUEsQ0FBSDtVQUlFLE9BQU84RCxJQUFBQyxpQkFBQUQsdUJBQWdDRSxLQUFBQSxDQUFLL0UsSUFBckMsRUFBMkN5RCxDQUEzQyxFQUE4QyxNQUFkc0I7UUFKekM7VUFNRSxPQUFPeEMsTUFBQXZDLElBQUF1QyxZQUFBQSxFQUFBQSxDQUFTLE1BQVQsRUFBZ0JrQixDQUFoQmxCLENBQUFBLEVBQUF5QyxhQUFBQTs7QUFFZkM7QUFDQUE7QUFDQUEsVUFKZUQsQ0FBQUEsR0FBQXpDO1FBTlQ7TUFERjtNQWdCQzhCO01BRUQsSUFBQSxRQUFJQSw4Q0FBSixDQUFBOztRQUNFYSxJQUFJOUM7UUFDSitDLFlBQUFBLE1BQUFBLElBQUFBLDRCQUFBQSxFQUFBQSxPQUFBQSxNQUFBbkYsSUFBQW1GLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFILGFBQUFBLEVBQUFDO0FBQUFBO0FBQUFBO0FBQUFBOzs7VUFDRWxDLFVBQWlCcUMsU0FBUDFFLFVBQU8wRSxFQUFJQyxVQUFGSCxDQUFFRyxFQUFFNUIsQ0FBRjRCLENBQUpEO1VBQ2pCLElBQUEsUUFBR2xFLFNBQUgsQ0FBQTtZQUNFLElBQUEsUUFBaUJvRSxPQUFSdkMsT0FBUXVDLEVBQUdyRSxRQUFIcUUsQ0FBakIsQ0FBQTtjQUFBLFFBQUEsUUFBQTtZQUFBO1VBREYsT0FFQSxJQUFBLFFBQWMxQixPQUFSYixPQUFRYSxFQUFFM0MsUUFBRjJDLENBQWQsQ0FBQTtZQUNFLFFBQUEsUUFBQTtVQURGO1VBR0Esb0JBQU1iLE9BQU47VUFDQWtDLE9BQUFDLENBQUFBLElBQUVFLFNBQUZGLENBQUVFLEVBQUd6QyxDQUFIeUMsQ0FBRkYsRUFSRkYsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFHLENBQUFBO1VBQUFBO1VBQUFBO1FBQUFBLENBQUFBO01BRkY7OztBQWNKZCxZQUFjM0QsVUFBTzJELGdCQUFrQnBELFFBQUtvRDtBQUM1Q0EsVUFBWTFELE9BQVFDLE9BQUFBLENBQU9lLGdCQUFmLEVBQTRCMEMsNkNBQXBCekQ7QUFDcEJ5RDtBQUNBQTtRQUNNa0IsTUFBQXZGLElBQUF1RixtQkFBQUEsRUFBQUEsRUFBQUEsRUFBQVAsYUFBb0I1RCxLQUFELEVBQVFvRSxHQUEzQlI7O1VBQW9CO1VBQU87VUFDekIsSUFBQSxNQUFnQlEsR0FBSUMsTUFBQUEsQ0FBRWhDLENBQUZnQyxDQUFwQixFQUEyQnJELENBQTNCLENBQUE7WUFBQSxPQUFBLG9CQUFNaEIsS0FBTixDQUFBO1VBQUE7WUE1UFI2RCxPQUFBO1VBNFBRLEVBREZELENBQUFBLEdBQUFPO01BbEJGO01Bc0JBbEIsT0FBQXJFO0lBN0ZGcUUsQ0FBQUEsSUFBQUE7O0FBZ0dBb0IsSUFBQUEsaUJBQUFBLDJCQUFNaEMsQ0FBTmdDO0FBQUFBLE1BQUFBOztNQUNFLElBQUcsQ0FBQSxRQUFBL0UsVUFBTWtFLFVBQUFBLENBQU9aLGFBQVBZLENBQU4sQ0FBQSxJQUFBLENBQUEsUUFBeUIzRCxRQUFJMkQsVUFBQUEsQ0FBT1osYUFBUFksQ0FBN0IsQ0FBQSxDQUFBLENBQUg7UUFDRWEsT0FBQVosSUFBQUMsaUJBQUFELHVCQUFnQ0UsS0FBQUEsQ0FBSy9FLElBQXJDLEVBQTJDeUQsQ0FBM0MsRUFBOEMsR0FBZHNCO01BRGxDO1FBR0VVLE9BQUF6RixJQUFBcUUsTUFBQUEsQ0FBS1osQ0FBTFk7TUFIRjtJQURGb0IsQ0FBQUEsR0FBQUE7O0FBUUFDLElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRSxLQUFpQ25FLGVBQWpDO1FBQUEsT0FBT3ZCLElBQUF1QyxVQUFBQSxDQUFTLFNBQVRBO01BQVA7TUFFQSxJQUFBLFFBQUltRCxxRUFBSixDQUFBO1FBQ0UvRSxPQUFRQyxPQUFBQSxDQUFPK0UsMEJBQWYsRUFBc0NELGtDQUE5QjlFO01BRFY7TUFJQSxLQUFBLFFBQVE4RSw4Q0FBUixDQUFBO1FBQ0UvRSxPQUFRQyxPQUFBQSxDQUFPZSxnQkFBZixFQUE2QitELDZCQUFELEdBQUEsQ0FBOEJoRixVQUFNdUMsT0FBQUEsQ0FBQUEsQ0FBcEMsQ0FBcEJyQztNQURWO01BSUE4RSxPQUFJQSxNQUFKMUYsSUFBQTBCLE1BQUFBLENBQUFBLENBQUlnRSxXQUFBQSxFQUFBQSxFQUFBQSxFQUFVN0MsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBVDRDO0lBWE5BLENBQUFBLEdBQUFBOztBQWNBRSxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLEVBQUEsR0FBQSxDQUFHLENBQUEsUUFBQTlELENBQUFBLFlBQUFwQixVQUFBb0IsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBVThELEVBQVYsQ0FBQSxDQUFILENBQUEsR0FBQSxDQUFrQixDQUFBLFFBQUExRSxTQUFBLENBQUEsR0FBQSxDQUFRMEUsS0FBUixJQUFBLENBQWdCQSxJQUFoQixDQUFBLENBQWxCLENBQUEsR0FBQSxDQUF5QyxDQUFBLFFBQUE5RCxDQUFBQSxZQUFBYixRQUFBYSxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFROEQsRUFBUixDQUFBLENBQXpDO0lBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLEVBQUEsR0FBQSxDQUFHLENBQUEsUUFBQS9ELENBQUFBLFlBQUFwQixVQUFBb0IsQ0FBQSxDQUFBLEdBQUEsQ0FBVXBCLFVBQU1tRixTQUFBQSxDQUFBQSxDQUFoQixJQUFBLENBQUEsU0FBQSxDQUFBLENBQUgsQ0FBQSxHQUFBLENBQThCLENBQUEsUUFBQTNFLFNBQUEsQ0FBQSxHQUFBLENBQVEyRSxLQUFSLElBQUEsQ0FBZ0JBLElBQWhCLENBQUEsQ0FBOUIsQ0FBQSxHQUFBLENBQXFELENBQUEsUUFBQS9ELENBQUFBLFlBQUFiLFFBQUFhLENBQUEsQ0FBQSxHQUFBLENBQVFiLFFBQUk0RSxTQUFBQSxDQUFBQSxDQUFaLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBckQ7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLDRCQUFBQSx3QkFBaUJDLElBQWpCRDtBQUFBQSxNQUFBQTs7O01BQ0VwRixhQUFTcUYsSUFBSUMsT0FBQUEsQ0FBQyxPQUFEQTtNQUNiL0UsV0FBTzhFLElBQUlDLE9BQUFBLENBQUMsS0FBREE7TUFDWEYsT0FBQTVFLENBQUFBLFlBQVE2RSxJQUFJQyxPQUFBQSxDQUFDLE1BQURBLENBQVo5RTtJQUhGNEUsQ0FBQUEsR0FBQUE7O0FBTUFHLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQ3ZGLFVBQUQsRUFBU08sUUFBVCxFQUFlQyxTQUFmLENBQXFCK0UsTUFBQUEsQ0FBQUE7SUFEdkJBLENBQUFBLEdBQUFBO0lBSUEsYUFBTSxJQUFOLEVBQVMsTUFBVDtJQUNBLGFBQU0sVUFBTixFQUFlLFFBQWY7SUFDQS9GLE9BQUEsYUFBTSxTQUFOLEVBQWMsUUFBZDtFQTFTRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTgwOTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jvb2xlYW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyB1c2Vfc3RyaWN0OiB0cnVlXG5cbmNsYXNzIDo6Qm9vbGVhbiA8IGBCb29sZWFuYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2Jvb2xlYW4nLCB0cnVlKWBcblxuICAleHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFsnJCRjbGFzcycsICckJG1ldGEnXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsIHByb3BlcnRpZXNbaV0sIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IE9wYWwuVHJ1ZUNsYXNzIDpcbiAgICAgICAgICAgICAgICAgdGhpcyA9PSBmYWxzZSA/IE9wYWwuRmFsc2VDbGFzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGFsLkJvb2xlYW47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCBcIiQkaWRcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IDIgOlxuICAgICAgICAgICAgICAgdGhpcyA9PSBmYWxzZSA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgYHNlbGYgIT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKSA6IGZhbHNlYFxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyB0cnVlIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyID09PSBmYWxzZSB8fCBvdGhlciA9PT0gbmlsKSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPT09IG90aGVyLnZhbHVlT2YoKWBcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBzZWxmLiQkbWV0YWBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzIyMzBcbiAgI1xuICAjIFRoaXMgaXMgYSBoYWNrIHRoYXQgYWxsb3dzIHlvdSB0byBhZGQgbWV0aG9kcyB0byBUcnVlQ2xhc3MgYW5kIEZhbHNlQ2xhc3MuXG4gICMgRG8gbm90ZSwgdGhhdCB3aGlsZSB0cnVlIGFuZCBmYWxzZSBoYXZlIGEgY29ycmVjdCAkJGNsYXNzIChpdCdzIGVpdGhlclxuICAjIFRydWVDbGFzcyBvciBGYWxzZUNsYXNzKSwgdGhlaXIgcHJvdG90eXBlIGlzIGBCb29sZWFuLiQkcHJvdG90eXBlYCwgd2hpY2hcbiAgIyBiYXNpY2FsbHkgbWVhbnMgdGhhdCB3aGVuIGNhbGxpbmcgYHRydWUuc29tZXRoaW5nYCB3ZSBhY3R1YWxseSBjYWxsXG4gICMgYEJvb2xlYW4jc29tZXRoaW5nYCBpbnN0ZWFkIG9mIGBUcnVlQ2xhc3Mjc29tZXRoaW5nYC4gU28gdXNpbmdcbiAgIyBtZXRob2RfbWlzc2luZyB3ZSBkaXNwYXRjaCBpdCB0byBgVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3Mjc29tZXRoaW5nYCBjb3JyZWN0bHkuXG4gICNcbiAgIyBUaGUgZG93bnNpZGUgaXMgdGhhdCBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gd291bGQgYWxzbyBhbGxvdyB1cyB0byBvdmVycmlkZVxuICAjIHRoZSBtZXRob2RzIGRlZmluZWQgb24gQm9vbGVhbiwgYnV0IG91ciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IGFsbG93IHRoYXQsXG4gICMgdW5sZXNzIHlvdSBkZWZpbmUgdGhlbSBvbiBCb29sZWFuIGFuZCBub3Qgb24gVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3MuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlWyckJyArICN7bWV0aG9kfV1gXG4gICAgc3VwZXIgdW5sZXNzIGB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWJvZHkuJCRzdHViYFxuICAgIGBPcGFsLnNlbmQoc2VsZiwgYm9keSwgI3thcmdzfSwgI3tibG9ja30pYFxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2QsIF9pbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGB2YXIgYm9keSA9IHNlbGYuJCRjbGFzcy4kJHByb3RvdHlwZVsnJCcgKyAje21ldGhvZH1dYFxuICAgIGB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWJvZHkuJCRzdHViYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuZW5kXG5cbmNsYXNzIDo6VHJ1ZUNsYXNzIDwgOjpCb29sZWFuOyBlbmRcbmNsYXNzIDo6RmFsc2VDbGFzcyA8IDo6Qm9vbGVhbjsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCb29sZWFuPiIsImFsbG9jYXRlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJzZWxmIiwibmFtZSIsIl9faWRfXyIsIiEiLCImIiwib3RoZXIiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsIm1ldGhvZF9taXNzaW5nIiwibWV0aG9kIiwiYXJncyIsImJsb2NrIiwicmVzcG9uZF90b19taXNzaW5nPyIsIl9pbmNsdWRlX2FsbCIsIjxjbGFzczpUcnVlQ2xhc3M+IiwiQm9vbGVhbiIsIjxjbGFzczpGYWxzZUNsYXNzPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNHQTs7QUFHSEE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFOzs7O0FBQ0VDLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCSCwwQkFBRCxHQUFBLENBQTJCSSxJQUFBQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFwQkg7TUFEVkYsQ0FBQUEsR0FBQUE7OztNQUlBLHNCQUFNLEtBQU47TUFwQ0osT0FBQTtJQStCRSw0QkFBU0ksSUFBVDs7QUFRQUUsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esc0JBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxpQkFBQUEsMEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxZQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLHNCQUFNQyxLQUFORDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsMkRBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxpQkFBQUEsc0JBQU1ELEtBQU5DO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSwwREFBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGlCQUFBQSxzQkFBTUYsS0FBTkU7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLHdGQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsa0JBQUFBLDJCQUFPSCxLQUFQRztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esa0NBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsaUNBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxtQkFBQUEsWUFBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkEzRUZDLE9BMkVFRDtBQUFBQSxNQUFBQTs7O01BM0VGOztNQTJFWSxrQ0FBQSw2QkFBUTtNQUNoQkEsT0FBQVo7SUFERlksQ0FBQUEsSUFBQUE7O0FBZ0JBRSxJQUFBQSw4QkFBQUEsMEJBQW1CQyxNQUFELEVBM0ZwQixFQTJGRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUEzRkY7TUEyRjZCO01BQ3hCQSwwQ0FBNENDLE1BQU9EO01BQ3BELEtBQUEsUUFBY0EsMkNBQWQsQ0FBQTtRQUFBLE9BQUFkLElBQUEsRUFBQSxrRUFBQSxrQkFBQSxFQUFBLENBQUFlLE1BQUEsQ0FBQSxRQUFBLE1BQUFDLElBQUEsQ0FBQSxDQUFBLEVBQUEsS0FBQTtNQUFBO01BQ0FGLE9BQUNBLHNCQUF3QkUsSUFBS0YsRUFBSUcsS0FBTUg7SUFIMUNBLENBQUFBLElBQUFBOztBQU1BSSxJQUFBQSxtQ0FBQUEsNENBQXdCSCxNQUFELEVBQVNJLFlBQWhDRDtBQUFBQSxNQUFBQTs7O01BQWdDLHlDQUFlO01BQzVDQSwwQ0FBNENILE1BQU9HO01BQ3BEQSxPQUFDQSwyQ0FBREE7SUFGRkEsQ0FBQUEsSUFBQUE7SUFLQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsSUFBYjtJQUNBLGFBQU0sU0FBTixFQUFjLE1BQWQ7SUFDQXZCLE9BQUEsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0VBdkdGQSxHQUFNLElBQU5BLEVBQW1CRCxPQUFuQkM7RUEwR0F5QixPQUFNLElBQU5BLEVBQW9CQyxjQUFwQkQ7RUFDQTFCLE9BQUE0QixRQUFNLElBQU5BLEVBQXFCRCxjQUFyQkM7QUE3R0E1QjsifX0seyJvZmZzZXQiOnsibGluZSI6MTgyNDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL25pbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6Ok5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGBvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciA9PT0gbmlsYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJ25pbCdcbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcbiAgICA6Ok5pbENsYXNzXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHRvX2hcbiAgICBgT3BhbC5oYXNoKClgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgMFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICcnXG4gIGVuZFxuXG4gIGRlZiB0b19jXG4gICAgOjpDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yIGlmIGFyZ3MubGVuZ3RoID4gMVxuICAgIDo6S2VybmVsLlJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoMCwgMSlcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIFtdXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpOaWxDbGFzcz4iLCJzZWxmIiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCIhIiwiJiIsInwiLCJvdGhlciIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsImluc3BlY3QiLCJuaWw/Iiwic2luZ2xldG9uX2NsYXNzIiwiTmlsQ2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJDb21wbGV4IiwibmV3IiwicmF0aW9uYWxpemUiLCI+IiwiYXJncyIsImxlbmd0aCIsIjEiLCJBcmd1bWVudEVycm9yIiwiUmF0aW9uYWwiLCJ0b19yIiwiaW5zdGFuY2VfdmFyaWFibGVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDR0EsMEJBQTRCQztJQUU3Qjs7OztBQUNFQyxNQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE2QkgsMEJBQUQsR0FBQSxDQUEyQkQsSUFBQUssTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBcEJGO01BRFZGLENBQUFBLEdBQUFBOzs7TUFJQSxzQkFBTSxLQUFOO01BUkosT0FBQTtJQUdFLDRCQUFTRCxJQUFUOztBQVFBTSxJQUFBQSxpQkFBQUEsWUFDRSxJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLFlBQ0UsS0FERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGlCQUFBQSx1QkFBTUMsS0FBTkQ7QUFBQUE7TUFDRUEsT0FBQ0EsZ0NBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxpQkFBQUEsdUJBQU1ELEtBQU5DO0FBQUFBO01BQ0VBLE9BQUNBLGdDQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsa0JBQUFBLDRCQUFPRixLQUFQRTtBQUFBQTtNQUNFQSxPQUFDQSxhQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsbUJBQUFBLFlBQ0UsR0FERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkFuQ0ZDLE9BbUNFRDtBQUFBQSxNQUFBQTs7O01BbkNGOztNQW1DWSxrQ0FBQSw2QkFBUTtNQUNoQkEsT0FBQTtJQURGQSxDQUFBQSxJQUFBQTs7QUFJQUUsSUFBQUEsdUJBQUFBLFlBQ0VoQixLQURGZ0IsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxZQUNFLElBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBO01BQ0VBLE9BQUFDO0lBREZELENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBO01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQ0EsV0FBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxZQUNFQyxDQURGRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsb0JBQUFBLFlBQ0V4QixFQURGd0IsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQUMsY0FBU0MsS0FBQUEsQ0FBS0osQ0FBZCxFQUFpQkEsQ0FBUkk7SUFEWEYsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLDJCQUFBQSx1QkF2RUYsRUF1RUVBO0FBQUFBLE1BQUFBOzs7TUF2RUY7TUF1RWtCO01BQ2QsSUFBQSxRQUE4Q0MsT0FBWkMsSUFBSUMsUUFBQUEsQ0FBQUEsQ0FBUUYsRUFBRUcsQ0FBRkgsQ0FBOUMsQ0FBQTtRQUFBMUIsT0FBUUMsT0FBQUEsQ0FBTzZCLG9CQUFQN0I7TUFBUjtNQUNBd0IsT0FBQXpCLE9BQVErQixVQUFBQSxDQUFVWCxDQUFsQixFQUFxQlMsQ0FBYkU7SUFGVk4sQ0FBQUEsSUFBQUE7O0FBS0FPLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQWhDLE9BQVErQixVQUFBQSxDQUFVWCxDQUFsQixFQUFxQlMsQ0FBYkU7SUFEVkMsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGtDQUFBQSw4QkFBQUE7QUFBQUE7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxHQUFBQTtJQUlBcEMsT0FBQSxhQUFNLE1BQU4sRUFBVyxNQUFYO0VBcEZGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODM1MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZXJyb3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpFeGNlcHRpb24gPCBgRXJyb3JgXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfZXhjZXB0aW9uJywgdHJ1ZSlgXG4gIGB2YXIgc3RhY2tfdHJhY2VfbGltaXRgXG5cbiAgYEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDEwMGBcblxuICBkZWYgc2VsZi5uZXcoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgbWVzc2FnZSAgID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsO1xuICAgICAgdmFyIGVycm9yICAgICA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3IobWVzc2FnZSk7XG4gICAgICBlcnJvci5uYW1lICAgID0gc2VsZi4kJG5hbWU7XG4gICAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIGVycm9yLmNhdXNlICAgPSAjeyQhfTtcbiAgICAgIE9wYWwuc2VuZChlcnJvciwgZXJyb3IuJGluaXRpYWxpemUsIGFyZ3MpO1xuXG4gICAgICAvLyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSgpIHdpbGwgdXNlIC5uYW1lIGFuZCAudG9TdHJpbmcgdG8gYnVpbGQgdGhlXG4gICAgICAvLyBmaXJzdCBsaW5lIG9mIHRoZSBzdGFjayB0cmFjZSBzbyBpdCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY2LngvZG9jcy9hcGkvZXJyb3JzLmh0bWxcbiAgICAgIGlmIChPcGFsLmNvbmZpZy5lbmFibGVfc3RhY2tfdHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgLy8gUGFzc2luZyBLZXJuZWwucmFpc2Ugd2lsbCBjdXQgdGhlIHN0YWNrIHRyYWNlIGZyb20gdGhhdCBwb2ludCBhYm92ZVxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgc3RhY2tfdHJhY2VfbGltaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICBlbmRcbiAgYHN0YWNrX3RyYWNlX2xpbWl0ID0gc2VsZi4kbmV3YFxuXG4gIGRlZiBzZWxmLmV4Y2VwdGlvbigqYXJncylcbiAgICBuZXcoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XG4gICAgYHNlbGYubWVzc2FnZSA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbGBcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gQ29udmVydCBiYWNrdHJhY2UgZnJvbSBhbnkgZm9ybWF0IHRvIFJ1YnkgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlKSB7XG4gICAgICB2YXIgbmV3X2J0ID0gW10sIG07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFja3RyYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBiYWNrdHJhY2VbaV07XG4gICAgICAgIGlmICghbG9jIHx8ICFsb2MuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAvKiBEbyBub3RoaW5nICovXG4gICAgICAgIH1cbiAgICAgICAgLyogQ2hyb21pdW0gZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pIFxcKCguKj8pXFwpJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyBcIjppbiBgXCIgKyBtWzFdICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0gKyBcIjppbiBgdW5kZWZpbmVkJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBOb2RlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgZnJvbSAoLio/KSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBNb3ppbGxhL0FwcGxlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiguKj8pQCguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyAnOmluIGAnICsgbVsxXSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3X2J0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpICE9PSAndW5kZWZpbmVkJyAmJiBiYWNrdHJhY2UuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5iYWNrdHJhY2UgPSBjb3JyZWN0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICBlbmRcblxuICBkZWYgYmFja3RyYWNlX2xvY2F0aW9uc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucykgcmV0dXJuIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucztcbiAgICAgIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucyA9ICN7YmFja3RyYWNlJi5tYXAgZG8gfGxvY3xcbiAgICAgICAgOjpUaHJlYWQ6OkJhY2t0cmFjZTo6TG9jYXRpb24ubmV3KGxvYylcbiAgICAgIGVuZH1cbiAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnM7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2F1c2VcbiAgICBgc2VsZi5jYXVzZSB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiBleGNlcHRpb24oc3RyID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHN0ciA9PT0gbmlsIHx8IHNlbGYgPT09IHN0cikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsb25lZCA9ICN7Y2xvbmV9O1xuICAgICAgY2xvbmVkLm1lc3NhZ2UgPSBzdHI7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2UpIGNsb25lZC5iYWNrdHJhY2UgPSBzZWxmLmJhY2t0cmFjZS4kZHVwKCk7XG4gICAgICBjbG9uZWQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgY2xvbmVkLmNhdXNlID0gc2VsZi5jYXVzZTtcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICBlbmRcblxuICAjIG5vdCB1c2luZyBhbGlhcyBtZXNzYWdlIHRvX3MgYmVjYXVzZSB5b3UgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJyaWRlIHRvX3MgYW5kIGhhdmUgbWVzc2FnZSB1c2Ugb3ZlcnJpZGRlbiBtZXRob2QsIHdvbid0IHdvcmsgd2l0aCBhbGlhc1xuICBkZWYgbWVzc2FnZVxuICAgIHRvX3NcbiAgZW5kXG5cbiAgZGVmIGZ1bGxfbWVzc2FnZShrd2FyZ3MgPSBuaWwpXG4gICAgdW5sZXNzIGRlZmluZWQ/IEhhc2hcbiAgICAgICMgV2UgYXJlIGRlYWxpbmcgd2l0aCBhbiB1bmZ1bGx5IGxvYWRlZCBPcGFsIGxpYnJhcnksIHNvIHdlIHNob3VsZFxuICAgICAgIyBkbyB3aXRoIGFzIGxpdHRsZSBhcyB3ZSBjYW4uXG5cbiAgICAgIHJldHVybiBcIiN7QG1lc3NhZ2V9XFxuI3tgc2VsZi5zdGFja2B9XCJcbiAgICBlbmRcblxuICAgIGt3YXJncyA9IHsgaGlnaGxpZ2h0OiAkc3RkZXJyLnR0eT8sIG9yZGVyOiA6dG9wIH0ubWVyZ2Uoa3dhcmdzIHx8IHt9KVxuICAgIGhpZ2hsaWdodCwgb3JkZXIgPSBrd2FyZ3NbOmhpZ2hsaWdodF0sIGt3YXJnc1s6b3JkZXJdXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiZXhwZWN0ZWQgdHJ1ZSBvciBmYWxzZSBhcyBoaWdobGlnaHQ6ICN7aGlnaGxpZ2h0fVwiIHVubGVzcyBbdHJ1ZSwgZmFsc2VdLmluY2x1ZGU/IGhpZ2hsaWdodFxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCA6dG9wIG9yIDpib3R0b20gYXMgb3JkZXI6ICN7b3JkZXJ9XCIgdW5sZXNzICVpW3RvcCBib3R0b21dLmluY2x1ZGU/IG9yZGVyXG5cbiAgICBpZiBoaWdobGlnaHRcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gXCJcXGVbMTs0bVwiXG4gICAgICBib2xkID0gXCJcXGVbMW1cIlxuICAgICAgcmVzZXQgPSBcIlxcZVttXCJcbiAgICBlbHNlXG4gICAgICBib2xkX3VuZGVybGluZSA9IGJvbGQgPSByZXNldCA9ICcnXG4gICAgZW5kXG5cbiAgICBidCA9IGJhY2t0cmFjZS5kdXBcbiAgICBidCA9IGNhbGxlciBpZiAhYnQgfHwgYnQuZW1wdHk/XG4gICAgZmlyc3QgPSBidC5zaGlmdFxuXG4gICAgbXNnID0gXCIje2ZpcnN0fTogXCJcbiAgICBtc2cgKz0gXCIje2JvbGR9I3t0b19zfSAoI3tib2xkX3VuZGVybGluZX0je3NlbGYuY2xhc3N9I3tyZXNldH0je2JvbGR9KSN7cmVzZXR9XFxuXCJcblxuICAgIG1zZyArPSBidC5tYXAgeyB8bG9jfCBcIlxcdGZyb20gI3tsb2N9XFxuXCIgfS5qb2luXG5cbiAgICBtc2cgKz0gY2F1c2UuZnVsbF9tZXNzYWdlKGhpZ2hsaWdodDogaGlnaGxpZ2h0KSBpZiBjYXVzZVxuXG4gICAgaWYgb3JkZXIgPT0gOmJvdHRvbVxuICAgICAgbXNnID0gbXNnLnNwbGl0KFwiXFxuXCIpLnJldmVyc2Uuam9pbihcIlxcblwiKVxuICAgICAgbXNnID0gXCIje2JvbGR9VHJhY2ViYWNrI3tyZXNldH0gKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6XFxuXCIgKyBtc2dcbiAgICBlbmRcblxuICAgIG1zZ1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGFzX3N0ciA9IHRvX3NcbiAgICBhc19zdHIuZW1wdHk/ID8gc2VsZi5jbGFzcy50b19zIDogXCIjPCN7c2VsZi5jbGFzcy50b19zfTogI3t0b19zfT5cIlxuICBlbmRcblxuICBkZWYgc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsaWQgPSB0cnVlLCBpLCBpaTtcblxuICAgICAgaWYgKGJhY2t0cmFjZSA9PT0gbmlsKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gbmlsO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGJhY2t0cmFjZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IFtiYWNrdHJhY2VdO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyAgZnJvbSAnICsgYmFja3RyYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJhY2t0cmFjZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBiYWNrdHJhY2UubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFiYWNrdHJhY2VbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9ICN7YGJhY2t0cmFjZWAubWFwIHsgfGl8ICcgIGZyb20gJyArIGkgfX0uam9pbihcIlxcblwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyA6OlNjcmlwdEVycm9yICAgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTeW50YXhFcnJvciAgICAgICAgIDwgOjpTY3JpcHRFcnJvcjsgZW5kXG5jbGFzcyA6OkxvYWRFcnJvciAgICAgICAgICAgPCA6OlNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIDo6Tm90SW1wbGVtZW50ZWRFcnJvciA8IDo6U2NyaXB0RXJyb3I7IGVuZFxuXG5jbGFzcyA6OlN5c3RlbUV4aXQgICAgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpOb01lbW9yeUVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6U2lnbmFsRXhjZXB0aW9uICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OkludGVycnVwdCAgICAgICAgICAgPCA6OlNpZ25hbEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlNlY3VyaXR5RXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTeXN0ZW1TdGFja0Vycm9yICA8IDo6RXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgOjpTdGFuZGFyZEVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6RW5jb2RpbmdFcnJvciAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6Olplcm9EaXZpc2lvbkVycm9yICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpOYW1lRXJyb3IgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6Tm9NZXRob2RFcnJvciAgICAgICAgIDwgOjpOYW1lRXJyb3I7IGVuZFxuY2xhc3MgOjpSdW50aW1lRXJyb3IgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RnJvemVuRXJyb3IgICAgICAgICAgIDwgOjpSdW50aW1lRXJyb3I7IGVuZFxuY2xhc3MgOjpMb2NhbEp1bXBFcnJvciAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6VHlwZUVycm9yICAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkFyZ3VtZW50RXJyb3IgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpVbmNhdWdodFRocm93RXJyb3IgICAgPCA6OkFyZ3VtZW50RXJyb3I7IGVuZFxuY2xhc3MgOjpJbmRleEVycm9yICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6U3RvcEl0ZXJhdGlvbiAgICAgICAgIDwgOjpJbmRleEVycm9yOyBlbmRcbmNsYXNzIDo6Q2xvc2VkUXVldWVFcnJvciAgICAgICAgPCA6OlN0b3BJdGVyYXRpb247IGVuZFxuY2xhc3MgOjpLZXlFcnJvciAgICAgICAgICAgICAgPCA6OkluZGV4RXJyb3I7IGVuZFxuY2xhc3MgOjpSYW5nZUVycm9yICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RmxvYXREb21haW5FcnJvciAgICAgIDwgOjpSYW5nZUVycm9yOyBlbmRcbmNsYXNzIDo6SU9FcnJvciAgICAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkVPRkVycm9yICAgICAgICAgICAgICA8IDo6SU9FcnJvcjsgZW5kXG5jbGFzcyA6OlN5c3RlbUNhbGxFcnJvciAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpSZWdleHBFcnJvciAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6VGhyZWFkRXJyb3IgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkZpYmVyRXJyb3IgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuXG46Ok9iamVjdC5hdXRvbG9hZCA6RXJybm8sICdjb3JlbGliL2Vycm9yL2Vycm5vJ1xuXG5jbGFzcyA6OkZyb3plbkVycm9yIDwgOjpSdW50aW1lRXJyb3JcbiAgYXR0cl9yZWFkZXIgOnJlY2VpdmVyXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbClcbiAgICBzdXBlciBtZXNzYWdlXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpVbmNhdWdodFRocm93RXJyb3IgPCA6OkFyZ3VtZW50RXJyb3JcbiAgYXR0cl9yZWFkZXIgOnRhZywgOnZhbHVlXG5cbiAgZGVmIGluaXRpYWxpemUodGFnLCB2YWx1ZSA9IG5pbClcbiAgICBAdGFnID0gdGFnXG4gICAgQHZhbHVlID0gdmFsdWVcblxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAdGFnLmluc3BlY3R9XCIpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6TmFtZUVycm9yXG4gIGF0dHJfcmVhZGVyIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbClcbiAgICBzdXBlciBtZXNzYWdlXG4gICAgQG5hbWUgPSBuYW1lXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6Tm9NZXRob2RFcnJvclxuICBhdHRyX3JlYWRlciA6YXJnc1xuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwsIGFyZ3MgPSBbXSlcbiAgICBzdXBlciBtZXNzYWdlLCBuYW1lXG4gICAgQGFyZ3MgPSBhcmdzXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6U3RvcEl0ZXJhdGlvblxuICBhdHRyX3JlYWRlciA6cmVzdWx0XG5lbmRcblxuY2xhc3MgOjpLZXlFcnJvclxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCByZWNlaXZlcjogbmlsLCBrZXk6IG5pbClcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQGtleSA9IGtleVxuICBlbmRcblxuICBkZWYgcmVjZWl2ZXJcbiAgICBAcmVjZWl2ZXIgfHwgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgaXMgYXZhaWxhYmxlJylcbiAgZW5kXG5cbiAgZGVmIGtleVxuICAgIEBrZXkgfHwgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAnbm8ga2V5IGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSA6OkpTXG4gIGNsYXNzIEVycm9yXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFeGNlcHRpb24+IiwibmV3Iiwic2VsZiIsIiQhIiwiZXhjZXB0aW9uIiwiYXJncyIsImluaXRpYWxpemUiLCJiYWNrdHJhY2UiLCJiYWNrdHJhY2VfbG9jYXRpb25zIiwiYmxvY2sgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsImxvYyIsImJsb2NrICgyIGxldmVscykgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsIlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbiIsIlRocmVhZDo6QmFja3RyYWNlIiwiVGhyZWFkIiwiY2F1c2UiLCJzdHIiLCJjbG9uZSIsIm1lc3NhZ2UiLCJ0b19zIiwiZnVsbF9tZXNzYWdlIiwia3dhcmdzIiwiQG1lc3NhZ2UiLCIkc3RkZXJyIiwidHR5PyIsIm1lcmdlIiwiJHJldF9vcl8xIiwiW10iLCJoaWdobGlnaHQiLCJvcmRlciIsImluY2x1ZGU/IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYm9sZF91bmRlcmxpbmUiLCJib2xkIiwicmVzZXQiLCJidCIsImR1cCIsImVtcHR5PyIsImNhbGxlciIsImZpcnN0Iiwic2hpZnQiLCJtc2ciLCIrIiwiY2xhc3MiLCJtYXAiLCJibG9jayBpbiBmdWxsX21lc3NhZ2UiLCJibG9jayAoMiBsZXZlbHMpIGluIGZ1bGxfbWVzc2FnZSIsImpvaW4iLCJzcGxpdCIsInJldmVyc2UiLCJpbnNwZWN0IiwiYXNfc3RyIiwic2V0X2JhY2t0cmFjZSIsIlR5cGVFcnJvciIsImJsb2NrIGluIHNldF9iYWNrdHJhY2UiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZXRfYmFja3RyYWNlIiwiJHJldF9vcl8yIiwiPGNsYXNzOlNjcmlwdEVycm9yPiIsIkV4Y2VwdGlvbiIsIjxjbGFzczpTeW50YXhFcnJvcj4iLCJTY3JpcHRFcnJvciIsIjxjbGFzczpMb2FkRXJyb3I+IiwiPGNsYXNzOk5vdEltcGxlbWVudGVkRXJyb3I+IiwiPGNsYXNzOlN5c3RlbUV4aXQ+IiwiPGNsYXNzOk5vTWVtb3J5RXJyb3I+IiwiPGNsYXNzOlNpZ25hbEV4Y2VwdGlvbj4iLCI8Y2xhc3M6SW50ZXJydXB0PiIsIlNpZ25hbEV4Y2VwdGlvbiIsIjxjbGFzczpTZWN1cml0eUVycm9yPiIsIjxjbGFzczpTeXN0ZW1TdGFja0Vycm9yPiIsIjxjbGFzczpTdGFuZGFyZEVycm9yPiIsIjxjbGFzczpFbmNvZGluZ0Vycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6WmVyb0RpdmlzaW9uRXJyb3I+IiwiPGNsYXNzOk5hbWVFcnJvcj4iLCI8Y2xhc3M6Tm9NZXRob2RFcnJvcj4iLCJOYW1lRXJyb3IiLCI8Y2xhc3M6UnVudGltZUVycm9yPiIsIjxjbGFzczpGcm96ZW5FcnJvcj4iLCJSdW50aW1lRXJyb3IiLCI8Y2xhc3M6TG9jYWxKdW1wRXJyb3I+IiwiPGNsYXNzOlR5cGVFcnJvcj4iLCI8Y2xhc3M6QXJndW1lbnRFcnJvcj4iLCI8Y2xhc3M6VW5jYXVnaHRUaHJvd0Vycm9yPiIsIjxjbGFzczpJbmRleEVycm9yPiIsIjxjbGFzczpTdG9wSXRlcmF0aW9uPiIsIkluZGV4RXJyb3IiLCI8Y2xhc3M6Q2xvc2VkUXVldWVFcnJvcj4iLCJTdG9wSXRlcmF0aW9uIiwiPGNsYXNzOktleUVycm9yPiIsIjxjbGFzczpSYW5nZUVycm9yPiIsIjxjbGFzczpGbG9hdERvbWFpbkVycm9yPiIsIlJhbmdlRXJyb3IiLCI8Y2xhc3M6SU9FcnJvcj4iLCI8Y2xhc3M6RU9GRXJyb3I+IiwiSU9FcnJvciIsIjxjbGFzczpTeXN0ZW1DYWxsRXJyb3I+IiwiPGNsYXNzOlJlZ2V4cEVycm9yPiIsIjxjbGFzczpUaHJlYWRFcnJvcj4iLCI8Y2xhc3M6RmliZXJFcnJvcj4iLCJPYmplY3QiLCJhdXRvbG9hZCIsImF0dHJfcmVhZGVyIiwiJGt3YXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwidGFnIiwidmFsdWUiLCJAdGFnIiwiQHZhbHVlIiwibmFtZSIsIkBuYW1lIiwiQGFyZ3MiLCJAa2V5Iiwia2V5IiwiPG1vZHVsZTpKUz4iLCI8Y2xhc3M6RXJyb3I+Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0dBO0lBQ0FBO0lBRUFBO0lBRURDLE1BQUlDLElBQUpELFVBQUFBLDBCQU5GLEVBTUVBO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFORjtNQU1lOztBQUVmQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxzQkFBd0JFLFdBQUdGO0FBQzNCQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBbkJFQSxDQUFBQSxJQUFBQTtJQXFCQ0Q7SUFFREksTUFBSUYsSUFBSkUsZ0JBQUFBLHFCQTdCRixFQTZCRUE7QUFBQUEsTUFBQUE7OztNQTdCRjtNQTZCcUI7TUFDakJBLE9BQUFILE1BQUFDLElBQUFELE9BQUFBLEVBQUks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QUFNLElBQU5BLEVBQUFBLElBQUFBO0VBZ0JBN0YsT0FBQXVIO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsUUFBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBTyxJQUFQQTtBQWxUQXZIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODc3NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZXJyb3IvZXJybm8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6RXJybm9cbiAgZXJyb3JzID0gW1xuICAgIFs6RUlOVkFMLCAnSW52YWxpZCBhcmd1bWVudCcsIDIyXSxcbiAgICBbOkVFWElTVCwgJ0ZpbGUgZXhpc3RzJywgMTddLFxuICAgIFs6RUlTRElSLCAnSXMgYSBkaXJlY3RvcnknLCAyMV0sXG4gICAgWzpFTUZJTEUsICdUb28gbWFueSBvcGVuIGZpbGVzJywgMjRdLFxuICAgIFs6RVNQSVBFLCAnSWxsZWdhbCBzZWVrJywgMjldLFxuICAgIFs6RUFDQ0VTLCAnUGVybWlzc2lvbiBkZW5pZWQnLCAxM10sXG4gICAgWzpFUEVSTSwgJ09wZXJhdGlvbiBub3QgcGVybWl0dGVkJywgMV0sXG4gICAgWzpFTk9FTlQsICdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JywgMl0sXG4gICAgWzpFTkFNRVRPT0xPTkcsICdGaWxlIG5hbWUgdG9vIGxvbmcnLCAzNl1cbiAgXVxuXG4gIGtsYXNzID0gbmlsXG5cbiAgJXh7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKCkgeyAvLyBDcmVhdGUgYSBjbG9zdXJlXG4gICAgICAgIHZhciBjbGFzc19uYW1lID0gZXJyb3JzW2ldWzBdO1xuICAgICAgICB2YXIgZGVmYXVsdF9tZXNzYWdlID0gZXJyb3JzW2ldWzFdO1xuICAgICAgICB2YXIgZXJybm8gPSBlcnJvcnNbaV1bMl07XG5cbiAgICAgICAga2xhc3MgPSBPcGFsLmtsYXNzKHNlbGYsIE9wYWwuU3lzdGVtQ2FsbEVycm9yLCBjbGFzc19uYW1lKTtcbiAgICAgICAga2xhc3MuZXJybm8gPSBlcnJubztcblxuICAgICAgICAje1xuICAgICAgICAgIGNsYXNzIDw8IGtsYXNzXG4gICAgICAgICAgICBkZWYgbmV3KG5hbWUgPSBuaWwpXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBgZGVmYXVsdF9tZXNzYWdlYFxuICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIC0gI3tuYW1lfVwiIGlmIG5hbWVcbiAgICAgICAgICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuZW5kXG5cbmNsYXNzIDo6U3lzdGVtQ2FsbEVycm9yIDwgOjpTdGFuZGFyZEVycm9yXG4gIGRlZiBlcnJub1xuICAgIHNlbGYuY2xhc3MuZXJybm9cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGF0dHJfcmVhZGVyIDplcnJub1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkVycm5vPiIsImVycm9ycyIsIjIyIiwiMTciLCIyMSIsIjI0IiwiMjkiLCIxMyIsIjEiLCIyIiwiMzYiLCJrbGFzcyIsIm5ldyIsIm5hbWUiLCJtZXNzYWdlIiwiKyIsInNlbGYiLCI8Y2xhc3M6U3lzdGVtQ2FsbEVycm9yPiIsImVycm5vIiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsIlN0YW5kYXJkRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsU0FBUyxDQUNQLENBQUMsUUFBRCxFQUFVRCxrQkFBVixFQUE4QkUsRUFBOUIsQ0FETyxFQUVQLENBQUMsUUFBRCxFQUFVRixhQUFWLEVBQXlCRyxFQUF6QixDQUZPLEVBR1AsQ0FBQyxRQUFELEVBQVVILGdCQUFWLEVBQTRCSSxFQUE1QixDQUhPLEVBSVAsQ0FBQyxRQUFELEVBQVVKLHFCQUFWLEVBQWlDSyxFQUFqQyxDQUpPLEVBS1AsQ0FBQyxRQUFELEVBQVVMLGNBQVYsRUFBMEJNLEVBQTFCLENBTE8sRUFNUCxDQUFDLFFBQUQsRUFBVU4sbUJBQVYsRUFBK0JPLEVBQS9CLENBTk8sRUFPUCxDQUFDLE9BQUQsRUFBU1AseUJBQVQsRUFBb0NRLENBQXBDLENBUE8sRUFRUCxDQUFDLFFBQUQsRUFBVVIsMkJBQVYsRUFBdUNTLENBQXZDLENBUk8sRUFTUCxDQUFDLGNBQUQsRUFBZ0JULG9CQUFoQixFQUFzQ1UsRUFBdEMsQ0FUTztJQVlUQyxRQUFROztBQUdWWDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBLFFBQ1U7O01BQ0UsT0FBQVksbUJBQUFBLGdCQUFRQyxJQUFSRDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQVEseUJBQU87UUFDYkUsVUFBV0Y7UUFDWCxJQUFBLFFBQTJCQyxJQUEzQixDQUFBO1VBQUFDLFVBQVFDLFNBQVJELE9BQVFDLEVBQUlILEtBQUQsR0FBQSxDQUFNQyxJQUFOLENBQUhFO1FBQVI7UUFDQUgsT0FBQSxPQUFBSSxJQUFBLEVBQUEsNkNBQUEsT0FBQSxFQUFBLENBQU1GLE9BQU4sQ0FBQSxFQUFBLElBQUE7TUFIRkYsQ0FBQUEsSUFBQUE7SUFERiw0QkFBU0QsS0FBVDtBQVFWWDtBQUNBQTtBQUNBQTtFQXJDQUEsR0FBTyxJQUFQQTtFQXdDQUQsT0FBQWtCO0VBQUFBOztJQUFBQTs7OztBQUNFQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRixJQUFJRyxPQUFBQSxDQUFBQSxDQUFNRCxPQUFBQSxDQUFBQTtJQURaQSxDQUFBQSxHQUFBQTtJQUlBRCxPQUFBOztNQUNFLE9BQUFELElBQUFJLGFBQUFBLENBQVksT0FBWkE7SUFERiw0QkFBU0osSUFBVDtFQUxGQyxHQUFNLElBQU5BLEVBQTBCSSxvQkFBMUJKO0FBeENBbEI7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4ODM5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jbGFzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL21vZHVsZSdcblxuY2xhc3MgOjpDbGFzc1xuICBkZWYgc2VsZi5uZXcoc3VwZXJjbGFzcyA9IE9iamVjdCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzdXBlcmNsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbXVzdCBiZSBhIENsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcyk7XG4gICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgICAgI3tga2xhc3NgLmNsYXNzX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj99XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG4gICAgICBvYmouJCRpZCA9IE9wYWwudWlkKCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlc2NlbmRhbnRzXG4gICAgc3ViY2xhc3NlcyArIHN1YmNsYXNzZXMubWFwKCY6ZGVzY2VuZGFudHMpLmZsYXR0ZW5cbiAgZW5kXG5cbiAgZGVmIGluaGVyaXRlZChjbHMpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvcmlnaW5hbClcbiAgICBpbml0aWFsaXplX2NvcHkob3JpZ2luYWwpXG4gICAgJXh7XG4gICAgICBzZWxmLiQkbmFtZSA9IG51bGw7XG4gICAgICBzZWxmLiQkZnVsbF9uYW1lID0gbnVsbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuZXcoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmplY3QgPSAje2FsbG9jYXRlfTtcbiAgICAgIE9wYWwuc2VuZChvYmplY3QsIG9iamVjdC4kaW5pdGlhbGl6ZSwgYXJncywgYmxvY2spO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdWJjbGFzc2VzXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIFdlYWtSZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpLCBzdWJjbGFzcywgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLiQkc3ViY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YmNsYXNzID0gc2VsZi4kJHN1YmNsYXNzZXNbaV0uZGVyZWYoKTtcbiAgICAgICAgICBpZiAoc3ViY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0LnB1c2goc3ViY2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkc3ViY2xhc3NlcztcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdXBlcmNsYXNzXG4gICAgYHNlbGYuJCRzdXBlciB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uX29mID0gc2VsZi4kJHNpbmdsZXRvbl9vZjtcblxuICAgICAgaWYgKHNpbmdsZXRvbl9vZiAmJiBzaW5nbGV0b25fb2YuJCRpc19hX21vZHVsZSkge1xuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6I3tgc2luZ2xldG9uX29mYC5uYW1lfT5cIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGV0b24gY2xhc3MgY3JlYXRlZCBmcm9tIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tzdXBlcigpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkNsYXNzPiIsIm5ldyIsInN1cGVyY2xhc3MiLCJPYmplY3QiLCJibG9ja19naXZlbj8iLCJjbGFzc19ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiYWxsb2NhdGUiLCJkZXNjZW5kYW50cyIsIisiLCJzdWJjbGFzc2VzIiwibWFwIiwiZmxhdHRlbiIsImluaGVyaXRlZCIsImluaXRpYWxpemVfZHVwIiwib3JpZ2luYWwiLCJpbml0aWFsaXplX2NvcHkiLCJ0b19zIiwibmFtZSIsIjE2Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFQyxNQUFJSCxJQUFKRyxVQUFBQSxzQkFBYUMsVUFBYkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBYSxxQ0FBYUU7O0FBRTVCRjtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsTUFBUSxDQUE4QkcsZUFBOUIsR0FBQSxDQUFPQyxNQUFQSixDQUFDQSxLQUFEQSxDQUFPSSxjQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRixDQUFQLElBQUEsR0FBQTtBQUNSSjtBQUNBQTtJQVZFQSxDQUFBQSxJQUFBQTs7QUFhQU8sSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLEdBQUFBOztBQVFBQyxJQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFXQyxTQUFYWixJQUFBYSxZQUFBQSxDQUFBQSxDQUFXRCxFQUFZRSxNQUFWZCxJQUFBYSxZQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLGFBQURMLFNBQUFBLENBQUFBLENBQUxLLENBQW1CQyxTQUFBQSxDQUFBQSxDQUEvQkg7SUFEYkQsQ0FBQUEsR0FBQUE7O0FBSUFLLElBQUFBLHlCQUFBQSxZQTVCRixHQTRCRUEsQ0FBQUEsR0FBQUE7O0FBR0FDLElBQUFBLDhCQUFBQSwwQkFBbUJDLFFBQW5CRDtBQUFBQSxNQUFBQTs7O01BQ0VqQixJQUFBbUIsaUJBQUFBLENBQWdCRCxRQUFoQkM7O0FBRUpGO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLEdBQUFBOztBQVFBZCxJQUFBQSxtQkFBQUEsc0JBdkNGLEVBdUNFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXZDRjtNQXVDVTs7QUFFVkEsbUJBQXFCSCxJQUFBVSxVQUFBQSxDQUFBQSxDQUFTUDtBQUM5QkE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsSUFBQUE7O0FBUUFVLElBQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQWZFQSxDQUFBQSxHQUFBQTs7QUFrQkFULElBQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLG1CQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQWdCLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOztBQUVGQTs7QUFFQUE7QUFDQUEsZUFBa0JBLFVBQUQsR0FBQSxDQUFXQSxDQUFDQSxZQUFEQSxDQUFjQyxNQUFBQSxDQUFBQSxDQUF6QixDQUFBLEdBQStCRCxHQUFHQTtBQUNuREE7QUFDQUE7QUFDQUE7QUFDQUEsZUFBa0JBLFlBQUQsR0FBQSxDQUFhQSxDQUFDQSxvQkFBREEsQ0FBc0JDLE1BQUFBLENBQUFBLENBQW5DLENBQUEsR0FBeUNELEtBQXpDLEdBQUEsQ0FBOENBLENBQUNBLHFCQUFEQSxDQUF1QkEsTUFBQUEsQ0FBTUUsRUFBTkYsQ0FBckUsQ0FBQSxHQUErRUEsSUFBSUE7QUFDcEdBOztBQUVBQSxhQUFlLE9BQUFwQixJQUFBLEVBQUEsOENBQUEsUUFBQSxFQUFBLEVBQUEsRUFBQSxJQUFBLENBQVFvQjtBQUN2QkE7SUFiRUEsQ0FBQUEsR0FBQUE7SUFnQkFsQixPQUFBLGFBQU0sU0FBTixFQUFjLE1BQWQ7RUFuRkZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4OTYyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgZmFsc3ksIGhhc2hfaWRzLCB5aWVsZDEsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGNvZXJjZV90bywgcmVzcG9uZF90bywgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemVcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyA6OkFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgamF2YXNjcmlwdCBhcnJheXMgYXMgYmVpbmcgdmFsaWQgcnVieSBhcnJheXNcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcnJheScsIHRydWUpYFxuXG4gICV4e1xuICAgIC8vIFJlY2VudCB2ZXJzaW9ucyBvZiBWOCAoPiA3LjEpIG9ubHkgdXNlIGFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyB1bm1vZGlmaWVkLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgXCJhcnJheS1zcGxpY2UudHFcIiBoYXMgYSBcImZhc3QgcGF0aFwiIChFeHRyYWN0RmFzdEpTQXJyYXksIGRlZmluZWQgaW4gXCJzcmMvY29kZWdlbi9jb2RlLXN0dWItYXNzZW1ibGVyLmNjXCIpXG4gICAgLy8gYnV0IGl0J3Mgb25seSBlbmFibGVkIHdoZW4gXCJJc1Byb3RvdHlwZUluaXRpYWxBcnJheVByb3RvdHlwZSgpXCIgaXMgdHJ1ZS5cbiAgICAvL1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIFY4IHdlcmUgdXNpbmcgcmVsYXRpdmVseSBmYXN0IEpTLXdpdGgtZXh0ZW5zaW9ucyBjb2RlIGV2ZW4gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgbW9kaWZpZWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNy4wLjEvc3JjL2pzL2FycmF5LmpzI0w1OTktTDY0MlxuICAgIC8vXG4gICAgLy8gSW4gc2hvcnQsIEFycmF5IG9wZXJhdGlvbnMgYXJlIHNsb3cgaW4gcmVjZW50IHZlcnNpb25zIG9mIFY4IHdoZW4gdGhlIEFycmF5LnByb3RvdHlwZSBoYXMgYmVlbiB0YW1wZXJlZC5cbiAgICAvLyBTbywgd2hlbiBwb3NzaWJsZSwgd2UgYXJlIHVzaW5nIGZhc3RlciBvcGVuLWNvZGVkIHZlcnNpb24gdG8gYm9vc3QgdGhlIHBlcmZvcm1hbmNlLlxuXG4gICAgLy8gQXMgb2YgVjggOC40LCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIGFycmF5LCB0aGlzIGlzIHVwIHRvIH4yNXggdGltZXMgZmFzdGVyIHRoYW4gQXJyYXkjc2hpZnQoKVxuICAgIC8vIEltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2JhNjg0ODA1YjZjMGVkZWQ3NmU1Y2Q4OWVlMDAzMjhhYzdhNTkzNjUvbGliL2ludGVybmFsL3V0aWwuanMjTDM0MS1MMzQ3XG4gICAgZnVuY3Rpb24gc2hpZnROb0FyZyhsaXN0KSB7XG4gICAgICB2YXIgciA9IGxpc3RbMF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGxpc3RbaW5kZXggLSAxXSA9IGxpc3RbaW5kZXhdO1xuICAgICAgfVxuICAgICAgbGlzdC5wb3AoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXlTdWJjbGFzcyhvYmosIGtsYXNzKSB7XG4gICAgICBpZiAoa2xhc3MuJCRuYW1lID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2xhc3MuJGFsbG9jYXRlKCkuJHJlcGxhY2UoI3tgb2JqYC50b19hfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBoZWxwZXIgZm9yIGtlZXBfaWYgYW5kIGRlbGV0ZV9pZiwgZmlsdGVyIGlzIGVpdGhlciBPcGFsLnRydXRoeVxuICAgIC8vIG9yIE9wYWwuZmFsc3kuXG4gICAgZnVuY3Rpb24gZmlsdGVySWYoc2VsZiwgZmlsdGVyLCBibG9jaykge1xuICAgICAgdmFyIHZhbHVlLCByYWlzZWQgPSBudWxsLCB1cGRhdGVkID0gbmV3IEFycmF5KHNlbGYubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGkyID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhaXNlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pXG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgcmFpc2VkID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJhaXNlZCB8fCBmaWx0ZXIodmFsdWUpKSB7XG4gICAgICAgICAgdXBkYXRlZFtpMl0gPSBzZWxmW2ldXG4gICAgICAgICAgaTIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaTIgIT09IGkpIHtcbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgWzAsIHVwZGF0ZWQubGVuZ3RoXS5jb25jYXQodXBkYXRlZCkpO1xuICAgICAgICBzZWxmLnNwbGljZShpMiwgdXBkYXRlZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFpc2VkKSB0aHJvdyByYWlzZWQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYuW10oKm9iamVjdHMpXG4gICAgYHRvQXJyYXlTdWJjbGFzcyhvYmplY3RzLCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc2l6ZSA9IG5pbCwgb2JqID0gbmlsLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAob2JqICE9PSBuaWwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLndhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA+ICN7OjpJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXJyYXkgc2l6ZSB0b28gYmlnJ31cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMilcIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHNpemUuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2EpfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2UgaWYgKCN7c2l6ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2FyeSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2l6ZSA9ICRjb2VyY2VfdG8oc2l6ZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfVxuICAgICAgfVxuXG4gICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICB2YXIgaSwgdmFsdWU7XG5cbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBzZWxmLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIHZhbHVlOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhpKTtcbiAgICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXG4gICAgOjpPcGFsLmNvZXJjZV90bz8gb2JqLCA6OkFycmF5LCA6dG9fYXJ5XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBzZWxmW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2guJGtleXMoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIHJldHVybiBqb2luKG90aGVyLnRvX3N0cikgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90byhvdGhlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICByZXR1cm4gYHNlbGYuc2xpY2UoKWAgaWYgYG90aGVyLmxlbmd0aCA9PT0gMGBcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PChvYmplY3QpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG4gICAgYHNlbGYucHVzaChvYmplY3QpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje2hhc2h9ID09PSAje290aGVyLmhhc2h9KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XG5cbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YHNlbGYubGVuZ3RoYCA8PT4gYG90aGVyLmxlbmd0aGB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKCRyZXNwb25kX3RvKG90aGVyLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgICByZXR1cm4gI3tgb3RoZXJgID09IGBhcnJheWB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycmF5LiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuICAgICAgICBpZiAob3RoZXIuJCRjb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG4gICAgICAgICAgb3RoZXIgPSAje2BvdGhlcmAudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcbiAgICAgIHRvICAgICAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4LmV4Y2xfcmV2ICYmIGluZGV4LmJlZ2luICE9PSBuaWwpIHtcbiAgICAgICAgZnJvbSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA+IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICB0byArPSBzaXplO1xuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFleGNsdWRlIHx8IGluZGV4LmVuZCA9PT0gbmlsKSB7XG4gICAgICAgIHRvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfYXJpdGhtZXRpY19zZXEoc2VsZiwgaW5kZXgpIHtcbiAgICAgIHZhciBhcnJheSwgb3V0ID0gW10sIGkgPSAwLCBwc2V1ZG9yYW5nZTtcblxuICAgICAgaWYgKGluZGV4LnN0ZXAgPCAwKSB7XG4gICAgICAgIHBzZXVkb3JhbmdlID0ge1xuICAgICAgICAgIGJlZ2luOiBpbmRleC5yYW5nZS5lbmQsXG4gICAgICAgICAgZW5kOiBpbmRleC5yYW5nZS5iZWdpbixcbiAgICAgICAgICBleGNsOiBmYWxzZSxcbiAgICAgICAgICBleGNsX3JldjogaW5kZXgucmFuZ2UuZXhjbFxuICAgICAgICB9O1xuICAgICAgICBhcnJheSA9ICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBwc2V1ZG9yYW5nZSkuJHJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcnJheSA9ICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleC5yYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIG91dC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgaSArPSBNYXRoLmFicyhpbmRleC5zdGVwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGluZGV4LiQkaXNfYXJpdGhtZXRpY19zZXEpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9hcml0aG1ldGljX3NlcShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSwgZXh0cmEgPSB1bmRlZmluZWQpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBkYXRhID0gbmlsXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc2l6ZSA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSlcbiAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hfTtcbiAgICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSlcbiAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hcnkudG9fYX07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkYXRhID0gW3ZhbHVlXTtcblxuICAgICAgICB2YXIgZXhjbHVkZSA9IGluZGV4LmV4Y2wsXG4gICAgICAgICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKSxcbiAgICAgICAgICAgIHRvICAgICAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUgfHwgaW5kZXguZW5kID09PSBuaWwpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tsZW5ndGggPSAxfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlICA9IGV4dHJhO1xuXG4gICAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpXG4gICAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hfTtcbiAgICAgICAgICBlbHNlIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnl9KVxuICAgICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYXJ5LnRvX2F9O1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRhdGEgPSBbdmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb2xkYH0gdG9vIHNtYWxsIGZvciBhcnJheTsgbWluaW11bSAje2Atc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm5lZ2F0aXZlIGxlbmd0aCAoI3tsZW5ndGh9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmW2ldID0gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZltpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbaW5kZXgsIGxlbmd0aF0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVtID0gc2VsZltpXSwgaXRlbS5sZW5ndGggJiYgI3tgaXRlbVswXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6YnNlYXJjaF9pbmRleCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSAwLFxuICAgICAgICAgIG1heCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIG1pZCxcbiAgICAgICAgICB2YWwsXG4gICAgICAgICAgcmV0LFxuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZSxcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBuaWw7XG5cbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIDIpO1xuICAgICAgICB2YWwgPSBzZWxmW21pZF07XG4gICAgICAgIHJldCA9ICR5aWVsZDEoYmxvY2ssIHZhbCk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNhdGlzZmllZCA9IG1pZDtcbiAgICAgICAgICBzbWFsbGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gbmlsKSB7XG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJldC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChyZXQgPT09IDApIHsgcmV0dXJuIG1pZDsgfVxuICAgICAgICAgIHNtYWxsZXIgPSAocmV0IDwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YHJldGAuY2xhc3N9IChtdXN0IGJlIG51bWVyaWMsIHRydWUsIGZhbHNlIG9yIG5pbClcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbWFsbGVyKSB7IG1heCA9IG1pZDsgfSBlbHNlIHsgbWluID0gbWlkICsgMTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2F0aXNmaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6YnNlYXJjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBpbmRleCA9IGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxuXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleC4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIDo6RmxvYXQ6OklORklOSVRZXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJldHVybiBpZiBlbXB0eT8gfHwgbiA9PSAwXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuID0gI3s6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBvYmplY3QgIT09IHVuZGVmaW5lZGAgfHwgYmxvY2tcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2l6ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgIHJlcGxhY2Ugb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGJpbm9taWFsX2NvZWZmaWNpZW50KG4sIGspIHtcbiAgICAgIGlmIChuID09PSBrIHx8IGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChrID4gMCAmJiBuID4gaykge1xuICAgICAgICByZXR1cm4gYmlub21pYWxfY29lZmZpY2llbnQobiAtIDEsIGsgLSAxKSArIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgZGVmIGNvbWJpbmF0aW9uKG4pXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IDo6T3BhbC5jb2VyY2VfdG8hIG4sIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpyZXBlYXRlZF9jb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudChzZWxmLmxlbmd0aCArIG51bSAtIDEsIG51bSlgIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShtYXgsIGZyb20sIGJ1ZmZlciwgc2VsZikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xuICAgICAgICAgICN7eWllbGQgYGNvcHlgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcbiAgICAgICAgICBpdGVyYXRlKG1heCwgaSwgYnVmZmVyLCBzZWxmKTtcbiAgICAgICAgICBidWZmZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bSA+PSAwKSB7XG4gICAgICAgIGl0ZXJhdGUobnVtLCAwLCBbXSwgc2VsZik7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChpdGVtID0gc2VsZltpXSkgIT09IG5pbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZltpXSA9PT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uY2F0KCpvdGhlcnMpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCkge1xuICAgICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgICAgcmV0dXJuICN7eWllbGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9hdChpbmRleClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGZbaW5kZXhdO1xuXG4gICAgICBzZWxmLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jaylcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGlmZmVyZW5jZSgqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgLSBiIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhpZHgsICppZHhzKVxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCppZHhzKVxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgJXh7XG4gICAgICBudW1iZXIgPSAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShudW1iZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSAmJlxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogLSN7YHNlbGYubGVuZ3RoYH0uLi4je2BzZWxmLmxlbmd0aGB9XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIGJsb2NrXG4gICAgICBpZiBgYXJncy5sZW5ndGggPiAyYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDAuLjIpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbHNlXG4gICAgICBpZiBgYXJncy5sZW5ndGggPT0gMGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDEuLjMpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvYmosIG9uZSwgdHdvID0gYXJnc1xuICAgIGVuZFxuXG4gICAgaWYgOjpSYW5nZSA9PT0gb25lXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2xlbmd0aCBpbnZhbGlkIHdpdGggcmFuZ2UnIGlmIHR3b1xuXG4gICAgICBsZWZ0ICAgPSBgb25lLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhvbmUuYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCIje29uZS5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIiBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIHJpZ2h0ID0gYG9uZS5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhvbmUuZW5kLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGByaWdodCArPSB0aGlzLmxlbmd0aGAgaWYgYHJpZ2h0IDwgMGBcbiAgICAgIGByaWdodCArPSAxYCB1bmxlc3Mgb25lLmV4Y2x1ZGVfZW5kP1xuXG4gICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPD0gbGVmdGBcbiAgICBlbHNpZiBvbmVcbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgbGVmdCAgID0gMCBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIGlmIHR3b1xuICAgICAgICByaWdodCA9IGAkY29lcmNlX3RvKHR3bywgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXG5cbiAgICAgICAgYHJpZ2h0ICs9IGxlZnRgXG4gICAgICBlbHNlXG4gICAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGVmdCAgPSAwXG4gICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGlmIGBsZWZ0ID4gdGhpcy5sZW5ndGhgXG4gICAgICAleHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGg7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgaWYgYHJpZ2h0ID4gdGhpcy5sZW5ndGhgXG4gICAgICBgdGhpcy5sZW5ndGggPSByaWdodGBcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGxlZnQpO1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZlswXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScsIHRydWUpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFyeSA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAkY29lcmNlX3RvKGxldmVsLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mbGF0dGVuKHNlbGYsIGxldmVsKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuIShsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBmbGF0dGVuZWQgPSAje2ZsYXR0ZW4gbGV2ZWx9O1xuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT0gZmxhdHRlbmVkLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmW2ldICE9PSBmbGF0dGVuZWRbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3tyZXBsYWNlIGBmbGF0dGVuZWRgfTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICBgJGZyZWV6ZShzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoJGhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnQSddLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICBpdGVtLCBpLCBrZXk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGZvciByZWN1cnNpdmUgc3RydWN0dXJlc1xuICAgICAgICBpZiAoJGhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluICRoYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSAkaGFzaF9pZHNba2V5XTtcbiAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obWVtYmVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG1lbWJlcn0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDppbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zZXJ0KGluZGV4LCAqb2JqZWN0cylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCIje2luZGV4fSBpcyBvdXQgb2YgYm91bmRzXCIgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5sZW5ndGg7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gobmlsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbaW5kZXgsIDBdLmNvbmNhdChvYmplY3RzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgaWQgPSAje19faWRfX30sXG4gICAgICBwdXNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKGluc3BlY3Rfc3RhY2suaW5kZXhPZihpZCkgIT09IC0xKSB7XG4gICAgICAgICAgcHVzaGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIH1cbiAgICAgICAgaW5zcGVjdF9zdGFjay5wdXNoKGlkKVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje3NlbGZbYGlgXX07XG5cbiAgICAgICAgICByZXN1bHQucHVzaCgje09wYWwuaW5zcGVjdChgaXRlbWApfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbnN1cmVcbiAgICAgIGBpZiAocHVzaGVkKSBpbnNwZWN0X3N0YWNrLnBvcCgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0aW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh0b19hLmR1cCkgeyB8YSwgYnwgYSAmIGIgfVxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0PyhvdGhlcilcbiAgICAhaW50ZXJzZWN0aW9uKG90aGVyKS5lbXB0eT9cbiAgZW5kXG5cbiAgZGVmIGpvaW4oc2VwID0gbmlsKVxuICAgIHJldHVybiAnJyBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgc2VwID09PSBuaWxgXG4gICAgICBzZXAgPSAkLFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgaSwgbGVuZ3RoLCBpdGVtLCB0bXA7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fc3RyJykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19zdHJ9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLnRvX3N9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fYXJ5JykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKHRtcCA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC5qb2luKHNlcCl9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fcycpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhcIiN7T3BhbC5pbnNwZWN0KGl0ZW0pfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3s6Ok9wYWwuY29lcmNlX3RvIShzZXAsIDo6U3RyaW5nLCA6dG9fc3RyKS50b19zfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYga2VlcF9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBmaWx0ZXJJZihzZWxmLCAkdHJ1dGh5LCBibG9jaylcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgZWFjaC5tYXgobiwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWluKCZibG9jaylcbiAgICBlYWNoLm1pbigmYmxvY2spXG4gIGVuZFxuXG4gICV4e1xuICAgIC8vIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgZnJvbSwgZnJvbS0xLCAuLi4sIGZyb20gLSBob3dfbWFueSArIDEuXG4gICAgZnVuY3Rpb24gZGVzY2VuZGluZ19mYWN0b3JpYWwoZnJvbSwgaG93X21hbnkpIHtcbiAgICAgIHZhciBjb3VudCA9IGhvd19tYW55ID49IDAgPyAxIDogMDtcbiAgICAgIHdoaWxlIChob3dfbWFueSkge1xuICAgICAgICBjb3VudCAqPSBmcm9tO1xuICAgICAgICBmcm9tLS07XG4gICAgICAgIGhvd19tYW55LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHBlcm11dGF0aW9uKG51bSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6cGVybXV0YXRpb24sIG51bSkgZG9cbiAgICAgICAgYGRlc2NlbmRpbmdfZmFjdG9yaWFsKHNlbGYubGVuZ3RoLCBudW0gPT09IHVuZGVmaW5lZCA/IHNlbGYubGVuZ3RoIDogbnVtKWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcGVybXV0ZSwgb2ZmZW5zaXZlLCBvdXRwdXQ7XG5cbiAgICAgIGlmIChudW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBudW0gPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBudW0gPSAkY29lcmNlX3RvKG51bSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR5aWVsZDEoYmxrLCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIC8vIG9mZmVuc2l2ZSAoYm90aCBkZWZpbml0aW9ucykgY29weS5cbiAgICAgICAgICBvZmZlbnNpdmUgPSBzZWxmLnNsaWNlKCk7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKG9mZmVuc2l2ZSwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfcGVybXV0YXRpb24obilcbiAgICBudW0gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX3Blcm11dGF0aW9uLCBudW0pIHsgbnVtID49IDAgPyBzaXplKipudW0gOiAwIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKG51bSwgW10sIHNlbGYuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9wKGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgY291bnQgPT09IDFgXG4gICAgICBgW3NlbGYucG9wKCldYFxuICAgIGVsc2lmIGBjb3VudCA+IHNlbGYubGVuZ3RoYFxuICAgICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcbiAgICBlbHNlXG4gICAgICBgc2VsZi5zcGxpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJvZHVjdCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICN7YmxvY2tfZ2l2ZW4/fSA/IG51bGwgOiBbXSxcbiAgICAgICAgICBuID0gYXJncy5sZW5ndGggKyAxLFxuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGxlbmd0aHMgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGFycmF5cyAgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGksIG0sIHN1YmFycmF5LCBsZW4sIHJlc3VsdGxlbiA9IDE7XG5cbiAgICAgIGFycmF5c1swXSA9IHNlbGY7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXSA9ICRjb2VyY2VfdG8oYXJnc1tpIC0gMV0sICN7OjpBcnJheX0sICd0b19hcnknKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZW4gPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XG4gICAgICAgIGlmIChyZXN1bHRsZW4gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICd0b28gYmlnIHRvIHByb2R1Y3QnfVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aHNbaV0gPSBsZW47XG4gICAgICAgIGNvdW50ZXJzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgb3V0ZXJfbG9vcDogZm9yICg7Oykge1xuICAgICAgICBzdWJhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgc3ViYXJyYXkucHVzaChhcnJheXNbaV1bY291bnRlcnNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3ViYXJyYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7eWllbGQgYHN1YmFycmF5YH1cbiAgICAgICAgfVxuICAgICAgICBtID0gbiAtIDE7XG4gICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIHdoaWxlIChjb3VudGVyc1ttXSA9PT0gbGVuZ3Roc1ttXSkge1xuICAgICAgICAgIGNvdW50ZXJzW21dID0gMDtcbiAgICAgICAgICBpZiAoLS1tIDwgMCkgYnJlYWsgb3V0ZXJfbG9vcDtcbiAgICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdXNoKCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggJiYgaXRlbVsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCN7YGl0ZW1bMV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgb3JpZ2luYWwgPSBsZW5ndGhcbiAgICBkZWxldGVfaWYoJmJsb2NrKVxuXG4gICAgdW5sZXNzIGxlbmd0aCA9PSBvcmlnaW5hbFxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVwbGFjZShvdGhlcilcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgc2VsZi5wdXNoLmFwcGx5KHNlbGYsIG90aGVyKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc2xpY2UoMCkucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZSFcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGBzZWxmLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJldmVyc2UuZWFjaCgmYmxvY2spXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gYG9iamVjdGB9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpyaW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZShuID0gMSlcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBzZWxmOjpTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gYCRjb2VyY2VfdG8oI3tAcm5nLnJhbmQoc2l6ZSl9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IDo6S2VybmVsLnJhbmQoYHNlbGYubGVuZ3RoYCkgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG5cbiAgICBpZiBgb3B0aW9ucyA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgKG8gPSA6Ok9wYWwuY29lcmNlX3RvPyBjb3VudCwgOjpIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7OjpIYXNofSwgJ3RvX2hhc2gnKWBcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJ1xuICAgIGVuZFxuXG4gICAgcm5nID0gb3B0aW9uc1s6cmFuZG9tXSBpZiBvcHRpb25zXG4gICAgcm5nID0gaWYgcm5nICYmIHJuZy5yZXNwb25kX3RvPyg6cmFuZClcbiAgICAgICAgICAgIFNhbXBsZVJhbmRvbS5uZXcgcm5nXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgOjpLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBqID0gaSA9PT0gMCA/IGkgKyAxIDogaSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzdWx0W2NdO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gcmVzdWx0W3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdFt0YXJnZXRJbmRleF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY291bnQgPT09IHNlbGYubGVuZ3RoID8gcmVzdWx0IDogI3tgcmVzdWx0YFswLCBjb3VudF19O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpXG5cbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuICAgICAgI3sga2VlcF9pZigmYmxvY2spIH07XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2hpZnROb0FyZyhzZWxmKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIGNvdW50KWBcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUocm5nID0gdW5kZWZpbmVkKVxuICAgIGR1cC50b19hLnNodWZmbGUhKHJuZylcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUhKHJuZyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciByYW5kZ2VuLCBpID0gc2VsZi5sZW5ndGgsIGosIHRtcDtcblxuICAgICAgaWYgKHJuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJuZyA9ICN7OjpPcGFsLmNvZXJjZV90bz8ocm5nLCA6Okhhc2gsIDp0b19oYXNoKX07XG5cbiAgICAgICAgaWYgKHJuZyAhPT0gbmlsKSB7XG4gICAgICAgICAgcm5nID0gI3tybmdbOnJhbmRvbV19O1xuXG4gICAgICAgICAgaWYgKHJuZyAhPT0gbmlsICYmICN7cm5nLnJlc3BvbmRfdG8/KDpyYW5kKX0pIHtcbiAgICAgICAgICAgIHJhbmRnZW4gPSBybmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGlmIChyYW5kZ2VuKSB7XG4gICAgICAgICAgaiA9IHJhbmRnZW4uJHJhbmQoaSkuJHRvX2ludCgpO1xuXG4gICAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBzbWFsbCAje2BqYH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA+PSBpKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBiaWcgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGogPSAje3JhbmQoYGlgKX07XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBzZWxmWy0taV07XG4gICAgICAgIHNlbGZbaV0gPSBzZWxmW2pdO1xuICAgICAgICBzZWxmW2pdID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoaW5kZXgsIGxlbmd0aCA9IHVuZGVmaW5lZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgaWYgYGxlbmd0aCA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgOjpSYW5nZSA9PT0gaW5kZXhcbiAgICAgICAgcmFuZ2UgPSBpbmRleFxuICAgICAgICByZXN1bHQgPSBzZWxmW3JhbmdlXVxuXG4gICAgICAgIHJhbmdlX3N0YXJ0ID0gYHJhbmdlLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhyYW5nZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHJhbmdlX2VuZCA9IGByYW5nZS5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhyYW5nZS5lbmQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCAmJiByYW5nZS5lbmQgIT09IG5pbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGZbc3RhcnRdO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNoaWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgbGVuZ3RoID0gYCRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgeGAuaW5zcGVjdH0gd2l0aCAje2B5YC5pbnNwZWN0fSBmYWlsZWRcIn07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3tgcmV0YCA+IDB9ID8gMSA6ICgje2ByZXRgIDwgMH0gPyAtMSA6IDApO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydCEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKVxuXG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydCgmYmxvY2spfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAje2BzZWxmLnNsaWNlKClgLnNvcnR9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLmxlbmd0aCA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKHJlc3VsdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnRfYnkhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvcn07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIHZhbHVlID0gYmxvY2soaXRlbSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuQXJyYXkuJG5ldyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hcnlcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICBhcnJheSA9IHNlbGZcbiAgICBhcnJheSA9IGFycmF5Lm1hcCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuID0gYXJyYXkubGVuZ3RoLCBhcnksIGtleSwgdmFsLCBoYXNoID0gI3t7fX07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnkgPSAjezo6T3BhbC5jb2VyY2VfdG8/KGBhcnJheVtpXWAsIDo6QXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IGF0ICN7YGlgfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBhcnJheSBsZW5ndGggYXQgI3tgaWB9IChleHBlY3RlZCAyLCB3YXMgI3tgYXJ5YC5sZW5ndGh9KVwifVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IGFyeVswXTtcbiAgICAgICAgdmFsID0gYXJ5WzFdO1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc3Bvc2VcbiAgICByZXR1cm4gW10gaWYgZW1wdHk/XG5cbiAgICByZXN1bHQgPSBbXVxuICAgIG1heCAgICA9IG5pbFxuXG4gICAgZWFjaCBkbyB8cm93fFxuICAgICAgcm93ID0gaWYgOjpBcnJheSA9PT0gcm93XG4gICAgICAgICAgICAgIHJvdy50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKHJvdywgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICAgbWF4IHx8PSBgcm93Lmxlbmd0aGBcblxuICAgICAgaWYgYHJvdy5sZW5ndGhgICE9IG1heFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiZWxlbWVudCBzaXplIGRpZmZlcnMgKCN7YHJvdy5sZW5ndGhgfSBzaG91bGQgYmUgI3ttYXh9KVwiXG4gICAgICBlbmRcblxuICAgICAgYHJvdy5sZW5ndGhgLnRpbWVzIGRvIHxpfFxuICAgICAgICBlbnRyeSA9IChyZXN1bHRbaV0gfHw9IFtdKVxuICAgICAgICBlbnRyeSA8PCByb3cuYXQoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB1bmlvbigqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodW5pcSkgeyB8YSwgYnwgYSB8IGIgfVxuICBlbmRcblxuICBkZWYgdW5pcSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgaXRlbSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGl0ZW0sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICBrZXkgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2BoYXNoYC52YWx1ZXN9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuaXEhKCZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBvcmlnaW5hbF9sZW5ndGggPSBzZWxmLmxlbmd0aCwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3JpZ2luYWxfbGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGtleSA9IChibG9jayA9PT0gbmlsID8gaXRlbSA6ICR5aWVsZDEoYmxvY2ssIGl0ZW0pKTtcblxuICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWxfbGVuZ3RoID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bnNoaWZ0KCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHNlbGZMZW5ndGggPSBzZWxmLmxlbmd0aFxuICAgICAgdmFyIG9iamVjdHNMZW5ndGggPSBvYmplY3RzLmxlbmd0aFxuICAgICAgaWYgKG9iamVjdHNMZW5ndGggPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICB2YXIgaW5kZXggPSBzZWxmTGVuZ3RoIC0gb2JqZWN0c0xlbmd0aFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKHNlbGZbaW5kZXggKyBpXSlcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSBzZWxmTGVuZ3RoIC0gMVxuICAgICAgd2hpbGUgKGxlbiAtIG9iamVjdHNMZW5ndGggPj0gMCkge1xuICAgICAgICBzZWxmW2xlbl0gPSBzZWxmW2xlbiAtIG9iamVjdHNMZW5ndGhdXG4gICAgICAgIGxlbi0tXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdHNMZW5ndGg7IGorKykge1xuICAgICAgICBzZWxmW2pdID0gb2JqZWN0c1tqXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIG91dCA9IFtdXG5cbiAgICBhcmdzLmVhY2ggZG8gfGVsZW18XG4gICAgICBpZiBlbGVtLmlzX2E/IDo6UmFuZ2VcbiAgICAgICAgZmluaXNoID0gYCN7ZWxlbS5lbmR9ID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oI3tlbGVtLmVuZH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICBzdGFydCA9IGAje2VsZW0uYmVnaW59ID09PSBuaWwgPyAwIDogJGNvZXJjZV90bygje2VsZW0uYmVnaW59LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0ICsgc2VsZi5sZW5ndGg7XG4gICAgICAgICAgICAje25leHR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChmaW5pc2ggPCAwKSB7XG4gICAgICAgICAgICBmaW5pc2ggPSBmaW5pc2ggKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCN7ZWxlbS5leGNsdWRlX2VuZD99ICYmICN7ZWxlbS5lbmR9ICE9PSBuaWwpIHtcbiAgICAgICAgICAgIGZpbmlzaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluaXNoIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQudXB0byhmaW5pc2gpIHsgfGl8IG91dCA8PCBhdChpKSB9XG4gICAgICBlbHNlXG4gICAgICAgIGkgPSBgJGNvZXJjZV90byhlbGVtLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgb3V0IDw8IGF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG91dFxuICBlbmRcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgc2l6ZSA9IHNlbGYubGVuZ3RoLCBwYXJ0LCBvLCBpLCBqLCBqajtcblxuICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBvID0gb3RoZXJzW2pdO1xuICAgICAgICBpZiAoby4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uJCRpc19yYW5nZSB8fCBvLiQkaXNfZW51bWVyYXRvcikge1xuICAgICAgICAgIG90aGVyc1tqXSA9IG8uJHRha2Uoc2l6ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJzW2pdID0gI3soXG4gICAgICAgICAgOjpPcGFsLmNvZXJjZV90bz8oYG9gLCA6OkFycmF5LCA6dG9fYXJ5KSB8fFxuICAgICAgICAgIDo6T3BhbC5jb2VyY2VfdG8hKGBvYCwgOjpFbnVtZXJhdG9yLCA6dG9fZW51bSwgOmVhY2gpXG4gICAgICAgICkudG9fYX07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgcGFydCA9IFtzZWxmW2ldXTtcblxuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgbyA9IG90aGVyc1tqXVtpXTtcblxuICAgICAgICAgIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydFtqICsgMV0gPSBvO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2ldID0gcGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCByZXN1bHRbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICAleHtcbiAgICAgIGtsYXNzLiQkcHJvdG90eXBlLiR0b19hID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBzdXBlci5yZWplY3QgeyB8aXZhcnwgYC9eQFxcZCskLy50ZXN0KCN7aXZhcn0pYCB8fCBpdmFyID09ICdAbGVuZ3RoJyB9XG4gIGVuZFxuXG4gIGRlZiBwYWNrKCphcmdzKVxuICAgIDo6S2VybmVsLnJhaXNlIFwiVG8gdXNlIEFycmF5I3BhY2ssIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvYXJyYXkvcGFjaycuXCJcbiAgZW5kXG5cbiAgYWxpYXMgYXBwZW5kIHB1c2hcbiAgYWxpYXMgZmlsdGVyIHNlbGVjdFxuICBhbGlhcyBmaWx0ZXIhIHNlbGVjdCFcbiAgYWxpYXMgbWFwIGNvbGxlY3RcbiAgYWxpYXMgbWFwISBjb2xsZWN0IVxuICBhbGlhcyBwcmVwZW5kIHVuc2hpZnRcbiAgYWxpYXMgc2l6ZSBsZW5ndGhcbiAgYWxpYXMgc2xpY2UgW11cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgOjpPcGFsLnByaXN0aW5lIHNpbmdsZXRvbl9jbGFzcywgOmFsbG9jYXRlXG4gIDo6T3BhbC5wcmlzdGluZSBzZWxmLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkFycmF5PiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwidG9fYSIsIltdIiwiaW5pdGlhbGl6ZSIsInNpemUiLCJvYmoiLCJLZXJuZWwiLCJ3YXJuIiwiSW50ZWdlcjo6TUFYIiwiSW50ZWdlciIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInJlcGxhY2UiLCJyZXNwb25kX3RvPyIsInRvX2FyeSIsInRyeV9jb252ZXJ0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJBcnJheSIsIiYiLCJvdGhlciIsInwiLCIqIiwiam9pbiIsInRvX3N0ciIsIisiLCItIiwiPDwiLCJvYmplY3QiLCI8PT4iLCJoYXNoIiwiPT0iLCJvYmplY3RfaWQiLCJpbmRleCIsImxlbmd0aCIsIltdPSIsInZhbHVlIiwiZXh0cmEiLCJkYXRhIiwiUmFuZ2VFcnJvciIsImluc3BlY3QiLCIxIiwiSW5kZXhFcnJvciIsImFueT8iLCJwYXR0ZXJuIiwiYXNzb2MiLCJhdCIsImJzZWFyY2hfaW5kZXgiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsIlR5cGVFcnJvciIsImNsYXNzIiwiYnNlYXJjaCIsImJsb2NrIiwidG9fcHJvYyIsImN5Y2xlIiwibiIsImJsb2NrIGluIGN5Y2xlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjeWNsZSIsIm5pbD8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImNvZXJjZV90byEiLCI+IiwiMCIsImVudW1lcmF0b3Jfc2l6ZSIsImVtcHR5PyIsImNsZWFyIiwiY291bnQiLCJpbml0aWFsaXplX2NvcHkiLCJjb2xsZWN0IiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsImNvbGxlY3QhIiwiYmxvY2sgaW4gY29sbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QhIiwiY29tYmluYXRpb24iLCJudW0iLCJibG9jayBpbiBjb21iaW5hdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gY29tYmluYXRpb24iLCJyZXBlYXRlZF9jb21iaW5hdGlvbiIsImJsb2NrIGluIHJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXBlYXRlZF9jb21iaW5hdGlvbiIsImNvbXBhY3QiLCJjb21wYWN0ISIsImNvbmNhdCIsIm90aGVycyIsIm1hcCIsImJsb2NrIGluIGNvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29uY2F0IiwiZXF1YWw/IiwiZHVwIiwiZWFjaCIsImRlbGV0ZSIsImRlbGV0ZV9hdCIsImRlbGV0ZV9pZiIsImJsb2NrIGluIGRlbGV0ZV9pZiIsImJsb2NrICgyIGxldmVscykgaW4gZGVsZXRlX2lmIiwiZGlmZmVyZW5jZSIsInJlZHVjZSIsImFycmF5cyIsImJsb2NrIGluIGRpZmZlcmVuY2UiLCJhIiwiYiIsImJsb2NrICgyIGxldmVscykgaW4gZGlmZmVyZW5jZSIsImRpZyIsImlkeCIsIml0ZW0iLCJpZHhzIiwiZHJvcCIsIm51bWJlciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJlYWNoX2luZGV4IiwiYmxvY2sgaW4gZWFjaF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9pbmRleCIsImVxbD8iLCJmZXRjaCIsImRlZmF1bHRzIiwiZmlsbCIsImFyZ3MiLCJvbmUiLCJ0d28iLCJSYW5nZSIsImxlZnQiLCJyaWdodCIsImV4Y2x1ZGVfZW5kPyIsImZpcnN0IiwiZmxhdHRlbiIsImxldmVsIiwiZmxhdHRlbiEiLCJmcmVlemUiLCJmcm96ZW4/IiwiaW5jbHVkZT8iLCJtZW1iZXIiLCJpbnNlcnQiLCJfX2lkX18iLCJpbnRlcnNlY3Rpb24iLCJibG9jayBpbiBpbnRlcnNlY3Rpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIGludGVyc2VjdGlvbiIsImludGVyc2VjdD8iLCIhIiwic2VwIiwiJCwiLCJ0b19zIiwiTm9NZXRob2RFcnJvciIsIm5ldyIsIlN0cmluZyIsImtlZXBfaWYiLCJibG9jayBpbiBrZWVwX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBrZWVwX2lmIiwibGFzdCIsIm1heCIsIm1pbiIsInBlcm11dGF0aW9uIiwiYmxvY2sgaW4gcGVybXV0YXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHBlcm11dGF0aW9uIiwicGVybSIsInVzZWQiLCJyZXBlYXRlZF9wZXJtdXRhdGlvbiIsImJsb2NrIGluIHJlcGVhdGVkX3Blcm11dGF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXBlYXRlZF9wZXJtdXRhdGlvbiIsIj49IiwiKioiLCJwb3AiLCJwcm9kdWN0IiwicHVzaCIsInJhc3NvYyIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwicmVqZWN0ISIsImJsb2NrIGluIHJlamVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCEiLCJvcmlnaW5hbCIsInJldmVyc2UiLCJyZXZlcnNlISIsInJldmVyc2VfZWFjaCIsImJsb2NrIGluIHJldmVyc2VfZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gcmV2ZXJzZV9lYWNoIiwicmluZGV4Iiwicm90YXRlIiwicm90YXRlISIsImNudCIsImFyeSIsIjxjbGFzczpzZWxmOjpTYW1wbGVSYW5kb20+IiwicmFuZCIsInJhbmRvbSIsIkBybmciLCJzYW1wbGUiLCJvcHRpb25zIiwibyIsIkhhc2giLCJybmciLCJTYW1wbGVSYW5kb20iLCJzZWxlY3QiLCJibG9jayBpbiBzZWxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCIsInNlbGVjdCEiLCJibG9jayBpbiBzZWxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QhIiwic2hpZnQiLCJzaHVmZmxlIiwic2h1ZmZsZSEiLCJzbGljZSEiLCJyZXN1bHQiLCJyYW5nZSIsInJhbmdlX3N0YXJ0IiwicmFuZ2VfZW5kIiwic3RhcnQiLCJzb3J0IiwiPCIsInNvcnQhIiwic29ydF9ieSEiLCJibG9jayBpbiBzb3J0X2J5ISIsImJsb2NrICgyIGxldmVscykgaW4gc29ydF9ieSEiLCJzb3J0X2J5IiwidGFrZSIsInRha2Vfd2hpbGUiLCJ0b19oIiwiYXJyYXkiLCJ0cmFuc3Bvc2UiLCJibG9jayBpbiB0cmFuc3Bvc2UiLCJyb3ciLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zcG9zZSIsIiRyZXRfb3JfMSIsInRpbWVzIiwiaSIsImJsb2NrICgzIGxldmVscykgaW4gdHJhbnNwb3NlIiwiZW50cnkiLCJ1bmlvbiIsInVuaXEiLCJibG9jayBpbiB1bmlvbiIsImJsb2NrICgyIGxldmVscykgaW4gdW5pb24iLCJ2YWx1ZXMiLCJ1bmlxISIsInVuc2hpZnQiLCJ2YWx1ZXNfYXQiLCJvdXQiLCJibG9jayBpbiB2YWx1ZXNfYXQiLCJlbGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJpc19hPyIsImZpbmlzaCIsImVuZCIsImJlZ2luIiwidXB0byIsImJsb2NrICgzIGxldmVscykgaW4gdmFsdWVzX2F0IiwiemlwIiwiRW51bWVyYXRvciIsImluaGVyaXRlZCIsImtsYXNzIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiYmxvY2sgaW4gaW5zdGFuY2VfdmFyaWFibGVzIiwiaXZhciIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfdmFyaWFibGVzIiwicGFjayIsInByaXN0aW5lIiwic2luZ2xldG9uX2NsYXNzIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBR0NEOztBQUdIQTtBQUNBQTtBQUNBQTtBQUNBQTtB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biI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb25zdGFudHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpSVUJZX1BMQVRGT1JNICAgICAgID0gJ29wYWwnXG46OlJVQllfRU5HSU5FICAgICAgICAgPSAnb3BhbCdcbjo6UlVCWV9WRVJTSU9OICAgICAgICA9ICczLjEuMCdcbjo6UlVCWV9FTkdJTkVfVkVSU0lPTiA9ICcxLjYuMSdcbjo6UlVCWV9SRUxFQVNFX0RBVEUgICA9ICcyMDIyLTEyLTA5J1xuOjpSVUJZX1BBVENITEVWRUwgICAgID0gMFxuOjpSVUJZX1JFVklTSU9OICAgICAgID0gJzAnXG46OlJVQllfQ09QWVJJR0hUICAgICAgPSAnb3BhbCAtIENvcHlyaWdodCAoQykgMjAxMy0yMDIyIEFkYW0gQmV5bm9uIGFuZCB0aGUgT3BhbCBjb250cmlidXRvcnMnXG46OlJVQllfREVTQ1JJUFRJT04gICAgPSBcIm9wYWwgI3s6OlJVQllfRU5HSU5FX1ZFUlNJT059ICgjezo6UlVCWV9SRUxFQVNFX0RBVEV9IHJldmlzaW9uICN7OjpSVUJZX1JFVklTSU9OfSlcIlxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIwIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsIlJVQllfUkVMRUFTRV9EQVRFIiwiUlVCWV9SRVZJU0lPTiJdLCJtYXBwaW5ncyI6IkFBQUFBLG9DQUFBQSxnQkFBQUE7RUFBQUE7OztFQUFBLFdBQUEsSUFBQSxtQkFBd0JBLE1BQXhCO0VBQ0EsV0FBQSxJQUFBLGlCQUF3QkEsTUFBeEI7RUFDQSxXQUFBLElBQUEsa0JBQXdCQSxPQUF4QjtFQUNBLFdBQUEsSUFBQSx5QkFBd0JBLE9BQXhCO0VBQ0EsV0FBQSxJQUFBLHVCQUF3QkEsWUFBeEI7RUFDQSxXQUFBLElBQUEscUJBQXdCQyxDQUF4QjtFQUNBLFdBQUEsSUFBQSxtQkFBd0JELEdBQXhCO0VBQ0EsV0FBQSxJQUFBLG9CQUF3QkEsc0VBQXhCO0VBQ0FBLE9BQUEsV0FBQSxJQUFBLHNCQUF5QkEsT0FBRCxHQUFBLENBQVFFLDBCQUFSLENBQUEsR0FBOEJGLElBQTlCLEdBQUEsQ0FBa0NHLHdCQUFsQyxDQUFBLEdBQXNESCxZQUF0RCxHQUFBLENBQWtFSSxvQkFBbEUsQ0FBQSxHQUFrRkosR0FBMUc7QUFSQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxOTI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgcmVzcG9uZF90bywgT3BhbCwgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemUsIGZyZWV6ZV9wcm9wc1xuIyB1c2Vfc3RyaWN0OiB0cnVlXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgPX4ob2JqKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhfihvYmopXG4gICAgIShzZWxmID1+IG9iailcbiAgZW5kXG5cbiAgZGVmID09PShvdGhlcilcbiAgICBvYmplY3RfaWQgPT0gb3RoZXIub2JqZWN0X2lkIHx8IHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIC8vIHNldCBndWFyZCBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICBzZWxmLiQkY29tcGFyYWJsZSA9IHRydWU7XG5cbiAgICAgIHZhciB4ID0gI3tzZWxmID09IG90aGVyfTtcblxuICAgICAgaWYgKHggJiYgeCAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5jbGFzc30nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7OjpNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmLmNsYXNzfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7OjpPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCA6OkFycmF5LCA6dG9fYXJ5KX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIGNvZXJjZWQgPSAjezo6T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgOjpBcnJheSwgOnRvX2EpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgcmV0dXJuIFtvYmplY3RdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0X2V4aXQoJmJsb2NrKVxuICAgICRfX2F0X2V4aXRfXyB8fD0gW11cbiAgICAkX19hdF9leGl0X18gPDwgYmxvY2tcbiAgICBibG9ja1xuICBlbmRcblxuICBkZWYgY2FsbGVyKHN0YXJ0ID0gMSwgbGVuZ3RoID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIHN0YWNrLCByZXN1bHQ7XG5cbiAgICAgIHN0YWNrID0gbmV3IEVycm9yKCkuJGJhY2t0cmFjZSgpO1xuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAje3N0YXJ0fSArIDEsIGlpID0gc3RhY2subGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBpZiAoIXN0YWNrW2ldLm1hdGNoKC9ydW50aW1lXFwuanMvKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCAhPSBuaWwpIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYWxsZXJfbG9jYXRpb25zKCphcmdzKVxuICAgIGNhbGxlcigqYXJncykubWFwIGRvIHxsb2N8XG4gICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xhc3NcbiAgICBgc2VsZi4kJGNsYXNzYFxuICBlbmRcblxuICBkZWYgY29weV9pbnN0YW5jZV92YXJpYWJsZXMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKSwgaSwgaWksIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAnJCcgJiYgb3RoZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3B5X3NpbmdsZXRvbl9tZXRob2RzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGksIG5hbWUsIG5hbWVzLCBsZW5ndGg7XG5cbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykgJiYgb3RoZXIuJCRtZXRhICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBvdGhlcl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob3RoZXIpO1xuICAgICAgICB2YXIgc2VsZl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZik7XG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdID0gb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyKSwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiBuaWwpXG4gICAgdW5sZXNzIGZyZWV6ZS5uaWw/IHx8IGZyZWV6ZSA9PSB0cnVlIHx8IGZyZWV6ZSA9PSBmYWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHZhbHVlIGZvciBmcmVlemU6ICN7ZnJlZXplLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmLCBmcmVlemU6IGZyZWV6ZSlcblxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlIHx8IChmcmVlemUubmlsPyAmJiBmcm96ZW4/KVxuICAgICAgY29weS5mcmVlemVcbiAgICBlbmRcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY2xvbmUob3RoZXIsIGZyZWV6ZTogbmlsKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfc2luZ2xldG9uX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBzaW5nbGV0b25fY2xhc3MuZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICBlbmRcblxuICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgOjpFbnVtZXJhdG9yLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXhpdChzdGF0dXMgPSB0cnVlKVxuICAgICRfX2F0X2V4aXRfXyB8fD0gW11cblxuICAgIHVudGlsICRfX2F0X2V4aXRfXy5lbXB0eT9cbiAgICAgIGJsb2NrID0gJF9fYXRfZXhpdF9fLnBvcFxuICAgICAgYmxvY2suY2FsbFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc3RhdHVzLiQkaXNfYm9vbGVhbikge1xuICAgICAgICBzdGF0dXMgPSBzdGF0dXMgPyAwIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9ICRjb2VyY2VfdG8oc3RhdHVzLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKVxuICAgICAgfVxuXG4gICAgICBPcGFsLmV4aXQoc3RhdHVzKTtcbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBleHRlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAje3JhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XG4gICAgICB9XG5cbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBzaW5nbGV0b24gPSAje3NpbmdsZXRvbl9jbGFzc307XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgYHNpbmdsZXRvbmB9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZF9vYmplY3Qgc2VsZn07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mKHNlbGYpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICRmcmVlemVfcHJvcHMoc2VsZik7XG4gICAgICAgIHJldHVybiAkZnJlZXplKHNlbGYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJvemVuP1xuICAgICV4e1xuICAgICAgc3dpdGNoICh0eXBlb2Yoc2VsZikpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICByZXR1cm4gKHNlbGYuJCRmcm96ZW4gfHwgZmFsc2UpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldHMoKmFyZ3MpXG4gICAgJHN0ZGluLmdldHMoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgX19pZF9fXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaXZzID0gJydcbiAgICBpZCA9IF9faWRfX1xuICAgIGlmIGBpbnNwZWN0X3N0YWNrYC5pbmNsdWRlPyBpZFxuICAgICAgaXZzID0gJyAuLi4nXG4gICAgZWxzZVxuICAgICAgYGluc3BlY3Rfc3RhY2tgIDw8IGlkXG4gICAgICBwdXNoZWQgPSB0cnVlXG4gICAgICBpbnN0YW5jZV92YXJpYWJsZXMuZWFjaCBkbyB8aXxcbiAgICAgICAgaXZhciA9IGluc3RhbmNlX3ZhcmlhYmxlX2dldChpKVxuICAgICAgICBpbnNwZWN0ID0gT3BhbC5pbnNwZWN0KGl2YXIpXG4gICAgICAgIGl2cyArPSBcIiAje2l9PSN7aW5zcGVjdH1cIlxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje2lkLnRvX3MoMTYpfSN7aXZzfT5cIlxuICByZXNjdWUgPT4gZVxuICAgIFwiIzwje3NlbGYuY2xhc3N9OjB4I3tpZC50b19zKDE2KX0+XCJcbiAgZW5zdXJlXG4gICAgYGluc3BlY3Rfc3RhY2tgLnBvcCBpZiBwdXNoZWRcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICAleHtcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNsYXNzID09PSBrbGFzcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZiwgbmFtZS5zdWJzdHIoMSkpYFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICB2YXIgaXZhciA9IHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV07XG5cbiAgICAgIHJldHVybiBpdmFyID09IG51bGwgPyBuaWwgOiBpdmFyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXkgPSBPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpLFxuICAgICAgICAgIHZhbDtcbiAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsID0gc2VsZltrZXldO1xuICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGl2YXI7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgaXZhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHN0ciwgYmFzZV9kaWdpdHM7XG5cbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEludGVnZXJcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgdmFsdWV9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChpICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3s6Ok9wYWwuY29lcmNlX3RvISh2YWx1ZSwgOjpJbnRlZ2VyLCA6dG9faSl9O1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IFwiMFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2UgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KS8sIGZ1bmN0aW9uIChfLCBoZWFkLCBmbGFnKSB7XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMikge1xuICAgICAgICAgICAgYmFzZSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSA4KSB7XG4gICAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICB9XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIGkgPSBwYXJzZUludChzdHIsIGJhc2UpO1xuXG4gICAgICBpZiAoaXNOYU4oaSkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEZsb2F0KHZhbHVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5JbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBGbG9hdCgpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Ok9wYWwuY29lcmNlX3RvISh2YWx1ZSwgOjpGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiA6Okhhc2ggPT09IGFyZ1xuICAgIDo6T3BhbC5jb2VyY2VfdG8hKGFyZywgOjpIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPcGFsLmlzX2Eoc2VsZiwga2xhc3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGl0c2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgOjpGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIDo6U3RvcEl0ZXJhdGlvbiA9PiBlXG4gICAgICAgIHJldHVybiBlLnJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICBpZiBhcmdzLmFueT9cbiAgICAgIHByaW50IGZvcm1hdCgqYXJncylcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHJvYygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgcmVhZGxpbmUoKmFyZ3MpXG4gICAgJHN0ZGluLnJlYWRsaW5lKCphcmdzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSA6Ok9wYWwuY29lcmNlX3RvISh1cGxldmVsLCA6OkludGVnZXIsIDp0b19zdHIpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAxLCAxKS5maXJzdCYuc3BsaXQoJzppbiBgJykmLmZpcnN0XG4gICAgICBsb2NhdGlvbiA9IFwiI3tsb2NhdGlvbn06IFwiIGlmIGxvY2F0aW9uXG4gICAgICBzdHJzID0gc3Rycy5tYXAgeyB8c3wgXCIje2xvY2F0aW9ufXdhcm5pbmc6ICN7c31cIiB9XG4gICAgZW5kXG5cbiAgICAkc3RkZXJyLnB1dHMoKnN0cnMpIHVubGVzcyAkVkVSQk9TRS5uaWw/IHx8IHN0cnMuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiByYWlzZShleGNlcHRpb24gPSB1bmRlZmluZWQsIHN0cmluZyA9IG5pbCwgYmFja3RyYWNlID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsICYmICN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgdGhyb3cgI3skIX07XG4gICAgICB9XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlJ1bnRpbWVFcnJvci5uZXcgJyd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJHRvX3N0cicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7OjpSdW50aW1lRXJyb3IubmV3IGV4Y2VwdGlvbi50b19zdHJ9O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJGV4Y2VwdGlvbicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfZXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIGV4Y2VwdGlvbiBpcyBmaW5lXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlR5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhY2t0cmFjZSAhPT0gbmlsKSB7XG4gICAgICAgIGV4Y2VwdGlvbi4kc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3skIX0gIT09IG5pbCkge1xuICAgICAgICBPcGFsLmV4Y2VwdGlvbnMucHVzaCgjeyQhfSk7XG4gICAgICB9XG5cbiAgICAgICN7JCF9ID0gZXhjZXB0aW9uO1xuICAgICAgI3skQH0gPSAje2BleGNlcHRpb25gLmJhY2t0cmFjZX07XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3s6OlJhbmRvbTo6REVGQVVMVC5yYW5kfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAobWF4IDwgMCkge1xuICAgICAgICAgIG1heCA9IE1hdGguYWJzKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICUgMSAhPT0gMCkge1xuICAgICAgICAgIG1heCA9IG1heC4kdG9faSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgICAgIG1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICA6OlJhbmRvbTo6REVGQVVMVC5yYW5kKG1heClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG8/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7cmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCBpbmNsdWRlX2FsbCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgOjpPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICAleHtcbiAgICAgIC8vIEFzIE9iamVjdC5yZXF1aXJlIHJlZmVycyB0byBLZXJuZWwucmVxdWlyZSBvbmNlIEtlcm5lbCBoYXMgYmVlbiBsb2FkZWQgdGhlIFN0cmluZ1xuICAgICAgLy8gY2xhc3MgbWF5IG5vdCBiZSBhdmFpbGFibGUgeWV0LCB0aGUgY29lcmNpb24gcmVxdWlyZXMgYm90aCAgU3RyaW5nIGFuZCBBcnJheSB0byBiZSBsb2FkZWQuXG4gICAgICBpZiAodHlwZW9mICN7ZmlsZX0gIT09ICdzdHJpbmcnICYmIE9wYWwuU3RyaW5nICYmIE9wYWwuQXJyYXkpIHtcbiAgICAgICAgI3tmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcGFsLnJlcXVpcmUoI3tmaWxlfSlcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXF1aXJlX3JlbGF0aXZlKGZpbGUpXG4gICAgOjpPcGFsLnRyeV9jb252ZXJ0IShmaWxlLCA6OlN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gOjpGaWxlLmV4cGFuZF9wYXRoIDo6RmlsZS5qb2luKGBPcGFsLmN1cnJlbnRfZmlsZWAsICcuLicsIGZpbGUpXG5cbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICAjIGBwYXRoYCBzaG91bGQgYmUgdGhlIGZ1bGwgcGF0aCB0byBiZSBmb3VuZCBpbiByZWdpc3RlcmVkIG1vZHVsZXMgKGBPcGFsLm1vZHVsZXNgKVxuICBkZWYgcmVxdWlyZV90cmVlKHBhdGgsIGF1dG9sb2FkOiBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7OjpGaWxlLmV4cGFuZF9wYXRoKHBhdGgpfVxuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHBhdGggPT09ICcuJykgcGF0aCA9ICcnO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgaWYgKCN7YG5hbWVgLnN0YXJ0X3dpdGg/KHBhdGgpfSkge1xuICAgICAgICAgIGlmKCEje2F1dG9sb2FkfSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW25hbWUsIE9wYWwucmVxdWlyZShuYW1lKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgdHJ1ZV0pOyAvLyBkbyBub3RoaW5nLCBkZWxlZ2F0ZWQgdG8gYSBhdXRvbG9hZGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgTmlsQ2xhc3MgaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2Vjb25kcy5jbGFzc30gaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIDo6UmFuZG9tLnNyYW5kKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiBTdHJpbmcoc3RyKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8/KHN0ciwgOjpTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShzdHIsIDo6U3RyaW5nLCA6dG9fcylcbiAgZW5kXG5cbiAgZGVmIHRhcCgmYmxvY2spXG4gICAgeWllbGQgc2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIGNhdGNoKHRhZyA9IG5pbClcbiAgICB0YWcgfHw9IDo6T2JqZWN0Lm5ld1xuICAgIHlpZWxkKHRhZylcbiAgcmVzY3VlIDo6VW5jYXVnaHRUaHJvd0Vycm9yID0+IGVcbiAgICByZXR1cm4gZS52YWx1ZSBpZiBlLnRhZyA9PSB0YWdcbiAgICA6Oktlcm5lbC5yYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3codGFnLCBvYmogPSBuaWwpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpVbmNhdWdodFRocm93RXJyb3IubmV3KHRhZywgb2JqKVxuICBlbmRcblxuICAjIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIG9wZW4sIGRlbGVnYXRlIHRvIEZpbGUub3BlblxuICBkZWYgb3BlbigqYXJncywgJmJsb2NrKVxuICAgIDo6RmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcblxuICBhbGlhcyBmYWlsIHJhaXNlXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbiAgYWxpYXMgcHVibGljX3NlbmQgX19zZW5kX19cbiAgYWxpYXMgc2VuZCBfX3NlbmRfX1xuICBhbGlhcyB0aGVuIHlpZWxkX3NlbGZcbiAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxuZW5kXG5cbmNsYXNzIDo6T2JqZWN0XG4gICMgT2JqZWN0LnJlcXVpcmUgaGFzIGJlZW4gc2V0IHRvIHJ1bnRpbWUuanMgT3BhbC5yZXF1aXJlXG4gICMgTm93IHdlIGhhdmUgS2VybmVsIGxvYWRlZCwgbWFrZSBzdXJlIE9iamVjdC5yZXF1aXJlIHJlZmVycyB0byBLZXJuZWwucmVxdWlyZVxuICAjIHdoaWNoIGlzIHdoYXQgcnVieSBkb2VzIGFuZCBhbGxvd3MgZm9yIG92ZXJ3cml0aW5nIGJ5IGF1dG9sb2FkZXJzXG4gIGBkZWxldGUgJE9iamVjdC4kJHByb3RvdHlwZS4kcmVxdWlyZWBcbiAgaW5jbHVkZSA6Oktlcm5lbFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIj1+IiwiIX4iLCJvYmoiLCJzZWxmIiwiISIsIj09PSIsIm90aGVyIiwiJHJldF9vcl8xIiwib2JqZWN0X2lkIiwiPT0iLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiS2VybmVsIiwicmFpc2UiLCJOYW1lRXJyb3IiLCJuZXciLCJjbGFzcyIsIk1ldGhvZCIsIm1ldGhvZHMiLCJhbGwiLCJwdWJsaWNfbWV0aG9kcyIsIkFycmF5Iiwib2JqZWN0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiPDwiLCJibG9jayIsImNhbGxlciIsInN0YXJ0IiwibGVuZ3RoIiwiMSIsImNhbGxlcl9sb2NhdGlvbnMiLCJtYXAiLCJhcmdzIiwiYmxvY2sgaW4gY2FsbGVyX2xvY2F0aW9ucyIsImxvYyIsImJsb2NrICgyIGxldmVscykgaW4gY2FsbGVyX2xvY2F0aW9ucyIsIlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbiIsIlRocmVhZDo6QmFja3RyYWNlIiwiVGhyZWFkIiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiY2xvbmUiLCIka3dhcmdzIiwiZnJlZXplIiwibmlsPyIsIkFyZ3VtZW50RXJyb3IiLCJjb3B5IiwiYWxsb2NhdGUiLCJpbml0aWFsaXplX2Nsb25lIiwiZnJvemVuPyIsImluaXRpYWxpemVfY29weSIsImRlZmluZV9zaW5nbGV0b25fbWV0aG9kIiwiZGVmaW5lX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcyIsInRvX3Byb2MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiRW51bWVyYXRvciIsImVxdWFsPyIsImV4aXQiLCJzdGF0dXMiLCJlbXB0eT8iLCJwb3AiLCJjYWxsIiwiSW50ZWdlciIsImV4dGVuZCIsIlR5cGVFcnJvciIsImFwcGVuZF9mZWF0dXJlcyIsImV4dGVuZF9vYmplY3QiLCJleHRlbmRlZCIsImdldHMiLCIkc3RkaW4iLCJoYXNoIiwiX19pZF9fIiwiaW5zcGVjdCIsIml2cyIsImlkIiwiaW5jbHVkZT8iLCJwdXNoZWQiLCJlYWNoIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiYmxvY2sgaW4gaW5zcGVjdCIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJpdmFyIiwiaW5zdGFuY2VfdmFyaWFibGVfZ2V0IiwiKyIsInRvX3MiLCIxNiIsIlN0YW5kYXJkRXJyb3IiLCJlIiwiaW5zdGFuY2Vfb2Y/Iiwia2xhc3MiLCJpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyIsImluc3RhbmNlX3ZhcmlhYmxlX25hbWUhIiwiaW5zdGFuY2VfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJiYXNlIiwiRmxvYXREb21haW5FcnJvciIsInJlc3BvbmRfdG8/IiwidG9faW50IiwiY29lcmNlX3RvISIsIkZsb2F0IiwiSGFzaCIsImFyZyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJTdHJpbmciLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiYmxvY2sgaW4gbG9vcCIsImJsb2NrICgyIGxldmVscykgaW4gbG9vcCIsIkZsb2F0OjpJTkZJTklUWSIsIlN0b3BJdGVyYXRpb24iLCJyZXN1bHQiLCJwcmludGYiLCJhbnk/IiwicHJpbnQiLCJmb3JtYXQiLCJwcm9jIiwicHV0cyIsIiRzdGRvdXQiLCJzdHJzIiwicCIsImJsb2NrIGluIHAiLCJibG9jayAoMiBsZXZlbHMpIGluIHAiLCI8PSIsIltdIiwiMCIsInJlYWRsaW5lIiwid2FybiIsInVwbGV2ZWwiLCI8IiwibG9jYXRpb24iLCJmaXJzdCIsImJsb2NrIGluIHdhcm4iLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB3YXJuIiwiJFZFUkJPU0UiLCIkc3RkZXJyIiwiZXhjZXB0aW9uIiwic3RyaW5nIiwiYmFja3RyYWNlIiwiJCEiLCJSdW50aW1lRXJyb3IiLCJ0b19zdHIiLCIkQCIsInJhbmQiLCJtYXgiLCJSYW5kb206OkRFRkFVTFQiLCJSYW5kb20iLCJpbmNsdWRlX2FsbCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtZXRob2RfbmFtZSIsInByaXN0aW5lIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCJ0cnlfY29udmVydCEiLCJGaWxlIiwiZXhwYW5kX3BhdGgiLCJqb2luIiwicmVxdWlyZV90cmVlIiwicGF0aCIsInN0YXJ0X3dpdGg/IiwiYXV0b2xvYWQiLCJzbGVlcCIsInNlY29uZHMiLCJzcmFuZCIsInNlZWQiLCJuZXdfc2VlZCIsInN0ciIsInRhcCIsImNhdGNoIiwidGFnIiwiT2JqZWN0IiwiVW5jYXVnaHRUaHJvd0Vycm9yIiwidGhyb3ciLCJvcGVuIiwieWllbGRfc2VsZiIsImJsb2NrIGluIHlpZWxkX3NlbGYiLCI8Y2xhc3M6T2JqZWN0PiIsImluY2x1ZGUiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUM7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLGtCQUFBQSxZ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UEE7RUEreEJBRCxPQUFBZ007RUFBQUE7Ozs7SUFJR0E7SUFDREEsT0FBQTNMLElBQUE0TCxTQUFBQSxDQUFRbEwsT0FBUmtMO0VBTEZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFseUJBaE07In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMDE1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tb2R1bGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgY29uc3Rfc2V0LCBPYmplY3QsIHJldHVybl9pdmFyLCBhc3NpZ25faXZhciwgaXZhciwgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemUsIHByb3BcblxuY2xhc3MgOjpNb2R1bGVcbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuaWwsIGZ1bmN0aW9uKCl7fSk7XG4gICAgICAvLyBMaW5rIHRoZSBwcm90b3R5cGUgb2YgTW9kdWxlIHN1YmNsYXNzZXNcbiAgICAgIGlmIChzZWxmICE9PSBPcGFsLk1vZHVsZSkgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1vZHVsZSwgc2VsZi4kJHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgIG1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gIGVuZFxuXG4gIGRlZiA9PT0ob2JqZWN0KVxuICAgIHJldHVybiBmYWxzZSBpZiBgb2JqZWN0ID09IG51bGxgXG5cbiAgICBgT3BhbC5pc19hKG9iamVjdCwgc2VsZilgXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIHVubGVzcyA6Ok1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgIyBjbGFzcyBjYW5ub3QgYmUgYSBkZXNjZW5kYW50IG9mIGl0c2VsZlxuICAgICV4e1xuICAgICAgdmFyIHdvcmtpbmcgPSBzZWxmLFxuICAgICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgICBpLCBsZW5ndGg7XG5cbiAgICAgIGlmICh3b3JraW5nID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvdGhlciksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmIDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICBvdGhlciA8IHNlbGZcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxuICAgICAgcmV0dXJuIG5pbFxuICAgIGVuZFxuXG4gICAgbHQgPSBzZWxmIDwgb3RoZXJcbiAgICByZXR1cm4gbmlsIGlmIGx0Lm5pbD9cbiAgICBsdCA/IC0xIDogMVxuICBlbmRcblxuICBkZWYgYWxpYXNfbWV0aG9kKG5ld25hbWUsIG9sZG5hbWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBuZXduYW1lID0gYCRjb2VyY2VfdG8obmV3bmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcbiAgICBvbGRuYW1lID0gYCRjb2VyY2VfdG8ob2xkbmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcbiAgICBgT3BhbC5hbGlhcyhzZWxmLCBuZXduYW1lLCBvbGRuYW1lKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX25hdGl2ZShtaWQsIGpzaWQgPSBtaWQpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBgT3BhbC5hbGlhc19uYXRpdmUoc2VsZiwgbWlkLCBqc2lkKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFuY2VzdG9yc1xuICAgIGBPcGFsLmFuY2VzdG9ycyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFwcGVuZF9mZWF0dXJlcyhpbmNsdWRlcilcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhpbmNsdWRlcilgXG5cbiAgICBgT3BhbC5hcHBlbmRfZmVhdHVyZXMoc2VsZiwgaW5jbHVkZXIpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGF0dHJfYWNjZXNzb3IoKm5hbWVzKVxuICAgIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICBhdHRyX3dyaXRlcigqbmFtZXMpXG4gIGVuZFxuXG4gIGRlZiBhdHRyKCphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgKGFyZ3NbMV0gPT09IHRydWUgfHwgYXJnc1sxXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICN7d2FybiAnb3B0aW9uYWwgYm9vbGVhbiBhcmd1bWVudCBpcyBvYnNvbGV0ZWQnLCB1cGxldmVsOiAxfVxuXG4gICAgICAgIGFyZ3NbMV0gPyAje2F0dHJfYWNjZXNzb3IoYGFyZ3NbMF1gKX0gOiAje2F0dHJfcmVhZGVyKGBhcmdzWzBdYCl9O1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJfcmVhZGVyKCphcmdzKVxuICBlbmRcblxuICBkZWYgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXG4gICAgICAgICAgICBpZCAgID0gJyQnICsgbmFtZSxcbiAgICAgICAgICAgIGl2YXIgPSAkaXZhcihuYW1lKTtcblxuICAgICAgICB2YXIgYm9keSA9ICRyZXR1cm5faXZhcihpdmFyKTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcbiAgICAgICAgT3BhbC5wcm9wKHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDA7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUgKyAnPScsXG4gICAgICAgICAgICBpdmFyID0gJGl2YXIobmFtZSk7XG5cbiAgICAgICAgdmFyIGJvZHkgPSAkYXNzaWduX2l2YXIoaXZhcilcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtbJ3JlcSddXTtcbiAgICAgICAgYm9keS4kJGFyaXR5ID0gMTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcbiAgICAgICAgT3BhbC5wcm9wKHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZChjb25zdCwgcGF0aClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmICghI3tPcGFsLmNvbnN0X25hbWU/KGNvbnN0KX0pIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCJhdXRvbG9hZCBtdXN0IGJlIGNvbnN0YW50IG5hbWU6ICN7Y29uc3R9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoID09IFwiXCIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdlbXB0eSBmaWxlIG5hbWUnfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuJCRjb25zdC5oYXNPd25Qcm9wZXJ0eSgje2NvbnN0fSkpIHtcbiAgICAgICAgaWYgKCFzZWxmLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgICBzZWxmLiQkYXV0b2xvYWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgICAgICAgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSA9IHsgcGF0aDogI3twYXRofSwgbG9hZGVkOiBmYWxzZSwgcmVxdWlyZWQ6IGZhbHNlLCBzdWNjZXNzOiBmYWxzZSwgZXhjZXB0aW9uOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZD8oY29uc3QpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGF1dG9sb2FkICYmIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gJiYgIXNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0ucmVxdWlyZWQgJiYgIXNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0uc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XS5wYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5jZXN0b3JzID0gc2VsZi4kYW5jZXN0b3JzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkICYmIGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XSAmJiAhYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnJlcXVpcmVkICYmICFhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0uc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0ucGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZXNcbiAgICBgT2JqZWN0LmtleXMoT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0KHNlbGYsIG5hbWUsIGZhbHNlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKS5oYXNPd25Qcm9wZXJ0eShuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jbGFzc192YXJpYWJsZShuYW1lKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAoT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICBkZWxldGUgc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImNhbm5vdCByZW1vdmUgI3tuYW1lfSBmb3IgI3tzZWxmfVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0YW50cyhpbmhlcml0ID0gdHJ1ZSlcbiAgICBgT3BhbC5jb25zdGFudHMoc2VsZiwgaW5oZXJpdClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0YW50cyhpbmhlcml0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgbmVzdGluZyA9IChzZWxmLiQkbmVzdGluZyB8fCBbXSkuY29uY2F0KCRPYmplY3QpLFxuICAgICAgICAgICAgY29uc3RhbnQsIGNvbnN0YW50cyA9IHt9LFxuICAgICAgICAgICAgaSwgaWk7XG5cbiAgICAgICAgZm9yKGkgPSAwLCBpaSA9IG5lc3RpbmcubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGZvciAoY29uc3RhbnQgaW4gbmVzdGluZ1tpXS4kJGNvbnN0KSB7XG4gICAgICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbnN0YW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5jb25zdGFudHMoc2VsZiwgaW5oZXJpdClcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5lc3RpbmdcbiAgICBgc2VsZi4kJG5lc3RpbmcgfHwgW11gXG4gIGVuZFxuXG4gICMgY2hlY2sgZm9yIGNvbnN0YW50IHdpdGhpbiBjdXJyZW50IHNjb3BlXG4gICMgaWYgaW5oZXJpdCBpcyB0cnVlIG9yIHNlbGYgaXMgT2JqZWN0LCB3aWxsIGFsc28gY2hlY2sgYW5jZXN0b3JzXG4gIGRlZiBjb25zdF9kZWZpbmVkPyhuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IDo6T3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtzZWxmXSwgbW9kdWxlX2NvbnN0YW50cywgaSwgaWk7XG5cbiAgICAgIC8vIEFkZCB1cCBhbmNlc3RvcnMgaWYgaW5oZXJpdCBpcyB0cnVlXG4gICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoc2VsZikpO1xuXG4gICAgICAgIC8vIEFkZCBPYmplY3QncyBhbmNlc3RvcnMgaWYgaXQncyBhIG1vZHVsZSDigJMgbW9kdWxlcyBoYXZlIG5vIGFuY2VzdG9ycyBvdGhlcndpc2VcbiAgICAgICAgaWYgKHNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoWyRPYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoJE9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgICAgIGlmIChtb2R1bGUuJCRjb25zdFsje25hbWV9XSAhPSBudWxsKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtb2R1bGUuJCRhdXRvbG9hZCAmJlxuICAgICAgICAgIG1vZHVsZS4kJGF1dG9sb2FkWyN7bmFtZX1dICYmXG4gICAgICAgICAgIW1vZHVsZS4kJGF1dG9sb2FkWyN7bmFtZX1dLnJlcXVpcmVkICYmXG4gICAgICAgICAgIW1vZHVsZS4kJGF1dG9sb2FkWyN7bmFtZX1dLnN1Y2Nlc3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X2dldChuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCc6OicpID09PSAwICYmIG5hbWUgIT09ICc6Oicpe1xuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgbmFtZS5pbmRleE9mKCc6OicpICE9IC0xICYmIG5hbWUgIT0gJzo6J2BcbiAgICAgIHJldHVybiBuYW1lLnNwbGl0KCc6OicpLmluamVjdChzZWxmKSB7IHxvLCBjfCBvLmNvbnN0X2dldChjKSB9XG4gICAgZW5kXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUFxuXG4gICAgJXh7XG4gICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICByZXR1cm4gT3BhbC4kJChbc2VsZl0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X2xvY2FsKHNlbGYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X21pc3NpbmcobmFtZSlcbiAgICBmdWxsX2NvbnN0X25hbWUgPSBzZWxmID09IDo6T2JqZWN0ID8gbmFtZSA6IFwiI3tzZWxmfTo6I3tuYW1lfVwiXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNvbnN0YW50ICN7ZnVsbF9jb25zdF9uYW1lfVwiLCBuYW1lKVxuICBlbmRcblxuICBkZWYgY29uc3Rfc2V0KG5hbWUsIHZhbHVlKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgaWYgbmFtZSAhfiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIHx8IG5hbWUuc3RhcnRfd2l0aD8oJzo6JylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKVxuICAgIGVuZFxuXG4gICAgYCRjb25zdF9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxuXG4gICAgdmFsdWVcbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19jb25zdGFudChjb25zdF9uYW1lKVxuICBlbmRcblxuICBkZWYgZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsKVxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jayd9XG4gICAgfVxuXG4gICAgYmxvY2sgfHw9IGNhc2UgbWV0aG9kXG4gICAgICAgICAgICAgIHdoZW4gOjpQcm9jXG4gICAgICAgICAgICAgICAgbWV0aG9kXG5cbiAgICAgICAgICAgICAgd2hlbiA6Ok1ldGhvZFxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXG5cbiAgICAgICAgICAgICAgd2hlbiA6OlVuYm91bmRNZXRob2RcbiAgICAgICAgICAgICAgICAtPigqYXJncykge1xuICAgICAgICAgICAgICAgICAgYm91bmQgPSBtZXRob2QuYmluZChzZWxmKVxuICAgICAgICAgICAgICAgICAgYm91bmQuY2FsbCgqYXJncylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tibG9jay5jbGFzc30gKGV4cGVjdGVkIFByb2MvTWV0aG9kKVwiXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mKFByb3h5KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG1ldGEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICAgICAgYmxvY2suJCRwcm94eV90YXJnZXQgPSBibG9ja1xuICAgICAgICBibG9jayA9IG5ldyBQcm94eShibG9jaywge1xuICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbih0YXJnZXQsIHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBvbGRfbmFtZSA9IHRhcmdldC4kJGpzaWRcbiAgICAgICAgICAgIHRhcmdldC4kJGpzaWQgPSBuYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICBpZiAoZSA9PT0gdGFyZ2V0LiQkYnJrIHx8IGUgPT09IHRhcmdldC4kJHJldCkgcmV0dXJuIGUuJHY7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuJCRqc2lkID0gb2xkX25hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkanNpZCAgICAgICAgPSBuYW1lO1xuICAgICAgYmxvY2suJCRzICAgICAgICAgICA9IG51bGw7XG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XG4gICAgICBibG9jay4kJGRlZmluZV9tZXRoID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIE9wYWwuZGVmbihzZWxmLCAnJCcgKyBuYW1lLCBibG9jayk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgIyBTcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGZyZWV6ZSwgYmVjYXVzZSB0aGUgJCRiYXNlX21vZHVsZSBwcm9wZXJ0eSBuZWVkcyB0byBiZVxuICAgICMgYWNjZXNzaWJsZSBkZXNwaXRlIHRoZSBmcm96ZW4gc3RhdHVzXG5cbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmICghc2VsZi5oYXNPd25Qcm9wZXJ0eSgnJCRiYXNlX21vZHVsZScpKSB7ICRwcm9wKHNlbGYsICckJGJhc2VfbW9kdWxlJywgbnVsbCk7IH1cblxuICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVtb3ZlX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmICghKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiIHx8IG5hbWUuJCRpc19zdHJpbmcpKSB7XG4gICAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje25hbWV9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cbiAgICAgICAgfVxuICAgICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAgIE9wYWwucmRlZihzZWxmLCBcIiRcIiArIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzcz9cbiAgICBgISFzZWxmLiQkaXNfc2luZ2xldG9uYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZSgqbW9kcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgc2VsZn07XG4gICAgICAgICN7YG1vZGAuaW5jbHVkZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5jbHVkZWRfbW9kdWxlc1xuICAgIGBPcGFsLmluY2x1ZGVkX21vZHVsZXMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhtb2QpXG4gICAgJXh7XG4gICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpaSwgbW9kMiwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kMiA9IGFuY2VzdG9yc1tpXTtcbiAgICAgICAgaWYgKG1vZDIgPT09IG1vZCAmJiBtb2QyICE9PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5uYW1lfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6OlVuYm91bmRNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZHMoaW5jbHVkZV9zdXBlciA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2luY2x1ZGVfc3VwZXJ9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZWQobW9kKVxuICBlbmRcblxuICBkZWYgZXh0ZW5kZWQobW9kKVxuICBlbmRcblxuICBkZWYgZXh0ZW5kX29iamVjdChvYmplY3QpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Mob2JqZWN0KWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7bmV3IEZ1bmN0aW9uKFwiT3BhbCxzZWxmXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQpKE9wYWwsIHNlbGYpfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICBOT1RFOklmIHlvdSB3YW50IHRvIGVuYWJsZSBwYXNzaW5nIGEgU3RyaW5nIGFyZ3VtZW50IHBsZWFzZSBhZGQgXFxcInJlcXVpcmUgJ29wYWwtcGFyc2VyJ1xcXCIgdG8geW91ciBzY3JpcHRcXG5cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIFtzZWxmXSk7XG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfZGVmaW5lZD8obWV0aG9kKVxuICAgICV4e1xuICAgICAgdmFyIGJvZHkgPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG1ldGhvZF07XG4gICAgICByZXR1cm4gKCEhYm9keSkgJiYgIWJvZHkuJCRzdHViO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9mdW5jdGlvbigqbWV0aG9kcylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRoID0gbWV0aG9kc1tpXSxcbiAgICAgICAgICAgICAgaWQgICA9ICckJyArIG1ldGgsXG4gICAgICAgICAgICAgIGZ1bmMgPSBzZWxmLiQkcHJvdG90eXBlW2lkXTtcblxuICAgICAgICAgIE9wYWwuZGVmcyhzZWxmLCBpZCwgZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZHMubGVuZ3RoID09PSAxID8gbWV0aG9kc1swXSA6IG1ldGhvZHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkZnVsbF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGJhc2UgPSBzZWxmO1xuXG4gICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAvLyBHaXZlIHVwIGlmIGFueSBvZiB0aGUgYW5jZXN0b3JzIGlzIHVubmFtZWRcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcblxuICAgICAgICByZXN1bHQudW5zaGlmdChiYXNlLiQkbmFtZSk7XG5cbiAgICAgICAgYmFzZSA9IGJhc2UuJCRiYXNlX21vZHVsZTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gJE9iamVjdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lID0gcmVzdWx0LmpvaW4oJzo6Jyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIGlmIChtb2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kX2ZlYXR1cmVzKHByZXBlbmRlcilcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3MocHJlcGVuZGVyKTtcblxuICAgICAgaWYgKCFzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3NlbGYuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgfVxuXG4gICAgICBPcGFsLnByZXBlbmRfZmVhdHVyZXMoc2VsZiwgcHJlcGVuZGVyKVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kZWQobW9kKVxuICBlbmRcblxuICBkZWYgcmVtb3ZlX2NvbnN0KG5hbWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBgT3BhbC5jb25zdF9yZW1vdmUoc2VsZiwgbmFtZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYE9wYWwuTW9kdWxlLiRuYW1lLmNhbGwoc2VsZilgIHx8IFwiIzwje2BzZWxmLiQkaXNfbW9kdWxlID8gJ01vZHVsZScgOiAnQ2xhc3MnYH06MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIHVuZGVmX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmICghKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiIHx8IG5hbWUuJCRpc19zdHJpbmcpKSB7XG4gICAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje25hbWV9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cbiAgICAgICAgfVxuICAgICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAgIE9wYWwudWRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBjb25zdHMgPSBjb25zdGFudHNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcgJiYgbmFtZSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiAhI3tjb25zdHMuaW5jbHVkZT8oYG5hbWVgKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzdXBlclxuICAgIGNvcHkuY29weV9jbGFzc192YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmNvcHlfY29uc3RhbnRzKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY29weV9jbGFzc192YXJpYWJsZXMob3RoZXIpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyLiQkY3ZhcnMpIHtcbiAgICAgICAgc2VsZi4kJGN2YXJzW25hbWVdID0gb3RoZXIuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NvbnN0YW50cyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBuYW1lLCBvdGhlcl9jb25zdGFudHMgPSBvdGhlci4kJGNvbnN0O1xuXG4gICAgICBmb3IgKG5hbWUgaW4gb3RoZXJfY29uc3RhbnRzKSB7XG4gICAgICAgICRjb25zdF9zZXQoc2VsZiwgbmFtZSwgb3RoZXJfY29uc3RhbnRzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWZpbmUoa2xhc3MsICZibG9jaylcbiAgICByZWZpbmVtZW50X21vZHVsZSwgbSwga2xhc3NfaWQgPSBzZWxmLCBuaWwsIG5pbFxuICAgICV4e1xuICAgICAga2xhc3NfaWQgPSBPcGFsLmlkKGtsYXNzKTtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi4kJHJlZmluZV9tb2R1bGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNlbGYuJCRyZWZpbmVfbW9kdWxlcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxmLiQkcmVmaW5lX21vZHVsZXNba2xhc3NfaWRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG0gPSBzZWxmLiQkcmVmaW5lX21vZHVsZXNba2xhc3NfaWRdID0gI3s6OlJlZmluZW1lbnQubmV3fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXTtcbiAgICAgIH1cbiAgICAgIG0ucmVmaW5lbWVudF9tb2R1bGUgPSByZWZpbmVtZW50X21vZHVsZVxuICAgICAgbS5yZWZpbmVkX2NsYXNzID0ga2xhc3NcbiAgICB9XG4gICAgbS5jbGFzc19leGVjKCZibG9jaylcbiAgICBtXG4gIGVuZFxuXG4gICMgQ29tcGlsZXIgb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG4gIGRlZiB1c2luZyhtb2QpXG4gICAgOjpLZXJuZWwucmFpc2UgJ01vZHVsZSN1c2luZyBpcyBub3QgcGVybWl0dGVkIGluIG1ldGhvZHMnXG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V2YWwgbW9kdWxlX2V2YWxcbiAgYWxpYXMgY2xhc3NfZXhlYyBtb2R1bGVfZXhlY1xuICBhbGlhcyBpbnNwZWN0IHRvX3NcbmVuZFxuXG5jbGFzcyA6OlJlZmluZW1lbnQgPCA6Ok1vZHVsZVxuICBkZWYgaW5zcGVjdFxuICAgIGlmIEByZWZpbmVtZW50X21vZHVsZVxuICAgICAgXCIjPHJlZmluZW1lbnQ6I3tAcmVmaW5lZF9jbGFzcy5pbnNwZWN0fUAje0ByZWZpbmVtZW50X21vZHVsZS5pbnNwZWN0fT5cIlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpNb2R1bGU+IiwiYWxsb2NhdGUiLCJzZWxmIiwiaW5pdGlhbGl6ZSIsImJsb2NrX2dpdmVuPyIsIm1vZHVsZV9ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiPT09Iiwib2JqZWN0IiwiPCIsIm90aGVyIiwiTW9kdWxlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCI8PSIsIiRyZXRfb3JfMSIsImVxdWFsPyIsIj4iLCI+PSIsIjw9PiIsImx0IiwibmlsPyIsIi0xIiwiMSIsImFsaWFzX21ldGhvZCIsIm5ld25hbWUiLCJvbGRuYW1lIiwiU3RyaW5nIiwiYWxpYXNfbmF0aXZlIiwibWlkIiwianNpZCIsImFuY2VzdG9ycyIsImFwcGVuZF9mZWF0dXJlcyIsImluY2x1ZGVyIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwibmFtZXMiLCJhdHRyX3dyaXRlciIsImF0dHIiLCJ3YXJuIiwiYXJncyIsImF1dG9sb2FkIiwiY29uc3QkIiwicGF0aCIsIk9wYWwiLCJjb25zdF9uYW1lPyIsIk5hbWVFcnJvciIsIkFyZ3VtZW50RXJyb3IiLCJhdXRvbG9hZD8iLCJjbGFzc192YXJpYWJsZXMiLCJjbGFzc192YXJpYWJsZV9nZXQiLCJuYW1lIiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjbGFzc192YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsImNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/IiwicmVtb3ZlX2NsYXNzX3ZhcmlhYmxlIiwiY29uc3RhbnRzIiwiaW5oZXJpdCIsIm5lc3RpbmciLCJjb25zdF9kZWZpbmVkPyIsImNvbnN0X25hbWUhIiwiPX4iLCJPcGFsOjpDT05TVF9OQU1FX1JFR0VYUCIsIm5ldyIsImNvbnN0X2dldCIsImluamVjdCIsInNwbGl0IiwiYmxvY2sgaW4gY29uc3RfZ2V0IiwibyIsImMiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbnN0X2dldCIsImNvbnN0X21pc3NpbmciLCJmdWxsX2NvbnN0X25hbWUiLCJPYmplY3QiLCJjb25zdF9zZXQiLCIhfiIsInN0YXJ0X3dpdGg/IiwicHVibGljX2NvbnN0YW50IiwiZGVmaW5lX21ldGhvZCIsIm1ldGhvZCIsIlByb2MiLCIkcmV0X29yXzIiLCJNZXRob2QiLCJVbmJvdW5kTWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX21ldGhvZCIsImJsb2NrICgyIGxldmVscykgaW4gZGVmaW5lX21ldGhvZCIsImJvdW5kIiwiYmluZCIsImNhbGwiLCJjbGFzcyIsImZyZWV6ZSIsImZyb3plbj8iLCJyZW1vdmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzPyIsImluY2x1ZGUiLCJpbmNsdWRlZCIsImluY2x1ZGVkX21vZHVsZXMiLCJpbmNsdWRlPyIsIm1vZCIsImluc3RhbmNlX21ldGhvZCIsImluc3RhbmNlX21ldGhvZHMiLCJpbmNsdWRlX3N1cGVyIiwiZXh0ZW5kZWQiLCJleHRlbmRfb2JqZWN0IiwibWV0aG9kX2FkZGVkIiwibWV0aG9kX3JlbW92ZWQiLCJtZXRob2RfdW5kZWZpbmVkIiwiMyIsImNvdmVyPyIsInNpemUiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiY29tcGlsZSIsInByb2MiLCJibG9jayBpbiBtb2R1bGVfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gbW9kdWxlX2V2YWwiLCJhbnk/IiwibW9kdWxlX2V4ZWMiLCJMb2NhbEp1bXBFcnJvciIsIm1ldGhvZF9kZWZpbmVkPyIsIm1vZHVsZV9mdW5jdGlvbiIsInByZXBlbmQiLCJwcmVwZW5kX2ZlYXR1cmVzIiwicHJlcGVuZGVkIiwicHJlcGVuZGVyIiwicmVtb3ZlX2NvbnN0IiwidG9fcyIsIl9faWRfXyIsIjE2IiwidW5kZWZfbWV0aG9kIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiY29uc3RzIiwiZHVwIiwiY29weSIsImNvcHlfY2xhc3NfdmFyaWFibGVzIiwiY29weV9jb25zdGFudHMiLCJyZWZpbmUiLCJrbGFzcyIsInJlZmluZW1lbnRfbW9kdWxlIiwibSIsImtsYXNzX2lkIiwiUmVmaW5lbWVudCIsImNsYXNzX2V4ZWMiLCJ1c2luZyIsIjxjbGFzczpSZWZpbmVtZW50PiIsImluc3BlY3QiLCJAcmVmaW5lbWVudF9tb2R1bGUiLCJAcmVmaW5lZF9jbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxNQUFJQyxJQUFKRCxlQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQSxHQUFBQTs7QUFTQUUsSUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFLElBQXVCQyxlQUF2QjtRQUFBRCxPQUFBRSxNQUFBSCxJQUFBRyxlQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRjtNQUFBO1FBYkpGLE9BQUE7TUFhSTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUssSUFBQUEsbUJBQUFBLDZCQUFRQyxNQUFSRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFpQkEsY0FBakIsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBQSxPQUFDQSx1QkFB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QSxDQUFBQSxDQUE5QixDQUFBLEdBQXVDQSxHQUF2QyxHQUFBLENBQTBDQyxzQkFBa0JELFNBQUFBLENBQUFBLENBQTVELENBQUEsR0FBcUVBO01BRHZFO1FBR0VBLE9BQUEsT0FBQXhKLElBQUEsRUFBQSxvREFBQSxXQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7TUFIRjtJQURGd0osQ0FBQUEsR0FBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFxQjdJLE9BQXJCNkk7QUE3d0JBMUo7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MDAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL3lpZWxkZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRW51bWVyYXRvclxuICBjbGFzcyBZaWVsZGVyXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICAgICMgcnVib2NvcDpkaXNhYmxlIExpbnQvVm9pZFxuICAgICAgc2VsZlxuICAgICAgIyBydWJvY29wOmVuYWJsZSBMaW50L1ZvaWRcbiAgICBlbmRcblxuICAgIGRlZiB5aWVsZCgqdmFsdWVzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKCN7QGJsb2NrfSwgdmFsdWVzKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuJHRocm93ZXJfdHlwZSA9PSBcImJyZWFrXCIpIHtcbiAgICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiA8PCh2YWx1ZSlcbiAgICAgIHNlbGYueWllbGQodmFsdWUpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiB0b19wcm9jXG4gICAgICBwcm9jIGRvIHwqdmFsdWVzfFxuICAgICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOllpZWxkZXI+IiwiaW5pdGlhbGl6ZSIsIkBibG9jayIsImJsb2NrIiwic2VsZiIsInlpZWxkIiwiPDwiLCJ2YWx1ZSIsInRvX3Byb2MiLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInZhbHVlcyJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDRUMsYUFBU0M7UUFFVEYsT0FBQUc7TUFIRkgsQ0FBQUEsR0FBQUE7O0FBT0FJLE1BQUFBLHFCQUFBQSwwQkFUSixFQVNJQTtBQUFBQSxRQUFBQTs7O1FBVEo7UUFTYzs7QUFFZEEsZ0NBQWtDSCxVQUFPRzs7QUFFekNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtNQVRJQSxDQUFBQSxJQUFBQTs7QUFZQUMsTUFBQUEsa0JBQUFBLDJCQUFPQyxLQUFQRDtBQUFBQSxRQUFBQTs7O1FBQ0VGLElBQUlDLE9BQUFBLENBQU9FLEtBQVBGO1FBRUpDLE9BQUFGO01BSEZFLENBQUFBLEdBQUFBO01BTUFOLE9BQUFRLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE1BQUFMLElBQUFLLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLGFBNUJOLEVBNEJNQSxFQUFBQzs7O1VBNUJOO1VBNEJlO1VBQ1BBLE9BQUlOLE1BQUpELElBQUlDLFNBQUFBLEVBQU8sTUFBQ08sTUFBRCxDQUFQUCxFQUROSyxDQUFBQSxHQUFBQSxzQkFBQUEsQ0FBQUQ7TUFERkQsQ0FBQUEsR0FBQUE7SUExQkZSLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDA2NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9jaGFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGRlbnlfZnJvemVuX2FjY2Vzc1xuXG5jbGFzcyA6OkVudW1lcmF0b3JcbiAgY2xhc3Mgc2VsZjo6Q2hhaW4gPCBzZWxmXG4gICAgZGVmIGluaXRpYWxpemUoKmVudW1zKVxuICAgICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICAgIEBlbnVtcyA9IGVudW1zXG4gICAgICBAaXRlcmF0ZWQgPSBbXVxuICAgICAgQG9iamVjdCA9IHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaCwgKmFyZ3MpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICAgQGVudW1zLmVhY2ggZG8gfGVudW18XG4gICAgICAgIEBpdGVyYXRlZCA8PCBlbnVtXG4gICAgICAgIGVudW0uZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgZW5kXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBzaXplKCphcmdzKVxuICAgICAgYWNjdW0gPSAwXG4gICAgICBAZW51bXMuZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgc2l6ZSA9IGVudW0uc2l6ZSgqYXJncylcbiAgICAgICAgcmV0dXJuIHNpemUgaWYgW25pbCwgOjpGbG9hdDo6SU5GSU5JVFldLmluY2x1ZGU/IHNpemVcbiAgICAgICAgYWNjdW0gKz0gc2l6ZVxuICAgICAgZW5kXG4gICAgICBhY2N1bVxuICAgIGVuZFxuXG4gICAgZGVmIHJld2luZFxuICAgICAgQGl0ZXJhdGVkLnJldmVyc2VfZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgZW51bS5yZXdpbmQgaWYgZW51bS5yZXNwb25kX3RvPyA6cmV3aW5kXG4gICAgICBlbmRcbiAgICAgIEBpdGVyYXRlZCA9IFtdXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgXCIjPEVudW1lcmF0b3I6OkNoYWluOiAje0BlbnVtcy5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6Q2hhaW4+IiwiaW5pdGlhbGl6ZSIsIkBlbnVtcyIsImVudW1zIiwiQGl0ZXJhdGVkIiwiQG9iamVjdCIsInNlbGYiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwidG9fZW51bSIsImFyZ3MiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwic2l6ZSIsImVudW0kIiwiPDwiLCJibG9jayIsInRvX3Byb2MiLCJhY2N1bSIsIjAiLCJibG9jayBpbiBzaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzaXplIiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJpbmNsdWRlPyIsIisiLCJyZXdpbmQiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXdpbmQiLCJyZXNwb25kX3RvPyIsImJsb2NrICgyIGxldmVscykgaW4gcmV3aW5kIiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFKSixFQUlJQTtBQUFBQSxRQUFBQTs7O1FBSko7UUFJbUI7UUFDWkE7UUFFREMsYUFBU0M7UUFDVEMsZ0JBQVk7UUFDWkgsT0FBQUksQ0FBQUEsY0FBVUMsSUFBVkQ7TUFMRkosQ0FBQUEsSUFBQUE7O0FBUUFNLE1BQUFBLG9CQUFBQSxnQkFaSixFQVlJQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQVpKO1FBWWE7UUFDUCxLQUE2Q0MsZUFBN0M7VUFBQSxPQUFPQyxNQUFBSCxJQUFBRyxXQUFBQSxFQUFBLENBQVEsTUFBUixDQUFBLFFBQWUsTUFBQ0MsSUFBRCxDQUFmLENBQUFELEVBQUFFLGFBQUFBLEVBQUFDOztZQUF3QkEsT0FBQU4sSUFBQU8sTUFBQUEsQ0FBQUEsQ0FBeEJGLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRjtRQUFQO1FBRU1GLE1BQU5MLFVBQU1LLFFBQUFBLEVBQUFBLEVBQUFBLEVBQU5JLGFBQWdCRyxLQUFoQkgsRUFBQUM7QUFBQUE7OztVQUFnQjtVQUNkUixhQUFVVyxPQUFBQSxDQUFHRCxLQUFIQztVQUNWSCxPQUFJTCxNQUFKTyxLQUFJUCxRQUFBQSxFQUFNLE1BQUNHLElBQUQsQ0FBTkgsRUFBY1MsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBYlYsRUFGTkksQ0FBQUEsR0FBQUEscUJBQUFBLENBQU1KO1FBS05BLE9BQUFEO01BUkZDLENBQUFBLElBQUFBOztBQVdBTSxNQUFBQSxvQkFBQUEsZ0JBdkJKLEVBdUJJQSxHQUFBQSxNQUFBQSxJQUFBQSw4QkFBQUE7QUFBQUEsUUFBQUE7OztRQXZCSjtRQXVCYTtRQUNQSyxRQUFRQztRQUNGWixNQUFOTCxVQUFNSyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFOYSxhQUFnQk4sS0FBaEJNLEVBQUFDOzs7VUFBZ0I7VUFDZFIsT0FBV0EsTUFBSkMsS0FBSUQsUUFBQUEsRUFBTSxNQUFDSCxJQUFELENBQU5HO1VBQ1gsSUFBQSxRQUFlLENBQUMsR0FBRCxFQUFNUyxJQUFBQyxZQUFBRCxhQUFOLENBQXdCRSxhQUFBQSxDQUFVWCxJQUFWVyxDQUF2QyxDQUFBO1lBQUEsU0FBQSxRQUFPWCxJQUFQO1VBQUE7VUFDQVEsT0FBQUgsQ0FBQUEsUUFBTU8sU0FBTlAsS0FBTU8sRUFBR1osSUFBSFksQ0FBTlAsRUFIRkUsQ0FBQUEsR0FBQUEsNEJBQUFBLENBQU1iO1FBS05NLE9BQUFLLE1BUEZMO1VBQUFBO1VBQUFBO1FBQUFBO01BQUFBLENBQUFBLElBQUFBOztBQVVBYSxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDV0MsTUFBVHZCLGFBQVN1QixnQkFBQUEsRUFBQUEsRUFBQUEsRUFBVEMsYUFBMkJkLEtBQTNCYzs7VUFBMkI7VUFDekIsSUFBQSxRQUFlZCxLQUFJZSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFuQixDQUFBO1lBQUFDLE9BQUFoQixLQUFJWSxRQUFBQSxDQUFBQTtVQUFKO1lBbkNSSSxPQUFBO1VBbUNRLEVBREZGLENBQUFBLEdBQVNEO1FBR1R2QixnQkFBWTtRQUNac0IsT0FBQXBCO01BTEZvQixDQUFBQSxHQUFBQTtNQVFBMUIsT0FBQStCLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLHVCQUFELEdBQUEsQ0FBd0I3QixVQUFNNkIsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0E7TUFEekNBLENBQUFBLEdBQUFBO0lBdENGL0IsR0FBTU0sSUFBTk4sRUFBb0JNLElBQXBCTjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDE2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9sYXp5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGNsYXNzIHNlbGY6OkxhenkgPCBzZWxmXG4gICAgY2xhc3Mgc2VsZjo6U3RvcExhenlFcnJvciA8IDo6RXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBzZWxmLmZvcihvYmplY3QsICopXG4gICAgICBsYXp5ID0gc3VwZXJcbiAgICAgIGBsYXp5LmVudW1lcmF0b3IgPSBvYmplY3RgXG4gICAgICBsYXp5XG4gICAgZW5kXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShvYmplY3QsIHNpemUgPSBuaWwsICZibG9jaylcbiAgICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBuZXcgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIEBlbnVtZXJhdG9yID0gb2JqZWN0XG5cbiAgICAgIHN1cGVyIHNpemUgZG8gfHlpZWxkZXIsICplYWNoX2FyZ3N8XG4gICAgICAgIG9iamVjdC5lYWNoKCplYWNoX2FyZ3MpIGRvIHwqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCgje3lpZWxkZXJ9KTtcblxuICAgICAgICAgICAgJHlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIG5pbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbGF6eVxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdF9jb25jYXQoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAjezo6T3BhbC50cnlfY29udmVydCBgdmFsdWVgLCA6OkFycmF5LCA6dG9fYXJ5fTtcblxuICAgICAgICAgICAgaWYgKGFycmF5ID09PSBuaWwpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGB2YWx1ZWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICN7YHZhbHVlYC5lYWNoIHsgfHZ8IGVudW0ueWllbGQgdiB9fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3AobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiA6OkludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICBkcm9wcGVkID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgZHJvcHBlZCA8IG5cbiAgICAgICAgICBkcm9wcGVkICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3VjY2VlZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgICBzZWxmLmNsYXNzLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgZW5kXG5cbiAgICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBzZWxlY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICAgIGlmIGJsb2NrXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgJHlpZWxkMShibG9jaywgcGFyYW0pYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGBwYXJhbWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiByZWplY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZShuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBjdXJyZW50X3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgIHNldF9zaXplICAgICA9IGlmIDo6SW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHRha2VuID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgdGFrZW4gPCBuXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgICB0YWtlbiArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBTdG9wTGF6eUVycm9yfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGluc3BlY3RcbiAgICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0BlbnVtZXJhdG9yLmluc3BlY3R9PlwiXG4gICAgZW5kXG5cbiAgICBhbGlhcyBmb3JjZSB0b19hXG4gICAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG4gICAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuICAgIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOnNlbGY6Okxhenk+IiwiPGNsYXNzOnNlbGY6OlN0b3BMYXp5RXJyb3I+Iiwic2VsZiIsIkV4Y2VwdGlvbiIsImZvciIsIm9iamVjdCIsImxhenkiLCJpbml0aWFsaXplIiwic2l6ZSIsImJsb2NrX2dpdmVuPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIkBlbnVtZXJhdG9yIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsInlpZWxkZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJlYWNoIiwiZWFjaF9hcmdzIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiU3RvcExhenlFcnJvciIsImNvbGxlY3QiLCJibG9jayIsIm5ldyIsIkxhenkiLCJlbnVtZXJhdG9yX3NpemUiLCJibG9jayBpbiBjb2xsZWN0IiwiZW51bSQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJ5aWVsZCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwicmVzcG9uZF90bz8iLCJ2IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsIk9wYWwiLCJ0cnlfY29udmVydCIsIkFycmF5IiwiZHJvcCIsIm4iLCJJbnRlZ2VyIiwiPCIsIjAiLCJjdXJyZW50X3NpemUiLCJzZXRfc2l6ZSIsImRyb3BwZWQiLCJibG9jayBpbiBkcm9wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wIiwiKyIsIjEiLCJhcmdzIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJibG9jayBpbiBkcm9wX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wX3doaWxlIiwiZW51bV9mb3IiLCJjbGFzcyIsIm1ldGhvZCIsInRvX3Byb2MiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImdyZXAiLCJwYXR0ZXJuIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImRlc3RydWN0dXJlIiwiPT09IiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJ0YWtlIiwidGFrZW4iLCJibG9jayBpbiB0YWtlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCJpbnNwZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxPQUFNQyxJQUFORCxFQUE0QkUsZ0JBQTVCRjtNQUVBRyxNQUFJRixJQUFKRSxVQUFBQSxxQkFBYUMsTUFBRCxFQU5oQixFQU1JRDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBTko7UUFNeUI7UUFDbkJFLE9BQU8sT0FBQUosSUFBQSxFQUFBLGtEQUFBLE9BQUEsRUFBQSxDQUFBRyxNQUFBLENBQUEsUUFBQSxNQUFBLFNBQUEsQ0FBQSxDQUFBLEVBQUEsTUFBQTtRQUNORDtRQUNEQSxPQUFBRTtNQUhGRixDQUFBQSxJQUFBQTs7QUFNQUcsTUFBQUEsMEJBQUFBLHNCQUFlRixN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LGFBQU0sS0FBTixFQUFVLFNBQVY7TUFDQSxhQUFNLFFBQU4sRUFBYSxVQUFiO01BQ0EvRSxPQUFBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUEvT0ZBLEdBQU1FLElBQU5GLEVBQW1CRSxJQUFuQkY7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ1MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29wYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnb3BhbC9iYXNlJ1xuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9taW5pJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2tlcm5lbC9mb3JtYXQnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9lbmNvZGluZydcbjo6T2JqZWN0LmF1dG9sb2FkIDpNYXRoLCAnY29yZWxpYi9tYXRoJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb21wbGV4L2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6Q29tcGxleCwgJ2NvcmVsaWIvY29tcGxleCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYXRpb25hbCwgJ2NvcmVsaWIvcmF0aW9uYWwnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3RpbWUnXG46Ok9iamVjdC5hdXRvbG9hZCA6U3RydWN0LCAnY29yZWxpYi9zdHJ1Y3QnXG46Ok9iamVjdC5hdXRvbG9hZCA6RGlyLCAnY29yZWxpYi9kaXInXG46Ok9iamVjdC5hdXRvbG9hZCA6RmlsZSwgJ2NvcmVsaWIvZmlsZSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9wcm9jZXNzL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UHJvY2VzcywgJ2NvcmVsaWIvcHJvY2Vzcydcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYW5kb20sICdjb3JlbGliL3JhbmRvbSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi91bnN1cHBvcnRlZCdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9iaW5kaW5nJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9pcmInXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRix1QkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YseUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsTUFBbEIsRUFBeUJILGNBQWpCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxTQUFsQixFQUE0QkgsaUJBQXBCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRix1QkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxVQUFsQixFQUE2Qkgsa0JBQXJCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFFBQWxCLEVBQTJCSCxnQkFBbkJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsS0FBbEIsRUFBd0JILGFBQWhCRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFFUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUVSRixPQUFRQyxTQUFBQSxDQUFTRixxQkFBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLGFBQVRFO0FBdEJSRjs7QUFBQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTQ3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvbWluaSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG46Ok9iamVjdC5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkNvbXBsZXgsICdjb3JlbGliL2NvbXBsZXgnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xuOjpPYmplY3QuYXV0b2xvYWQgOkRpciwgJ2NvcmVsaWIvZGlyJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkZpbGUsICdjb3JlbGliL2ZpbGUnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2Vzcy9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlByb2Nlc3MsICdjb3JlbGliL3Byb2Nlc3MnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmFuZG9tLCAnY29yZWxpYi9yYW5kb20nXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmluZGluZydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaXJiJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHlCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsVUFBbEIsRUFBNkJILGtCQUFyQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFFUkYsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtBQXRCUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTczLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9hcHAvYXBwbGljYXRpb24uanMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSBcIm9wYWxcIlxuIyBVbmNvbW1lbnQgdGhlIGZvbGxvd2luZyB0byBwcmludCBvdXQgeW91J3JlIGhlbGxvLXdvcmxkIHdpdGggT3BhbDpcbiMgICBwdXRzIFwiaGVsbG8gd29ybGQhXCJcbiNcbiMgVGhlIGZvbGxvd2luZyB3aWxsIGFwcGVuZCBhIGhlbGxvLXdvcmxkIHRvIHlvdXIgPGJvZHk+IGVsZW1lbnQ6XG4jXG4jICAgcmVxdWlyZSBcIm5hdGl2ZVwiXG4jICAgJCRbOmRvY3VtZW50XS5hZGRFdmVudExpc3RlbmVyIDpET01Db250ZW50TG9hZGVkIGRvXG4jICAgICAkJFs6ZG9jdW1lbnRdWzpib2R5XVs6aW5uZXJIVE1MXSArPSAnPGgyPkhlbGxvIFdvcmxkITwvaDI+J1xuIyAgIGVuZFxuXG5Eb2N1bWVudC5yZWFkeT8gZG9cbiAgY3VycmVudF91cmwgPSBFbGVtZW50LmZpbmQoJy5sZWdpc2xhdGlvbl93ZWJzaXRlJykuYXR0cls6aHJlZl1cbiAgRWxlbWVudC5maW5kKCdMZWdpc2xhdGlvbldlYnNpdGUnKS5vbiA6Y2xpY2sgZG9cbiAgICBjdXJyZW50X3BhZ2VfdXJsID0gRWxlbWVudC5maW5kKCdMZWdpc2xhdGlvbldlYnNpdGUnKS5hdHRyWzpocmVmXVxuICAgIGlmIGN1cnJlbnRfcGFnZV91cmwgIT0gY3VycmVudF91cmxcbiAgICAgIEVsZW1lbnQuZmluZCgnY3VycmVudF9wYWdlJykuaHRtbCA9IGN1cnJlbnRfcGFnZV91cmxcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJzZWxmIiwicmVxdWlyZSIsInJlYWR5PyIsIkRvY3VtZW50IiwiYmxvY2sgaW4gPG1haW4+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8bWFpbj4iLCJjdXJyZW50X3VybCIsIkVsZW1lbnQiLCJmaW5kIiwiYXR0ciIsIltdIiwib24iLCJibG9jayAoMyBsZXZlbHMpIGluIDxtYWluPiIsImN1cnJlbnRfcGFnZV91cmwiLCJodG1sPSJdLCJtYXBwaW5ncyI6IkFBQUFBLDJCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLE1BQVJFO0VBV0FGLE9BQVFHLE1BQVJDLGNBQVFELFVBQUFBLEVBQUFBLEVBQUFBLEVBQVJFLGFBQUFBLEVBQUFDOzs7SUFDRUMsY0FBY0MsYUFBT0MsTUFBQUEsQ0FBTUgsc0JBQU5HLENBQTZCQyxNQUFBQSxDQUFBQSxDQUFLQyxPQUFBQSxDQUFDLE1BQURBO0lBQ3ZETCxPQUFrQ00sTUFBbENKLGFBQU9DLE1BQUFBLENBQU1ILG9CQUFORyxDQUEyQkcsTUFBQUEsRUFBQUEsQ0FBSSxPQUFKQSxDQUFBQSxFQUFsQ04sYUFBQUEsRUFBQU87OztNQUNFQyxtQkFBbUJOLGFBQU9DLE1BQUFBLENBQU1JLG9CQUFOSixDQUEyQkMsTUFBQUEsQ0FBQUEsQ0FBS0MsT0FBQUEsQ0FBQyxNQUFEQTtNQUMxRCxJQUFBLE9BQUdHLGdCQUFILEVBQXVCUCxXQUF2QixDQUFBO1FBQ0VNLE9BQTRCRSxNQUFBQSxDQUFRRCxnQkFBUkMsQ0FBQUEsRUFBQUEsTUFBNUJQLGFBQU9DLE1BQUFBLENBQU1JLGNBQU5KLENBQXFCTSxTQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtNQUQ5QjtRQWZKRixPQUFBO01BZUksRUFGRlAsQ0FBQUEsR0FBa0NNLEVBRnBDUCxDQUFBQSxHQUFRRjtBQVhSSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ1OTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIoZXhpdCkiXSwic291cmNlc0NvbnRlbnQiOlsiOjpLZXJuZWwuZXhpdFxuIl0sIm5hbWVzIjpbIjxtYWluPiIsIktlcm5lbCIsImV4aXQiXSwibWFwcGluZ3MiOiJBQUFBQSwyQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDLE9BQVFDLE1BQUFBLENBQUFBO0FBQVJGOyJ9fV19
